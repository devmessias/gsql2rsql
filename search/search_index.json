{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gsql2rsql","text":"<p>Query your Delta Tables as a Graph</p> <p>No need for a separate graph database. Write intuitive OpenCypher queries, get Databricks SQL automatically.</p> <p>Why Databricks?</p> <p>Databricks provides tables designed for massive scale, enabling efficient storage and querying of tens of billions of triples with features like time travel No ETL or migration needed\u2014just query your data lake as a graph. Recently, Databricks released support for recursive queries, unlocking the use of SQL warehouses for graph-type queries.</p>"},{"location":"#why-gsql2rsql","title":"Why gsql2rsql?","text":"Challenge Solution Graph queries require complex SQL with <code>WITH RECURSIVE</code> Write 5 lines of Cypher instead Need to maintain a separate graph database Query Delta Lake directly LLM-generated complex SQL is hard to audit Human-readable Cypher + deterministic transpilation (optionally pass to LLM for final optimization) Scaling to tens of billions of triples is costly in graph DBs Delta Lake stores billions of triples efficiently, with Spark scalability"},{"location":"#see-it-in-action","title":"See It in Action","text":"Bash<pre><code>pip install gsql2rsql\n</code></pre> Python<pre><code>from gsql2rsql import GraphContext\n\n# Point to your existing Delta tables - no migration needed\ngraph = GraphContext(\n    nodes_table=\"catalog.fraud.nodes\",\n    edges_table=\"catalog.fraud.edges\",\n)\n\n# Write graph queries with familiar Cypher syntax\nsql = graph.transpile(\"\"\"\n    MATCH path = (origin:Person {id: 12345})-[:TRANSACTION*1..4]-&gt;(dest:Person)\n    WHERE dest.risk_score &gt; 0.8\n    RETURN dest.id, dest.name, dest.risk_score, length(path) AS depth\n    ORDER BY depth, dest.risk_score DESC\n    LIMIT 3\n\"\"\")\n\nprint(sql)\n</code></pre> <p>5 lines of Cypher \u2192 optimized Databricks SQL with recursive CTEs</p> Click to see the generated SQL (auto-generated from transpiler) SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.src AS start_node,\n      e.dst AS end_node,\n      1 AS depth,\n      ARRAY(e.src, e.dst) AS path,\n      ARRAY(NAMED_STRUCT('src', e.src, 'dst', e.dst, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      ARRAY(e.src) AS visited\n    FROM catalog.fraud.edges e\n    JOIN catalog.fraud.nodes src ON src.id = e.src\n    WHERE (relationship_type = 'TRANSACTION') AND (src.id) = (12345)\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.dst AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.dst)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('src', e.src, 'dst', e.dst, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.src)) AS visited\n    FROM paths_1 p\n    JOIN catalog.fraud.edges e\n      ON p.end_node = e.src\n    WHERE p.depth &lt; 4\n      AND NOT ARRAY_CONTAINS(p.visited, e.dst)\n      AND (relationship_type = 'TRANSACTION')\n  )\nSELECT \n   _gsql2rsql_dest_id AS id\n  ,_gsql2rsql_dest_name AS name\n  ,_gsql2rsql_dest_risk_score AS risk_score\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS depth\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_dest_id\n    ,sink.name AS _gsql2rsql_dest_name\n    ,sink.risk_score AS _gsql2rsql_dest_risk_score\n    ,source.id AS _gsql2rsql_origin_id\n    ,source.name AS _gsql2rsql_origin_name\n    ,source.risk_score AS _gsql2rsql_origin_risk_score\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.fraud.nodes sink\n    ON sink.id = p.end_node\n  JOIN catalog.fraud.nodes source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 4 AND (sink.risk_score) &gt; (0.8)\n) AS _proj\nORDER BY depth ASC, _gsql2rsql_dest_risk_score DESC\nLIMIT 3\n</code></pre> <p>Not for OLTP (obviously) or end-user queries</p> <p>This transpiler is for internal analytics and exploration (data science, engineering, analysis). It obviously makes no sense for OLTP  ! If you plan to expose transpiled queries to end users, be careful: implement validation, rate limiting, and security. Use common sense.</p>"},{"location":"#real-world-examples","title":"Real-World Examples","text":"Fraud DetectionCredit AnalysisSocial Network Cypher<pre><code>-- Find fraud rings: accounts connected through suspicious transactions\nMATCH (a:Account)-[:TRANSFER*2..4]-&gt;(b:Account)\nWHERE a.flagged = true AND b.flagged = true\nRETURN DISTINCT a.id, b.id, length(path) AS hops\n</code></pre> <p>See more fraud detection queries \u2192</p> Cypher<pre><code>-- Analyze credit exposure through guarantor chains\nMATCH path = (borrower:Customer)-[:GUARANTEES*1..3]-&gt;(guarantor:Customer)\nWHERE borrower.credit_score &lt; 600\nRETURN borrower.id, COLLECT(guarantor.id) AS chain\n</code></pre> <p>See more credit analysis queries \u2192</p> Cypher<pre><code>-- Friends of friends who work at tech companies\nMATCH (me:Person {id: 123})-[:KNOWS*1..2]-&gt;(friend)-[:WORKS_AT]-&gt;(c:Company)\nWHERE c.industry = 'Technology'\nRETURN DISTINCT friend.name, c.name\n</code></pre> <p>See all feature examples \u2192</p> <p>That's it! No schema boilerplate, no complex setup.</p> <p>Full User Guide \u2192</p>"},{"location":"#low-level-api-without-graphcontext","title":"Low-Level API (Without GraphContext)","text":"<p>For advanced use cases or non-Triple-Store schemas, use the components directly:</p> Python<pre><code>from gsql2rsql import OpenCypherParser, LogicalPlan, SQLRenderer\nfrom gsql2rsql.common.schema import NodeSchema, EdgeSchema, EntityProperty\nfrom gsql2rsql.renderer.schema_provider import SimpleSQLSchemaProvider, SQLTableDescriptor\n\n# 1. Define schema (SimpleSQLSchemaProvider)\nschema = SimpleSQLSchemaProvider()\n\nperson = NodeSchema(\n    name=\"Person\",\n    node_id_property=EntityProperty(\"id\", int),\n    properties=[EntityProperty(\"name\", str)],\n)\nschema.add_node(\n    person,\n    SQLTableDescriptor(table_name=\"people\", node_id_columns=[\"id\"]),\n)\n\nknows = EdgeSchema(\n    name=\"KNOWS\",\n    source_node_id=\"Person\",\n    sink_node_id=\"Person\",\n)\nschema.add_edge(\n    knows,\n    SQLTableDescriptor(table_name=\"friendships\"),\n)\n\n# 2. Transpile\nparser = OpenCypherParser()\nast = parser.parse(\"MATCH (p:Person)-[:KNOWS]-&gt;(f:Person) RETURN p.name, f.name\")\nplan = LogicalPlan.process_query_tree(ast, schema)\nplan.resolve(original_query=\"...\")\n\nrenderer = SQLRenderer(db_schema_provider=schema)\nsql = renderer.render_plan(plan)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature Description Variable-length paths <code>[:REL*1..5]</code> via <code>WITH RECURSIVE</code> Cycle detection Automatic <code>ARRAY_CONTAINS</code> checks Path functions <code>length(path)</code>, <code>nodes(path)</code>, <code>relationships(path)</code> No-label nodes <code>(a)-[:REL]-&gt;(b:Label)</code> matches any node type for <code>a</code> Inline filters <code>(n:Person {id: 123})</code> pushes predicates to source Undirected edges <code>(a)-[:KNOWS]-(b)</code> via optimized UNION ALL Aggregations COUNT, SUM, AVG, COLLECT, etc. Type safety Schema validation before SQL generation"},{"location":"#architecture","title":"Architecture","text":"<p>gsql2rsql uses a 4-phase pipeline for correctness:</p> Text Only<pre><code>OpenCypher \u2192 Parser \u2192 Planner \u2192 Resolver \u2192 Renderer \u2192 SQL\n</code></pre> <ol> <li>Parser: Cypher \u2192 AST (syntax only, no schema)</li> <li>Planner: AST \u2192 Logical operators (semantics)</li> <li>Resolver: Validate columns &amp; types against schema</li> <li>Renderer: Operators \u2192 Databricks SQL</li> </ol> <p>This separation ensures each phase has clear responsibilities and can be tested independently.</p>"},{"location":"#documentation","title":"Documentation","text":"Section Description User Guide Getting started, GraphContext, schema setup Examples 69 complete queries with generated SQL"},{"location":"#project-status","title":"Project Status","text":"<p>Research Project</p> <p>Contributions welcome!</p> <ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE</p>"},{"location":"#inspiration-and-design-differences","title":"Inspiration and Design Differences","text":"<p>gsql2rsql was inspired by the Microsoft openCypherTranspiler, a C# project for transpiling OpenCypher to T-SQL (now discontinued). While the core idea is similar\u2014translating Cypher graph queries to SQL\u2014gsql2rsql introduces several key architectural differences:</p> <ul> <li> <p>Stricter Phase Separation:   gsql2rsql enforces a much stronger separation between the phases of the transpiler pipeline (Parser, Planner, Resolver, Renderer). Each phase has a single responsibility, and the renderer is intentionally kept as \"dumb\" as possible, only emitting SQL from fully-resolved logical plans. This separation makes the codebase easier to maintain, test, and extend.</p> </li> <li> <p>Human-Friendly Debugging:   The architecture is designed for transparency and developer experience. For example, error messages during development are rich and actionable, showing available variables, suggestions, and hints. See the example below:</p> Text Only<pre><code>Makefile:55: warning: ignoring old recipe for target 'test-pyspark-quick'\nTesting recursive query transpilation...\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 ColumnResolutionError: Variable 'rels' is not defined                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2501\u2501\u2501 Query \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n    1 \u2502 MATCH path = (root:Vertex)-[rels:REL*1..5]-(n:Vertex) WHERE root.node_id = '1234_algo' AND n.node_type = 'node_type' AND NONE(r IN rels WHERE r.relationship_type IN ['a', 'b']) RETURN rels AS edges, n AS vertex_info\n      \u2502                             \u25b2\n      \u2502                             \u2514\u2500\u2500 ERROR: Variable 'rels' is not defined\n    2 \u2502\n\n\u2501\u2501\u2501 Available Variables (Scope Level 0) \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Name         Type      Data Type   Defined At              Properties\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  root         entity   Vertex       MATCH (root:Vertex)      node_type, metadata, node_id\n  path         path     PATH         MATCH path = ...         -\n  n            entity   Vertex       MATCH (n:Vertex)         node_type, metadata, node_id\n  edges        value    unknown      RETURN/WITH AS edges     -\n  vertex_info  value    Vertex       RETURN/WITH AS vertex_info -\n\n\u2501\u2501\u2501 Suggestions \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \u2022 Did you mean 'root'? (3 characters difference)\n\n\u2501\u2501\u2501 Hints \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \ud83d\udca1 Make sure 'rels' is defined in a MATCH clause before use.\n     Variables must be defined before they can be referenced in WHERE, WITH, or RETURN clauses.\n\n\u2501\u2501\u2501 Debug Information \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Operator:         ProjectionOperator (id=6)\n  Resolution Phase: expression_resolution\n  Symbol Table:\n    Symbol Table Dump:\n      Scope 0 (global):\n        root: entity(Vertex) @ scope 0\n        path: path(PATH) @ scope 0\n        n: entity(Vertex) @ scope 0\n        edges: value(unknown) @ scope 0\n        vertex_info: value(Vertex) @ scope 0\n</code></pre> </li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#gsql2rsql","title":"gsql2rsql","text":"<p>gsql2rsql is an OpenCypher to Databricks SQL transpiler that enables graph analytics at scale using distributed SQL.</p> <p>This project transforms graph queries into high-performance SQL, allowing you to leverage the power of Databricks while expressing complex graph patterns in the intuitive Cypher query language.</p>"},{"location":"about/#author","title":"Author","text":"<p>Bruno Messias</p> <ul> <li>LinkedIn: bruno-messias-510553193</li> </ul>"},{"location":"about/#license","title":"License","text":"<p>This project is licensed under the MIT License.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files, to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the conditions of the MIT License.</p> <p>See the LICENSE file for full details.</p>"},{"location":"about/#contributing","title":"Contributing","text":"<p>Contributions are welcome! See the Contributing Guide for details on how to get started.</p>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>This guide covers architecture, development workflow, and contribution guidelines.</p>"},{"location":"contributing/#why-contribute","title":"Why Contribute?","text":""},{"location":"contributing/#rich-error-messages","title":"Rich Error Messages","text":"<p>One of the key features of this transpiler is its developer-friendly error messages. When something goes wrong, you get detailed context to quickly identify and fix the issue:</p> Text Only<pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 ColumnResolutionError: Variable 'rels' is not defined                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2501\u2501\u2501 Query \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n    1 \u2502 MATCH path = (root:Vertex)-[rels:REL*1..5]-(n:Vertex) WHERE root.node_id = '1234' RETURN rels\n      \u2502                             \u25b2\n      \u2502                             \u2514\u2500\u2500 ERROR: Variable 'rels' is not defined\n    2 \u2502\n\n\u2501\u2501\u2501 Available Variables (Scope Level 0) \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Name         Type      Data Type   Defined At              Properties\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  root         entity   Vertex       MATCH (root:Vertex)      node_type, metadata, node_id\n  path         path     PATH         MATCH path = ...         -\n  n            entity   Vertex       MATCH (n:Vertex)         node_type, metadata, node_id\n\n\u2501\u2501\u2501 Suggestions \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \u2022 Did you mean 'root'? (3 characters difference)\n\n\u2501\u2501\u2501 Hints \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \ud83d\udca1 Make sure 'rels' is defined in a MATCH clause before use.\n     Variables must be defined before they can be referenced in WHERE, WITH, or RETURN clauses.\n\n\u2501\u2501\u2501 Debug Information \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Operator:         ProjectionOperator (id=6)\n  Resolution Phase: expression_resolution\n  Symbol Table:\n    Symbol Table Dump:\n      Scope 0 (global):\n        root: entity(Vertex) @ scope 0\n        path: path(PATH) @ scope 0\n        n: entity(Vertex) @ scope 0\n</code></pre> <p>Error messages include: - Visual pointer to the exact error location in the query - Available variables at that scope with their types and properties - Suggestions for typos (using Levenshtein distance) - Hints explaining why the error occurred - Debug info for advanced troubleshooting</p>"},{"location":"contributing/#architecture-overview","title":"Architecture Overview","text":""},{"location":"contributing/#high-level-dataflow","title":"High-Level Dataflow","text":"<pre><code>graph TD\n    A[OpenCypher Query String] --&gt; B[Phase 1: Parser]\n    B --&gt; C[Abstract Syntax Tree]\n    C --&gt; D[Phase 2: Planner]\n    D --&gt; E[Logical Operator Tree + SymbolTable]\n    E --&gt; F[Phase 3: Optimizer]\n    F --&gt; G[Optimized Logical Plan]\n    G --&gt; H[Phase 4: Resolver]\n    H --&gt; I[ResolutionResult]\n    I --&gt; J[Phase 5: Renderer]\n    J --&gt; K[Databricks Databricks SQL]\n\n    style B fill:#e1f5ff\n    style D fill:#fff4e1\n    style F fill:#ffe1f5\n    style H fill:#e1ffe1\n    style J fill:#ffe1e1</code></pre>"},{"location":"contributing/#design-principle","title":"Design Principle","text":"<p>Each phase has a single responsibility and does not perform the responsibilities of other phases:</p> <ol> <li>Parser: Syntax only (what is valid Cypher?)</li> <li>Planner: Semantics only (what does it mean logically?)</li> <li>Resolver: Validation only (do all references exist?)</li> <li>Renderer: Implementation only (how to generate SQL?)</li> </ol> <p>This prevents: - Parser from needing schema knowledge - Planner from validating column references - Renderer from making semantic decisions</p>"},{"location":"contributing/#phase-details","title":"Phase Details","text":""},{"location":"contributing/#phase-1-parser-lexicalsyntactic-analysis","title":"Phase 1: Parser (Lexical/Syntactic Analysis)","text":"<p>Location: src/gsql2rsql/parser/</p> <p>Responsibility: Convert OpenCypher query string to Abstract Syntax Tree (AST). Validates syntax only \u2014 does NOT validate semantics, resolve references, or access schema.</p> File Purpose <code>opencypher_parser.py</code> Main entry point, ANTLR runtime invocation <code>ast.py</code> AST node definitions (50+ node types) <code>visitor.py</code> ANTLR visitor pattern implementation <code>operators.py</code> Operator enums (binary, aggregation, functions) <code>grammar/</code> ANTLR-generated parser/lexer <p>Does NOT:</p> <ul> <li>\u274c Validate semantics</li> <li>\u274c Resolve references</li> <li>\u274c Access schema</li> <li>\u274c Perform type checking</li> <li>\u274c Validate property names</li> </ul> <p>Rules:</p> <ul> <li>Parser MUST NOT import from <code>planner/</code>, <code>renderer/</code>, or <code>common/schema.py</code></li> <li>Parser MUST NOT call graph schema provider</li> <li>Parser MUST only validate syntax (grammar rules)</li> </ul>"},{"location":"contributing/#phase-2-planner-logical-operator-construction","title":"Phase 2: Planner (Logical Operator Construction)","text":"<p>Location: src/gsql2rsql/planner/</p> <p>Responsibility: Convert AST to logical relational algebra. Builds symbol table tracking variable definitions and scopes. Does NOT resolve column references or validate property access.</p> File Purpose <code>logical_plan.py</code> Main orchestrator, AST \u2192 operator conversion <code>operators.py</code> Logical operator definitions (11 operator types) <code>symbol_table.py</code> Variable tracking with nested scopes <code>path_analyzer.py</code> Variable-length path optimization <code>schema.py</code> Internal schema representation <code>subquery_optimizer.py</code> Conservative subquery flattening <p>Does NOT:</p> <ul> <li>\u274c Resolve column references</li> <li>\u274c Validate property access</li> <li>\u274c Generate SQL</li> <li>\u274c Query database schema</li> </ul> <p>Rules:</p> <ul> <li>Planner CAN import from <code>parser/</code> (uses AST)</li> <li>Planner CAN import from <code>common/schema.py</code> (uses GraphSchema)</li> <li>Planner MUST NOT import from <code>renderer/</code></li> <li>Planner MUST NOT perform column resolution (that's Phase 4)</li> </ul>"},{"location":"contributing/#phase-3-optimizer-conservative-transformations","title":"Phase 3: Optimizer (Conservative Transformations)","text":"<p>Location: src/gsql2rsql/planner/subquery_optimizer.py</p> <p>Responsibility: Apply conservative transformations to reduce SQL nesting. Only flattens patterns guaranteed to preserve semantics.</p> <p>Safe to Flatten: - \u2705 Selection \u2192 Projection: <code>WHERE</code> can be pushed before <code>SELECT</code> - \u2705 Selection \u2192 Selection: Multiple <code>WHERE</code> clauses can be merged</p> <p>NEVER Flattened: - \u274c Projection \u2192 Projection: Aliases must stay in separate subqueries - \u274c Anything involving aggregation boundaries: Aggregation semantics are fragile</p> <p>Configuration: Enabled by default. Disable with <code>--no-optimize</code> CLI flag.</p>"},{"location":"contributing/#phase-4-resolver-column-reference-validation","title":"Phase 4: Resolver (Column Reference Validation)","text":"<p>Location: src/gsql2rsql/planner/column_resolver.py</p> <p>Responsibility: Validate ALL column references before rendering. Query schema for entity properties. Build resolution context for SQL generation.</p> File Purpose <code>column_resolver.py</code> Main resolver implementation <code>column_ref.py</code> Resolved reference objects <p>Does NOT:</p> <ul> <li>\u274c Generate SQL</li> <li>\u274c Modify logical plan structure</li> <li>\u274c Perform optimizations</li> </ul> <p>Rules:</p> <ul> <li>Resolver CAN import from <code>parser/</code>, <code>planner/</code>, <code>common/</code></li> <li>Resolver MUST NOT import from <code>renderer/</code></li> <li>Resolver MUST validate ALL column refs before SQL generation</li> <li>Resolver MUST provide rich error messages with suggestions</li> </ul>"},{"location":"contributing/#phase-5-renderer-sql-generation","title":"Phase 5: Renderer (SQL Generation)","text":"<p>Location: src/gsql2rsql/renderer/sql_renderer.py</p> <p>Responsibility: Generate Databricks Databricks SQL from logical plan using pre-resolved column references. Handle SQL dialect specifics.</p> File Purpose <code>sql_renderer.py</code> Main SQL code generator <code>schema_provider.py</code> Database schema provider interface <p>Does NOT:</p> <ul> <li>\u274c Resolve columns</li> <li>\u274c Validate references</li> <li>\u274c Make semantic decisions</li> </ul> <p>Rules:</p> <ul> <li>Renderer CAN import from all phases (uses everything)</li> <li>Renderer MUST use <code>ResolutionResult</code> for all column refs</li> <li>Renderer MUST NOT resolve columns itself</li> <li>Renderer MUST NOT perform semantic validation</li> </ul>"},{"location":"contributing/#quick-start-for-contributors","title":"Quick Start for Contributors","text":""},{"location":"contributing/#1-set-up-development-environment","title":"1. Set Up Development Environment","text":""},{"location":"contributing/#option-a-using-makefile-recommended","title":"Option A: Using Makefile (Recommended)","text":"Bash<pre><code># Clone repository\ngit clone https://github.com/your-org/cyper2dsql.git\ncd cyper2dsql/python\n\n# Create virtual environment and install dev dependencies\nmake venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nmake install-dev\n</code></pre>"},{"location":"contributing/#option-b-using-uv-directly-if-make-is-not-available","title":"Option B: Using uv directly (if make is not available)","text":"Bash<pre><code># Clone repository\ngit clone https://github.com/your-org/cyper2dsql.git\ncd cyper2dsql/python\n\n# Create virtual environment with uv\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install dependencies (dev mode)\nuv sync --extra dev\nuv pip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#2-verify-installation","title":"2. Verify Installation","text":""},{"location":"contributing/#using-makefile","title":"Using Makefile","text":"Bash<pre><code>make test-no-pyspark  # Run fast test suite (excludes PySpark)\nmake check            # Run linter + type checker\nmake cli-example      # Transpile example query\n</code></pre>"},{"location":"contributing/#using-uv-directly","title":"Using uv directly","text":"Bash<pre><code>uv run pytest tests/ -v --ignore=tests/test_examples_with_pyspark.py --ignore=tests/test_pyspark_basic.py\nuv run ruff check src/ tests/\nuv run pyright src/\necho \"MATCH (p:Person)-[:KNOWS]-&gt;(f:Person) RETURN p.name, f.name\" | uv run gsql2rsql transpile -s examples/schema.json\n</code></pre>"},{"location":"contributing/#available-make-commands","title":"Available Make Commands","text":"<p>Run <code>make help</code> to see all available commands:</p> Command Description <code>make install-dev</code> Install with dev dependencies <code>make test</code> Run all tests (including PySpark) <code>make test-no-pyspark</code> Run fast tests (excludes PySpark) <code>make test-cov</code> Run tests with coverage report <code>make check</code> Run lint + format check + typecheck <code>make format</code> Auto-format code <code>make lint-fix</code> Auto-fix linting issues <code>make typecheck</code> Run pyright type checker <code>make typecheck-mypy</code> Run mypy type checker"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<p>Before coding: 1. Read phase details (critical!) 2. Identify which phase your change affects (parser, planner, resolver, or renderer) 3. Add tests first (TDD recommended)</p> <p>Development loop:</p> Using MakefileUsing uv directly Bash<pre><code># 1. Make changes to src/\n# 2. Run fast tests\nmake test-no-pyspark\n\n# 3. Run all checks\nmake check\n\n# 4. Update golden files if SQL output changes\nmake dump-sql-save ID=01 NAME=simple_node_lookup\n\n# 5. Run full test suite\nmake test\n</code></pre> Bash<pre><code># 1. Make changes to src/\n# 2. Run fast tests\nuv run pytest tests/ -v --ignore=tests/test_examples_with_pyspark.py --ignore=tests/test_pyspark_basic.py\n\n# 3. Run lint and type checks\nuv run ruff check src/ tests/\nuv run pyright src/\n\n# 4. Run full test suite\nuv run pytest tests/ -n 6\n</code></pre>"},{"location":"contributing/#4-submit-changes","title":"4. Submit Changes","text":"Using MakefileUsing uv directly Bash<pre><code># Format code\nmake format\n\n# Run all checks\nmake check\n\n# Run full test suite (including PySpark)\nmake test\n\n# Commit with descriptive message\ngit add .\ngit commit -m \"feat: add support for map projection in RETURN clause\"\n\n# Push and create PR\ngit push origin feature/map-projection\n</code></pre> Bash<pre><code># Format code\nuv run ruff format src/ tests/\n\n# Run lint and type checks\nuv run ruff check src/ tests/\nuv run pyright src/\n\n# Run full test suite\nuv run pytest tests/ -n 6\n\n# Commit with descriptive message\ngit add .\ngit commit -m \"feat: add support for map projection in RETURN clause\"\n\n# Push and create PR\ngit push origin feature/map-projection\n</code></pre>"},{"location":"contributing/#architectural-examples","title":"Architectural Examples","text":""},{"location":"contributing/#valid-vs-invalid-changes","title":"Valid vs Invalid Changes","text":""},{"location":"contributing/#parser-example","title":"Parser Example","text":"<p>Valid Change - Adding a new AST node type: Python<pre><code># \u2705 Adding a new AST node type for a new Cypher construct\nclass QueryExpressionPatternComprehension(QueryExpression):\n    pattern: QueryPattern\n    where_clause: Optional[WhereClause]\n    projection: QueryExpression\n</code></pre></p> <p>Invalid Change - Parser accessing schema: Python<pre><code># \u274c WRONG: Parser accessing schema\nclass CypherVisitor:\n    def visitPropertyExpression(self, ctx):\n        entity_name = self._get_entity_name(ctx)\n        # \u274c WRONG: Don't validate property existence here\n        if not self.schema.has_property(entity_name, property_name):\n            raise Exception(\"Property not found\")\n</code></pre></p>"},{"location":"contributing/#planner-example","title":"Planner Example","text":"<p>Valid Change - Adding a new logical operator: Python<pre><code># \u2705 Adding a new logical operator\nclass WindowOperator(LogicalOperator):\n    \"\"\"Represents a window function (OVER clause).\"\"\"\n    partition_by: list[str]\n    order_by: list[OrderByItem]\n    window_function: WindowFunction\n</code></pre></p> <p>Invalid Change - Planner resolving column references: Python<pre><code># \u274c WRONG: Planner resolving column references\nclass LogicalPlan:\n    def _process_projection(self, projection: ProjectionItem):\n        # \u274c WRONG: Don't resolve column refs during planning\n        resolved_ref = self._resolve_column_reference(projection.expression)\n        # Column resolution belongs in Phase 4 (Resolver)\n</code></pre></p>"},{"location":"contributing/#renderer-example","title":"Renderer Example","text":"<p>Valid Change - Adding support for new SQL function: Python<pre><code># \u2705 Adding support for new SQL function\nclass SQLRenderer:\n    def _render_function(self, func: Function, args: list[str]) -&gt; str:\n        if func == Function.RTRIM:\n            # New function mapping\n            return f\"RTRIM({', '.join(args)})\"\n        # ... existing functions\n</code></pre></p> <p>Invalid Change - Renderer resolving columns: Python<pre><code># \u274c WRONG: Renderer resolving columns\nclass SQLRenderer:\n    def _render_property_access(self, entity: str, property: str) -&gt; str:\n        # \u274c WRONG: Don't resolve property here\n        if not self.schema.has_property(entity, property):\n            raise Exception(\"Property not found\")\n        # Resolution should already be done in Phase 4\n</code></pre></p>"},{"location":"contributing/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"contributing/#adding-a-new-cypher-feature","title":"Adding a New Cypher Feature","text":"<p>Example: Add support for <code>range()</code> function</p> <ol> <li> <p>Phase 1 (Parser): Add to grammar or AST if needed    Python<pre><code># If new function, add to Function enum in operators.py\nclass Function(Enum):\n    RANGE = \"range\"  # Generate sequence of integers\n</code></pre></p> </li> <li> <p>Phase 2 (Planner): Handle in operator construction (if needed)    Python<pre><code># Usually functions are just expressions, no special operator needed\n</code></pre></p> </li> <li> <p>Phase 4 (Resolver): Type checking (if needed)    Python<pre><code># Add type evaluation rule\ndef _evaluate_function_type(self, func: Function, args: list[DataType]) -&gt; DataType:\n    if func == Function.RANGE:\n        return DataType.LIST_INT\n</code></pre></p> </li> <li> <p>Phase 5 (Renderer): Add SQL generation    Python<pre><code>class SQLRenderer:\n    def _render_function(self, func: Function, args: list[str]) -&gt; str:\n        if func == Function.RANGE:\n            # Databricks: sequence(start, stop, step)\n            return f\"sequence({args[0]}, {args[1]})\"\n</code></pre></p> </li> <li> <p>Add Tests: Golden file test + unit tests    Bash<pre><code># Create test_46_range_function.py\n# Generate golden file\nmake dump-sql-save ID=46 NAME=range_function\n</code></pre></p> </li> </ol>"},{"location":"contributing/#fixing-a-bug","title":"Fixing a Bug","text":"<p>Example: Fix incorrect null handling in OPTIONAL MATCH</p> <ol> <li> <p>Write failing test first (TDD)    Python<pre><code># tests/test_optional_match_null_bug.py\ndef test_optional_match_null_handling():\n    cypher = \"MATCH (p:Person) OPTIONAL MATCH (p)-[:KNOWS]-&gt;(f) RETURN p.name, f.name\"\n    sql = transpile(cypher)\n    # Should use COALESCE for f.name\n    assert \"COALESCE\" in sql\n</code></pre></p> </li> <li> <p>Run test (should fail)    Bash<pre><code>pytest tests/test_optional_match_null_bug.py -v\n</code></pre></p> </li> <li> <p>Identify the phase where the bug is (use <code>--explain-scopes</code> for debugging)    Bash<pre><code>echo \"MATCH (p) OPTIONAL MATCH (p)-[:KNOWS]-&gt;(f) RETURN p.name, f.name\" | \\\n  uv run gsql2rsql transpile -s examples/schema.json --explain-scopes\n</code></pre></p> </li> <li> <p>Fix the bug in the appropriate phase    Python<pre><code># src/gsql2rsql/renderer/sql_renderer.py\ndef _render_optional_property(self, ref: ResolvedColumnRef) -&gt; str:\n    if ref.is_from_optional_match:\n        # \u2705 Add COALESCE for null handling\n        return f\"COALESCE({ref.sql_column_name}, NULL)\"\n    return ref.sql_column_name\n</code></pre></p> </li> <li> <p>Run tests (should pass now)    Bash<pre><code>pytest tests/test_optional_match_null_bug.py -v\nmake test-no-pyspark\n</code></pre></p> </li> <li> <p>Update golden files if SQL output changed    Bash<pre><code>make diff-all  # Review changes\nmake dump-sql-save ID=09 NAME=optional_match  # Update if correct\n</code></pre></p> </li> </ol>"},{"location":"contributing/#debugging-transpilation-issues","title":"Debugging Transpilation Issues","text":"<p>Step 1: Isolate the query Bash<pre><code># Save problematic query to file\necho \"MATCH (n:Node) WHERE n.prop &gt; 10 RETURN n\" &gt; debug_query.cypher\n</code></pre></p> <p>Step 2: Inspect AST Bash<pre><code>uv run gsql2rsql parse -i debug_query.cypher\n</code></pre></p> <p>Step 3: Inspect logical plan Python<pre><code># In Python REPL or script\nfrom gsql2rsql import OpenCypherParser, LogicalPlan\nfrom gsql2rsql.renderer.schema_provider import SimpleSQLSchemaProvider\n\nparser = OpenCypherParser()\nast = parser.parse(open(\"debug_query.cypher\").read())\n\nschema = SimpleSQLSchemaProvider()\n# ... add schema\n\nplan = LogicalPlan.process_query_tree(ast, schema)\nprint(plan.dump_graph())  # Visualize operator tree\n</code></pre></p> <p>Step 4: Check scopes Bash<pre><code>uv run gsql2rsql transpile -s examples/schema.json -i debug_query.cypher --explain-scopes\n</code></pre></p>"},{"location":"contributing/#testing-error-messages","title":"Testing Error Messages","text":"<p>The transpiler has rich error messages. To test error behavior:</p> Bash<pre><code># Test a query that should produce an error\nmake test-recursive-query\n\n# Or manually test with a bad query\necho \"MATCH (n:Person) RETURN undefined_var\" | uv run gsql2rsql transpile -s examples/schema.json\n</code></pre> <p>Error messages are generated in <code>src/gsql2rsql/common/exceptions.py</code>. When adding new error types:</p> <ol> <li>Create a descriptive error class</li> <li>Include context (query, position, available variables)</li> <li>Add helpful suggestions (typo detection, hints)</li> <li>Test the error message visually</li> </ol>"},{"location":"contributing/#inspiration-and-design-differences","title":"Inspiration and Design Differences","text":"<p>gsql2rsql was inspired by the Microsoft openCypherTranspiler, a C# project for transpiling OpenCypher to T-SQL (now discontinued). While the core idea is similar\u2014translating Cypher graph queries to SQL\u2014gsql2rsql introduces several key architectural differences:</p> <ul> <li> <p>Stricter Phase Separation:   gsql2rsql enforces a much stronger separation between the phases of the transpiler pipeline (Parser, Planner, Resolver, Renderer). Each phase has a single responsibility, and the renderer is intentionally kept as \"dumb\" as possible, only emitting SQL from fully-resolved logical plans. This separation makes the codebase easier to maintain, test, and extend.</p> </li> <li> <p>Human-Friendly Debugging:   The architecture is designed for transparency and developer experience. For example, error messages during development are rich and actionable, showing available variables, suggestions, and hints. See the example below:</p> Text Only<pre><code>Makefile:55: warning: ignoring old recipe for target 'test-pyspark-quick'\nTesting recursive query transpilation...\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 ColumnResolutionError: Variable 'rels' is not defined                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2501\u2501\u2501 Query \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n    1 \u2502 MATCH path = (root:Vertex)-[rels:REL*1..5]-(n:Vertex) WHERE root.node_id = '1234_algo' AND n.node_type = 'node_type' AND NONE(r IN rels WHERE r.relationship_type IN ['a', 'b']) RETURN rels AS edges, n AS vertex_info\n      \u2502                             \u25b2\n      \u2502                             \u2514\u2500\u2500 ERROR: Variable 'rels' is not defined\n    2 \u2502\n\n\u2501\u2501\u2501 Available Variables (Scope Level 0) \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Name         Type      Data Type   Defined At              Properties\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  root         entity   Vertex       MATCH (root:Vertex)      node_type, metadata, node_id\n  path         path     PATH         MATCH path = ...         -\n  n            entity   Vertex       MATCH (n:Vertex)         node_type, metadata, node_id\n  edges        value    unknown      RETURN/WITH AS edges     -\n  vertex_info  value    Vertex       RETURN/WITH AS vertex_info -\n\n\u2501\u2501\u2501 Suggestions \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \u2022 Did you mean 'root'? (3 characters difference)\n\n\u2501\u2501\u2501 Hints \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \ud83d\udca1 Make sure 'rels' is defined in a MATCH clause before use.\n     Variables must be defined before they can be referenced in WHERE, WITH, or RETURN clauses.\n\n\u2501\u2501\u2501 Debug Information \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Operator:         ProjectionOperator (id=6)\n  Resolution Phase: expression_resolution\n  Symbol Table:\n    Symbol Table Dump:\n      Scope 0 (global):\n        root: entity(Vertex) @ scope 0\n        path: path(PATH) @ scope 0\n        n: entity(Vertex) @ scope 0\n        edges: value(unknown) @ scope 0\n        vertex_info: value(Vertex) @ scope 0\n</code></pre> </li> </ul>"},{"location":"table-design/","title":"Making Databricks Delta  Tables Graph Friendly","text":"<p>How to structure your Delta tables to enable graph queries with gsql2rsql.</p>"},{"location":"table-design/#why-delta-lake-for-graphs","title":"Why Delta Lake for Graphs?","text":"<p>Delta Lake can store terabytes of graph data efficiently while still enabling fast queries:</p> <ul> <li>ACID transactions</li> <li>Time travel for auditing and debugging</li> <li>Efficient storage</li> <li>Data skipping to reduce I/O</li> </ul> <p>Instead of maintaining a separate graph database, you can query your existing Delta tables as a graph.</p>"},{"location":"table-design/#the-triple-store-pattern","title":"The Triple Store Pattern","text":"<p>One approach I find convenient is the Triple Store pattern: one table for nodes, one table for edges.</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   nodes table   \u2502         \u2502   edges table   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 node_id (PK)    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 src (FK)        \u2502\n\u2502 node_type       \u2502         \u2502 dst (FK)        \u2502\n\u2502 ...properties   \u2502         \u2502 relationship_type\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502 ...properties   \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This is not the only approach, and may not be optimal for your use case. But it's flexible and works well with gsql2rsql's <code>GraphContext</code> API.</p>"},{"location":"table-design/#nodes-table","title":"Nodes Table","text":"SQL<pre><code>CREATE TABLE catalog.schema.nodes (\n    node_id STRING NOT NULL,\n    node_type STRING NOT NULL,  -- 'Person', 'Company', etc.\n    name STRING,\n    -- ... other properties\n)\nUSING DELTA;\n</code></pre>"},{"location":"table-design/#edges-table","title":"Edges Table","text":"SQL<pre><code>CREATE TABLE catalog.schema.edges (\n    src STRING NOT NULL,\n    dst STRING NOT NULL,\n    relationship_type STRING NOT NULL,  -- 'KNOWS', 'WORKS_AT', etc.\n    -- ... edge properties\n)\nUSING DELTA;\n</code></pre>"},{"location":"table-design/#alternative-separate-tables","title":"Alternative: Separate Tables","text":"<p>If you already have separate tables per entity type, gsql2rsql supports that too via the low-level API:</p> Text Only<pre><code>people (id, name, email)\ncompanies (id, name, industry)\nemployment (person_id, company_id, role)\n</code></pre> <p>See Low-Level API for how to configure this.</p>"},{"location":"table-design/#databricks-optimizations","title":"Databricks Optimizations","text":"<p>Under Construction</p> <p>This section covers Databricks-specific optimizations. The best approach depends on many factors: data size, query patterns, cluster configuration, and whether you're using Photon.</p>"},{"location":"table-design/#photon-for-graph-queries","title":"Photon for Graph Queries","text":"<p>Cost Consideration</p> <p>IN MY EXPERIENCE, enabling Photon can almost double your compute costs. Evaluate whether the performance gains justify the expense for your workload.</p> <p>Photon is Databricks' vectorized query engine. It can significantly accelerate graph queries, especially:</p> <ul> <li>Large joins (node-edge-node patterns)</li> <li>Recursive CTEs (<code>WITH RECURSIVE</code>)</li> <li>Aggregations over paths</li> </ul>"},{"location":"table-design/#liquid-clustering-vs-partitioning-with-z-order","title":"Liquid Clustering vs Partitioning with Z-ORDER","text":"<p>HARD TO PREDICT</p> <p>IN MY EXPERIENCE, Liquid Clustering performance is very hard to predict. It can be great or terrible depending on your data distribution, query patterns, and table size. Always benchmark with your actual workload before committing.</p>"},{"location":"table-design/#which-columns-to-optimize","title":"Which Columns to Optimize?","text":"<p>For graph queries, the most important columns are:</p> Table Key Columns Why Edges <code>src</code>, <code>dst</code> Join predicates in traversals Nodes <code>node_id</code> Join target from edges <p>Secondary columns (less impact):</p> Table Column When Useful Edges <code>relationship_type</code> If you filter by edge type frequently Nodes <code>node_type</code> If you filter by node type frequently"},{"location":"table-design/#liquid-clustering","title":"Liquid Clustering","text":"SQL<pre><code>CREATE TABLE catalog.schema.edges (\n    src STRING,\n    dst STRING,\n    relationship_type STRING\n)\nUSING DELTA\nCLUSTER BY (src, dst);\n</code></pre> <p>Pros: - Automatic optimization (no manual <code>OPTIMIZE</code> runs) - Adapts to changing data patterns</p> <p>Cons: - Performance can be unpredictable - Less control over clustering behavior - May not work well with high-cardinality columns</p>"},{"location":"table-design/#partitioning-z-order","title":"Partitioning + Z-ORDER","text":"SQL<pre><code>-- Create with partitioning (if you have clear access patterns)\nCREATE TABLE catalog.schema.edges (...)\nUSING DELTA\nPARTITIONED BY (relationship_type);\n\n-- Then Z-ORDER on join columns\nOPTIMIZE catalog.schema.edges\nZORDER BY (src, dst);\n</code></pre> <p>Pros: - More predictable behavior - Fine-grained control - Well-understood optimization</p> <p>Cons: - Requires periodic <code>OPTIMIZE</code> runs - Partitioning can create small file problems</p>"},{"location":"table-design/#when-to-use-what","title":"When to Use What?","text":"Scenario Recommendation New table, uncertain query patterns Start with Z-ORDER only, benchmark LC later Existing table Z-ORDER on <code>(src, dst)</code> Very large table (TB+) with clear partition key Consider partitioning + Z-ORDER Queries always filter by edge type first Maybe partition by <code>relationship_type</code> <p>My Recommendation</p> <p>Start simple: no partitioning, just <code>ZORDER BY (src, dst)</code>. Measure performance. Only add complexity (LC or partitioning) if you have a clear problem to solve.</p>"},{"location":"table-design/#data-skipping","title":"Data Skipping","text":"<p>Delta Lake automatically tracks min/max statistics for data skipping. To maximize effectiveness:</p> <ol> <li>Z-Order on join columns (<code>src</code>, <code>dst</code>, <code>node_id</code>) - this is the most important</li> <li>Keep column cardinality reasonable - very high cardinality reduces skipping effectiveness</li> </ol>"},{"location":"table-design/#bloom-filters","title":"Bloom Filters","text":"<p>HELP WANTED!</p>"},{"location":"table-design/#data-skew","title":"Data Skew","text":"<p>Graph data is often highly skewed - some nodes have many more connections than others (e.g., celebrity accounts, hub nodes). Also, some relationship types are far more frequent than others</p>"},{"location":"table-design/#why-skew-matters","title":"Why Skew Matters","text":"Problem Impact Hot partitions Some tasks take much longer than others Uneven file sizes Z-ORDER/LC less effective Join explosions Popular nodes cause massive intermediate results"},{"location":"table-design/#detecting-skew","title":"Detecting Skew","text":""},{"location":"table-design/#mitigating-skew","title":"Mitigating Skew","text":"<p>HELP WANTED</p>"},{"location":"table-design/#column-naming","title":"Column Naming","text":"<p>gsql2rsql uses sensible defaults. Override them if your tables use different names:</p> Python<pre><code>graph = GraphContext(\n    nodes_table=\"my_nodes\",\n    edges_table=\"my_edges\",\n\n    # Custom column names\n    node_id_col=\"id\",              # default: \"node_id\"\n    node_type_col=\"type\",          # default: \"node_type\"\n    edge_src_col=\"source\",         # default: \"src\"\n    edge_dst_col=\"target\",         # default: \"dst\"\n    edge_type_col=\"rel_type\",      # default: \"relationship_type\"\n)\n</code></pre>"},{"location":"table-design/#whats-missing","title":"What's Missing","text":"<p>Topics to be expanded (Help wanted)</p> <ul> <li>Benchmarks comparing optimization strategies</li> <li>Guidance for very large graphs (billions of edges)</li> <li>Cost-based optimization considerations</li> </ul>"},{"location":"table-design/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Start using gsql2rsql</li> <li>Examples - Real-world query examples</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide covers everything you need to start using gsql2rsql to transpile OpenCypher queries to Databricks SQL.</p> <p>Looking for examples?</p> <p>After learning the basics, check out complete query examples:</p> <ul> <li>Fraud Detection - Fraud rings, money laundering patterns</li> <li>Credit Analysis - Risk assessment, guarantor chains</li> <li>All Features - 69 queries covering every feature</li> </ul>"},{"location":"user-guide/#installation","title":"Installation","text":"Bash<pre><code>pip install gsql2rsql\n</code></pre> <p>Requirements:</p> <ul> <li>Python 3.12+</li> <li>Databricks Runtime 15+ only needed to execute the generated SQL</li> </ul>"},{"location":"user-guide/#try-it-now","title":"Try It Now","text":"<p>No database needed! Just define a schema and generate SQL:</p> Python<pre><code>from gsql2rsql import GraphContext\n\n# Table names are just strings - no database connection required\ngraph = GraphContext(\n    nodes_table=\"my_nodes\",\n    edges_table=\"my_edges\",\n)\ngraph.set_types(\n    node_types=[\"Person\", \"Company\"],\n    edge_types=[\"WORKS_AT\"],\n)\n\n# Generate SQL from OpenCypher\nsql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:WORKS_AT]-&gt;(c:Company)\n    RETURN p.node_id, c.node_id\n\"\"\")\n\nprint(sql)  # Copy this SQL to run on Databricks\n</code></pre> Generated SQL Output SQL<pre><code>SELECT\n   _gsql2rsql_p_node_id AS node_id\n  ,_gsql2rsql_c_node_id AS node_id\nFROM (\n  SELECT\n     _left._gsql2rsql_p_node_id AS _gsql2rsql_p_node_id\n    ,_right._gsql2rsql_c_node_id AS _gsql2rsql_c_node_id\n  FROM (\n    SELECT\n       _left._gsql2rsql_p_node_id AS _gsql2rsql_p_node_id\n    FROM (\n      SELECT node_id AS _gsql2rsql_p_node_id\n      FROM my_nodes WHERE (node_type = 'Person')\n    ) AS _left\n    INNER JOIN (\n      SELECT src AS _gsql2rsql__anon1_src, dst AS _gsql2rsql__anon1_dst\n      FROM my_edges WHERE (relationship_type = 'WORKS_AT')\n    ) AS _right\n    ON _left._gsql2rsql_p_node_id = _right._gsql2rsql__anon1_src\n  ) AS _left\n  INNER JOIN (\n    SELECT node_id AS _gsql2rsql_c_node_id\n    FROM my_nodes WHERE (node_type = 'Company')\n  ) AS _right\n  ON _right._gsql2rsql_c_node_id = _left._gsql2rsql__anon1_dst\n) AS _proj\n</code></pre>"},{"location":"user-guide/#graphcontext-full-configuration","title":"GraphContext: Full Configuration","text":"<p>GraphContext is the recommended API for graph data stored in the Triple Store pattern (one nodes table + one edges table). It eliminates ~100 lines of schema boilerplate.</p>"},{"location":"user-guide/#with-nodeedge-attributes","title":"With Node/Edge Attributes","text":"Python<pre><code>from gsql2rsql import GraphContext\n\n# Define schema with additional attributes\ngraph = GraphContext(\n    nodes_table=\"catalog.schema.nodes\",\n    edges_table=\"catalog.schema.edges\",\n    extra_node_attrs={\"name\": str, \"age\": int, \"score\": float},\n    extra_edge_attrs={\"weight\": float, \"timestamp\": str},\n)\n\ngraph.set_types(\n    node_types=[\"Person\", \"Company\", \"Account\"],\n    edge_types=[\"KNOWS\", \"WORKS_AT\", \"OWNS\"],\n)\n\n# Now you can use those attributes in queries\nsql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:WORKS_AT]-&gt;(c:Company)\n    WHERE c.industry = 'Technology'\n    RETURN p.name, c.name AS company\n    LIMIT 100\n\"\"\")\n\nprint(sql)\n</code></pre> Generated SQL SQL<pre><code>SELECT\n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_c_name AS company\nFROM (\n  SELECT\n     _left._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_right._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right._gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_right._gsql2rsql_c_industry AS _gsql2rsql_c_industry\n  FROM (\n    SELECT\n       _left._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right._gsql2rsql__anon1_src AS _gsql2rsql__anon1_src\n      ,_right._gsql2rsql__anon1_dst AS _gsql2rsql__anon1_dst\n    FROM (\n      SELECT id AS _gsql2rsql_p_id, name AS _gsql2rsql_p_name\n      FROM catalog.schema.nodes\n      WHERE (node_type = 'Person')\n    ) AS _left\n    INNER JOIN (\n      SELECT src AS _gsql2rsql__anon1_src, dst AS _gsql2rsql__anon1_dst\n      FROM catalog.schema.edges\n      WHERE (relationship_type = 'WORKS_AT')\n    ) AS _right\n    ON _left._gsql2rsql_p_id = _right._gsql2rsql__anon1_src\n  ) AS _left\n  INNER JOIN (\n    SELECT id AS _gsql2rsql_c_id, name AS _gsql2rsql_c_name, industry AS _gsql2rsql_c_industry\n    FROM catalog.schema.nodes\n    WHERE (node_type = 'Company') AND ((industry) = ('Technology'))\n  ) AS _right\n  ON _right._gsql2rsql_c_id = _left._gsql2rsql__anon1_dst\n) AS _proj\nLIMIT 100\n</code></pre>"},{"location":"user-guide/#graphcontext-parameters","title":"GraphContext Parameters","text":"Parameter Type Description <code>nodes_table</code> str Full path to nodes table (e.g., <code>catalog.schema.nodes</code>) <code>edges_table</code> str Full path to edges table <code>node_type_col</code> str Column for node type (default: <code>\"node_type\"</code>) <code>edge_type_col</code> str Column for edge type (default: <code>\"relationship_type\"</code>) <code>node_id_col</code> str Column for node ID (default: <code>\"node_id\"</code>) <code>edge_src_col</code> str Column for edge source (default: <code>\"src\"</code>) <code>edge_dst_col</code> str Column for edge destination (default: <code>\"dst\"</code>) <code>extra_node_attrs</code> dict Additional node properties <code>{name: type}</code> <code>extra_edge_attrs</code> dict Additional edge properties <code>{name: type}</code> <code>spark</code> SparkSession Optional: for auto-discovery and execution"},{"location":"user-guide/#expected-table-structure","title":"Expected Table Structure","text":"<p>Nodes table:</p> Column Description <code>node_id</code> Unique node identifier <code>node_type</code> Node label (Person, Company, etc.) <code>name</code>, <code>age</code>, ... Node properties <p>Edges table:</p> Column Description <code>src</code> Source node ID <code>dst</code> Destination node ID <code>relationship_type</code> Edge label (KNOWS, WORKS_AT, etc.) <code>weight</code>, ... Edge properties"},{"location":"user-guide/#no-label-nodes-wildcard-matching","title":"No-Label Nodes (Wildcard Matching)","text":"<p>GraphContext automatically enables no-label support, allowing nodes without explicit labels in queries:</p> Python<pre><code># Node 'a' has no label - matches ANY node type\nsql = graph.transpile(\"\"\"\n    MATCH (a)-[:WORKS_AT]-&gt;(c:Company)\n    RETURN a, c.name\n\"\"\")\n</code></pre> <p>This is useful when:</p> <ul> <li>You don't know or care about the source node type</li> <li>You want to match multiple node types at once</li> <li>You're exploring relationships without type constraints</li> </ul> <p>Performance Impact</p> <p>No-label nodes cause full table scans on the nodes table (no <code>WHERE node_type = '...'</code> filter). Use explicit labels whenever possible for production queries.</p>"},{"location":"user-guide/#variable-length-paths","title":"Variable-Length Paths","text":"<p>One of gsql2rsql's most powerful features is support for variable-length paths using <code>WITH RECURSIVE</code>.</p> Python<pre><code>sql = graph.transpile(\"\"\"\n    MATCH path = (origin:Person {id: 12345})-[:KNOWS*1..3]-&gt;(friend:Person)\n    RETURN friend.name, length(path) AS hops\n    ORDER BY hops\n\"\"\")\n</code></pre> <p>Key features:</p> <ul> <li>Depth bounds: <code>*1..3</code> means 1 to 3 hops</li> <li>Cycle detection: Automatic <code>ARRAY_CONTAINS</code> checks prevent infinite loops</li> <li>Path functions: <code>length(path)</code>, <code>nodes(path)</code>, <code>relationships(path)</code></li> <li>Path variable: Captures the entire path for analysis</li> </ul>"},{"location":"user-guide/#inline-filters","title":"Inline Filters","text":"<p>Use inline property filters for better performance:</p> Python<pre><code># Inline filter (optimized - pushed to source scan)\nsql = graph.transpile(\"\"\"\n    MATCH (p:Person {status: 'active'})-[:KNOWS]-&gt;(friend)\n    RETURN p.name, friend.name\n\"\"\")\n\n# Equivalent WHERE clause (less optimized)\nsql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:KNOWS]-&gt;(friend)\n    WHERE p.status = 'active'\n    RETURN p.name, friend.name\n\"\"\")\n</code></pre> <p>Inline filters are pushed down to the data source scan, reducing the amount of data processed.</p>"},{"location":"user-guide/#undirected-relationships","title":"Undirected Relationships","text":"<p>Use <code>-[:REL]-</code> (without arrow) for undirected relationships:</p> Python<pre><code>sql = graph.transpile(\"\"\"\n    MATCH (a:Person)-[:KNOWS]-(b:Person)\n    WHERE a.id = 123\n    RETURN b.name\n\"\"\")\n</code></pre> <p>This generates a <code>UNION ALL</code> query to match both directions efficiently.</p>"},{"location":"user-guide/#aggregations","title":"Aggregations","text":"<p>Standard aggregation functions are supported:</p> Python<pre><code>sql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:WORKS_AT]-&gt;(c:Company)\n    RETURN c.name, COUNT(p) AS employees, AVG(p.salary) AS avg_salary\n    ORDER BY employees DESC\n\"\"\")\n</code></pre> <p>Supported functions: <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>, <code>COLLECT</code>, <code>COUNT(DISTINCT ...)</code></p>"},{"location":"user-guide/#with-clauses","title":"WITH Clauses","text":"<p>Chain multiple query stages with <code>WITH</code>:</p> Python<pre><code>sql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:WORKS_AT]-&gt;(c:Company)\n    WITH c, COUNT(p) AS employee_count\n    WHERE employee_count &gt; 100\n    MATCH (c)-[:LOCATED_IN]-&gt;(city:City)\n    RETURN c.name, employee_count, city.name\n\"\"\")\n</code></pre>"},{"location":"user-guide/#union-queries","title":"UNION Queries","text":"<p>Combine multiple result sets:</p> Python<pre><code>sql = graph.transpile(\"\"\"\n    MATCH (p:Person)-[:KNOWS]-&gt;(friend:Person)\n    RETURN p.name AS source, friend.name AS target, 'KNOWS' AS type\n    UNION\n    MATCH (p:Person)-[:WORKS_AT]-&gt;(c:Company)\n    RETURN p.name AS source, c.name AS target, 'WORKS_AT' AS type\n\"\"\")\n</code></pre>"},{"location":"user-guide/#execution-on-databricks","title":"Execution on Databricks","text":"<p>If you provide a SparkSession, you can execute queries directly:</p> Python<pre><code>from pyspark.sql import SparkSession\n\nspark = SparkSession.builder.getOrCreate()\n\ngraph = GraphContext(\n    spark=spark,  # Enable execution\n    nodes_table=\"catalog.schema.nodes\",\n    edges_table=\"catalog.schema.edges\",\n)\ngraph.set_types(node_types=[\"Person\"], edge_types=[\"KNOWS\"])\n\n# Transpile and execute\nsql = graph.transpile(\"MATCH (p:Person) RETURN p.name LIMIT 10\")\ndf = spark.sql(sql)\ndf.show()\n</code></pre>"},{"location":"user-guide/#low-level-api-without-graphcontext","title":"Low-Level API (Without GraphContext)","text":"<p>For complex scenarios where graph data is spread across multiple tables (not a simple Triple Store), or when you need full control, use the components directly:</p> Python<pre><code>from gsql2rsql import OpenCypherParser, LogicalPlan, SQLRenderer\nfrom gsql2rsql.common.schema import NodeSchema, EdgeSchema, EntityProperty\nfrom gsql2rsql.renderer.schema_provider import SimpleSQLSchemaProvider, SQLTableDescriptor\n\n# 1. Define schema (SimpleSQLSchemaProvider)\nschema = SimpleSQLSchemaProvider()\n\nperson = NodeSchema(\n    name=\"Person\",\n    properties=[\n        EntityProperty(property_name=\"id\", data_type=int),\n        EntityProperty(property_name=\"name\", data_type=str),\n    ],\n    node_id_property=EntityProperty(property_name=\"id\", data_type=int)\n)\nschema.add_node(\n    person,\n    SQLTableDescriptor(\n        table_name=\"catalog.schema.people\",  # Separate table for Person nodes\n        node_id_columns=[\"id\"],\n    )\n)\n\nknows = EdgeSchema(\n    name=\"KNOWS\",\n    source_node_id=\"Person\",\n    sink_node_id=\"Person\",\n    source_id_property=EntityProperty(property_name=\"person_id\", data_type=int),\n    sink_id_property=EntityProperty(property_name=\"friend_id\", data_type=int),\n)\nschema.add_edge(\n    knows,\n    SQLTableDescriptor(\n        entity_id=\"Person@KNOWS@Person\",\n        table_name=\"catalog.schema.friendships\",  # Separate table for KNOWS edges\n    )\n)\n\n# 2. Transpile\nparser = OpenCypherParser()\nast = parser.parse(\"MATCH (p:Person)-[:KNOWS]-&gt;(f:Person) RETURN p.name, f.name\")\nplan = LogicalPlan.process_query_tree(ast, schema)\nplan.resolve(original_query=\"...\")\n\nrenderer = SQLRenderer(db_schema_provider=schema)\nsql = renderer.render_plan(plan)\n</code></pre> <p>This approach is useful when:</p> <ul> <li>Different tables for different node/edge types (e.g., <code>people</code>, <code>companies</code>, <code>friendships</code>)</li> <li>Custom column mappings beyond what GraphContext supports</li> <li>Integration with existing schemas that don't follow Triple Store pattern</li> </ul>"},{"location":"user-guide/#cli-usage","title":"CLI Usage","text":"<p>gsql2rsql includes a command-line interface:</p> Bash<pre><code># Transpile a query\necho \"MATCH (p:Person) RETURN p.name\" | gsql2rsql translate --schema schema.json\n\n# Interactive TUI\ngsql2rsql tui --schema schema.json\n</code></pre>"},{"location":"user-guide/#limitations","title":"Limitations","text":"<ul> <li>Databricks new Runtime required for <code>WITH RECURSIVE</code> and HoF</li> <li>Write operations not supported (<code>CREATE</code>, <code>DELETE</code>, <code>SET</code>)</li> <li>Some Cypher features not yet implemented</li> </ul>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<ul> <li>Examples Gallery - 69 complete query examples</li> </ul>"},{"location":"examples/","title":"Query Examples","text":"<p>Welcome to the gsql2rsql query examples gallery!</p> <p>This section demonstrates the transpiler's capabilities across different domains. Each example shows the original OpenCypher query alongside the generated Databricks SQL.</p>"},{"location":"examples/#available-categories","title":"Available Categories","text":""},{"location":"examples/#credit","title":"Credit","text":"<ul> <li>Total Queries: 15</li> <li>Successful: 15</li> <li>Failed: 0</li> </ul>"},{"location":"examples/#fraud","title":"Fraud","text":"<ul> <li>Total Queries: 17</li> <li>Successful: 17</li> <li>Failed: 0</li> </ul>"},{"location":"examples/#features","title":"Features","text":"<ul> <li>Total Queries: 54</li> <li>Successful: 54</li> <li>Failed: 0</li> </ul>"},{"location":"examples/#about-these-examples","title":"About These Examples","text":"<p>All queries are sourced from real-world use cases in:</p> <ul> <li>Fraud Detection: Graph-based fraud ring detection, anomaly identification</li> <li>Credit Analysis: Relationship-based credit risk assessment</li> <li>Simple examples: Simple examples</li> </ul> <p>Try These Yourself</p> <p>You can run any of these queries through the transpiler using: Bash<pre><code>gsql2rsql translate --schema examples/fraud_queries.yaml \"&lt;your-query&gt;\"\n</code></pre></p>"},{"location":"examples/credit/","title":"Credit Queries","text":"<p>This page contains transpiled examples for credit queries queries.</p> <p>Disclaimer</p> <p>These examples were generated by Claude, and I believe Claude was overconfident about the usefulness of these queries. Therefore, these examples require further curation and validation, including the transpilation results. if you spot any issues, please open an issue or contribute at https://github.com/devmessias/gsql2rsql/issues</p> <p>Each example shows the original OpenCypher query and its corresponding Databricks SQL translation.</p>"},{"location":"examples/credit/#1-calculate-credit-risk-scores-based-on-transaction-history","title":"1. Calculate credit risk scores based on transaction history","text":"<p>Application: Credit: Risk scoring</p> Notes <p>Analyzes recent transaction patterns to assess credit risk. High overdraft rates indicate elevated default risk.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)-[:TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P90D')\nWITH c, a,\n     COUNT(t) AS tx_count,\n     AVG(t.amount) AS avg_transaction,\n     SUM(CASE WHEN t.type = 'overdraft' THEN 1 ELSE 0 END) AS overdraft_count\nRETURN c.id, c.name,\n       tx_count,\n       avg_transaction,\n       overdraft_count,\n       (overdraft_count * 1.0 / tx_count) AS overdraft_rate\nORDER BY overdraft_rate DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,tx_count AS tx_count\n  ,avg_transaction AS avg_transaction\n  ,overdraft_count AS overdraft_count\n  ,((overdraft_count) * (1.0)) / (tx_count) AS overdraft_rate\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,COUNT(_gsql2rsql_t_id) AS tx_count\n    ,AVG(CAST(_gsql2rsql_t_amount AS DOUBLE)) AS avg_transaction\n    ,SUM(CASE WHEN (_gsql2rsql_t_type) = ('overdraft') THEN 1 ELSE 0 END) AS overdraft_count\n    ,_gsql2rsql_a_balance AS _gsql2rsql_a_balance\n    ,_gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n      ,_left_0._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n      ,_right_0._gsql2rsql_t_type AS _gsql2rsql_t_type\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n        ,_left_1._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_right_2._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n          ,_right_2._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,account_id AS _gsql2rsql__anon1_account_id\n            FROM\n              catalog.credit.CustomerAccount\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a_id\n            ,balance AS _gsql2rsql_a_balance\n            ,customer_id AS _gsql2rsql_a_customer_id\n          FROM\n            catalog.credit.Account\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_a_id = _left_2._gsql2rsql__anon1_account_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.AccountTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n        ,type AS _gsql2rsql_t_type\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 90 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_a_id, _gsql2rsql_a_balance, _gsql2rsql_a_customer_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n) AS _proj\nORDER BY overdraft_rate DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, a=a, tx_count=COUNT(t), avg_transaction=AVG(t.amount), overdraft_count=SUM(CASE WHEN (t.type EQ 'overdraft') THEN 1 ELSE 0 END)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P90D')))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, tx_count=tx_count, avg_transaction=avg_transaction, overdraft_count=overdraft_count, overdraft_rate=((overdraft_count MULTIPLY 1.0) DIVIDE tx_count)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#2-identify-credit-worthy-customers-via-payment-consistency","title":"2. Identify credit-worthy customers via payment consistency","text":"<p>Application: Credit: Payment reliability assessment</p> Notes <p>Finds customers with excellent payment history for credit line increases. High on-time rates indicate low default probability.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_LOAN]-&gt;(l:Loan)-[:PAYMENT]-&gt;(p:Payment)\nWHERE l.status = 'active'\nWITH c, l,\n     COUNT(p) AS total_payments,\n     SUM(CASE WHEN p.on_time = true THEN 1 ELSE 0 END) AS on_time_payments\nWHERE total_payments &gt; 6\nWITH c, l, total_payments, on_time_payments,\n     (on_time_payments * 1.0 / total_payments) AS on_time_rate\nWHERE on_time_rate &gt; 0.95\nRETURN c.id, c.name, l.amount, on_time_rate, total_payments\nORDER BY l.amount DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,_gsql2rsql_l_amount AS amount\n  ,on_time_rate AS on_time_rate\n  ,total_payments AS total_payments\nFROM (\n  SELECT *\n  FROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_l_id AS _gsql2rsql_l_id\n    ,total_payments AS total_payments\n    ,on_time_payments AS on_time_payments\n    ,((on_time_payments) * (1.0)) / (total_payments) AS on_time_rate\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    ,_gsql2rsql_l_amount AS _gsql2rsql_l_amount\n    ,_gsql2rsql_l_balance AS _gsql2rsql_l_balance\n    ,_gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n    ,_gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n    ,_gsql2rsql_l_status AS _gsql2rsql_l_status\n  FROM (\n    SELECT \n       _gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,COUNT(_gsql2rsql_p_id) AS total_payments\n      ,SUM(CASE WHEN (_gsql2rsql_p_on_time) = (TRUE) THEN 1 ELSE 0 END) AS on_time_payments\n      ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_gsql2rsql_l_amount AS _gsql2rsql_l_amount\n      ,_gsql2rsql_l_balance AS _gsql2rsql_l_balance\n      ,_gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n      ,_gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n      ,_gsql2rsql_l_status AS _gsql2rsql_l_status\n    FROM (\n      SELECT\n         _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_0._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n        ,_left_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n        ,_left_0._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n        ,_left_0._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n        ,_left_0._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n        ,_left_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n        ,_left_0._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n        ,_left_0._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n        ,_left_0._gsql2rsql__anon2_payment_id AS _gsql2rsql__anon2_payment_id\n        ,_right_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_right_0._gsql2rsql_p_on_time AS _gsql2rsql_p_on_time\n      FROM (\n        SELECT\n           _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_1._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n          ,_left_1._gsql2rsql_l_id AS _gsql2rsql_l_id\n          ,_left_1._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n          ,_left_1._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n          ,_left_1._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n          ,_left_1._gsql2rsql_l_status AS _gsql2rsql_l_status\n          ,_left_1._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n          ,_right_1._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n          ,_right_1._gsql2rsql__anon2_payment_id AS _gsql2rsql__anon2_payment_id\n        FROM (\n          SELECT\n             _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_2._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n            ,_right_2._gsql2rsql_l_id AS _gsql2rsql_l_id\n            ,_right_2._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n            ,_right_2._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n            ,_right_2._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n            ,_right_2._gsql2rsql_l_status AS _gsql2rsql_l_status\n            ,_right_2._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n          FROM (\n            SELECT\n               _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n              ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n              ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n              ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_right_3._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n            FROM (\n              SELECT\n                 id AS _gsql2rsql_c_id\n                ,name AS _gsql2rsql_c_name\n                ,status AS _gsql2rsql_c_status\n              FROM\n                catalog.credit.Customer\n            ) AS _left_3\n            INNER JOIN (\n              SELECT\n                 customer_id AS _gsql2rsql__anon1_customer_id\n                ,loan_id AS _gsql2rsql__anon1_loan_id\n              FROM\n                catalog.credit.CustomerLoan\n            ) AS _right_3 ON\n              _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n          ) AS _left_2\n          INNER JOIN (\n            SELECT\n               id AS _gsql2rsql_l_id\n              ,amount AS _gsql2rsql_l_amount\n              ,balance AS _gsql2rsql_l_balance\n              ,interest_rate AS _gsql2rsql_l_interest_rate\n              ,status AS _gsql2rsql_l_status\n              ,origination_date AS _gsql2rsql_l_origination_date\n            FROM\n              catalog.credit.Loan\n            WHERE ((status) = ('active'))\n          ) AS _right_2 ON\n            _right_2._gsql2rsql_l_id = _left_2._gsql2rsql__anon1_loan_id\n        ) AS _left_1\n        INNER JOIN (\n          SELECT\n             loan_id AS _gsql2rsql__anon2_loan_id\n            ,payment_id AS _gsql2rsql__anon2_payment_id\n          FROM\n            catalog.credit.LoanPayment\n        ) AS _right_1 ON\n          _left_1._gsql2rsql_l_id = _right_1._gsql2rsql__anon2_loan_id\n      ) AS _left_0\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_p_id\n          ,on_time AS _gsql2rsql_p_on_time\n        FROM\n          catalog.credit.Payment\n      ) AS _right_0 ON\n        _right_0._gsql2rsql_p_id = _left_0._gsql2rsql__anon2_payment_id\n    ) AS _proj\n    GROUP BY _gsql2rsql_c_id, _gsql2rsql_l_id, _gsql2rsql_c_name, _gsql2rsql_c_status, _gsql2rsql_l_amount, _gsql2rsql_l_balance, _gsql2rsql_l_interest_rate, _gsql2rsql_l_origination_date, _gsql2rsql_l_status\n    HAVING (total_payments) &gt; (6)\n  ) AS _proj\n  ) AS _filter\n  WHERE (on_time_rate) &gt; (0.95)\n) AS _proj\nORDER BY _gsql2rsql_l_amount DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_LOAN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: l:Loan\n    Filter: (l.status EQ 'active')\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:PAYMENT]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: p:Payment\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, l=l, total_payments=COUNT(p), on_time_payments=SUM(CASE WHEN (p.on_time EQ true) THEN 1 ELSE 0 END)\n    Having: (total_payments GT 6)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=13;\n  ProjectionOperator(id=12)\n    Projections: c=c, l=l, total_payments=total_payments, on_time_payments=on_time_payments, on_time_rate=((on_time_payments MULTIPLY 1.0) DIVIDE total_payments)\n    Having: (on_time_rate GT 0.95)\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=13 Op=ProjectionOperator; InOpIds=12; OutOpIds=;\n  ProjectionOperator(id=13)\n    Projections: id=c.id, name=c.name, amount=l.amount, on_time_rate=on_time_rate, total_payments=total_payments\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#3-trace-debt-consolidation-opportunities-via-multiple-loan-analysis","title":"3. Trace debt consolidation opportunities via multiple loan analysis","text":"<p>Application: Credit: Debt consolidation</p> Notes <p>Identifies customers with multiple active loans suitable for consolidation. Can improve customer retention and reduce default risk.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_LOAN]-&gt;(l:Loan)\nWHERE l.status = 'active'\nWITH c, COUNT(l) AS active_loans, SUM(l.balance) AS total_debt, AVG(l.interest_rate) AS avg_rate\nWHERE active_loans &gt;= 3 AND total_debt &gt; 10000\nRETURN c.id, c.name, active_loans, total_debt, avg_rate\nORDER BY total_debt DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,active_loans AS active_loans\n  ,total_debt AS total_debt\n  ,avg_rate AS avg_rate\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,COUNT(_gsql2rsql_l_id) AS active_loans\n    ,SUM(_gsql2rsql_l_balance) AS total_debt\n    ,AVG(CAST(_gsql2rsql_l_interest_rate AS DOUBLE)) AS avg_rate\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      ,_right_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,_right_0._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n      ,_right_0._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n      ,_right_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_right_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_right_1._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,name AS _gsql2rsql_c_name\n          ,status AS _gsql2rsql_c_status\n        FROM\n          catalog.credit.Customer\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           customer_id AS _gsql2rsql__anon1_customer_id\n          ,loan_id AS _gsql2rsql__anon1_loan_id\n        FROM\n          catalog.credit.CustomerLoan\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_c_id = _right_1._gsql2rsql__anon1_customer_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_l_id\n        ,balance AS _gsql2rsql_l_balance\n        ,interest_rate AS _gsql2rsql_l_interest_rate\n        ,status AS _gsql2rsql_l_status\n      FROM\n        catalog.credit.Loan\n      WHERE ((status) = ('active'))\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_l_id = _left_0._gsql2rsql__anon1_loan_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING ((active_loans) &gt;= (3)) AND ((total_debt) &gt; (10000))\n) AS _proj\nORDER BY total_debt DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_LOAN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: l:Loan\n    Filter: (l.status EQ 'active')\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: c=c, active_loans=COUNT(l), total_debt=SUM(l.balance), avg_rate=AVG(l.interest_rate)\n    Having: ((active_loans GEQ 3) AND (total_debt GT 10000))\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=c.id, name=c.name, active_loans=active_loans, total_debt=total_debt, avg_rate=avg_rate\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#4-predict-default-probability-using-behavioral-patterns","title":"4. Predict default probability using behavioral patterns","text":"<p>Application: Credit: Default prediction</p> Notes <p>Combines multiple risk indicators to predict default probability. NSF fees and late payments are strong default predictors.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)-[:TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P60D')\nWITH c, a,\n     COUNT(CASE WHEN t.type = 'NSF' THEN 1 END) AS nsf_count,\n     COUNT(CASE WHEN t.type = 'late_fee' THEN 1 END) AS late_fee_count,\n     MIN(a.balance) AS min_balance\nWHERE nsf_count &gt; 2 OR late_fee_count &gt; 3 OR min_balance &lt; 0\nRETURN c.id, c.name, nsf_count, late_fee_count, min_balance,\n       (nsf_count + late_fee_count * 2) AS default_risk_score\nORDER BY default_risk_score DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,nsf_count AS nsf_count\n  ,late_fee_count AS late_fee_count\n  ,min_balance AS min_balance\n  ,(nsf_count) + ((late_fee_count) * (2)) AS default_risk_score\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,COUNT(CASE WHEN (_gsql2rsql_t_type) = ('NSF') THEN 1 END) AS nsf_count\n    ,COUNT(CASE WHEN (_gsql2rsql_t_type) = ('late_fee') THEN 1 END) AS late_fee_count\n    ,MIN(_gsql2rsql_a_balance) AS min_balance\n    ,_gsql2rsql_a_balance AS _gsql2rsql_a_balance\n    ,_gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n      ,_left_0._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n      ,_right_0._gsql2rsql_t_type AS _gsql2rsql_t_type\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n        ,_left_1._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_right_2._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n          ,_right_2._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,account_id AS _gsql2rsql__anon1_account_id\n            FROM\n              catalog.credit.CustomerAccount\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a_id\n            ,balance AS _gsql2rsql_a_balance\n            ,customer_id AS _gsql2rsql_a_customer_id\n          FROM\n            catalog.credit.Account\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_a_id = _left_2._gsql2rsql__anon1_account_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.AccountTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,timestamp AS _gsql2rsql_t_timestamp\n        ,type AS _gsql2rsql_t_type\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 60 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_a_id, _gsql2rsql_a_balance, _gsql2rsql_a_customer_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING (((nsf_count) &gt; (2)) OR ((late_fee_count) &gt; (3))) OR ((min_balance) &lt; (0))\n) AS _proj\nORDER BY default_risk_score DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, a=a, nsf_count=COUNT(CASE WHEN (t.type EQ 'NSF') THEN 1 END), late_fee_count=COUNT(CASE WHEN (t.type EQ 'late_fee') THEN 1 END), min_balance=MIN(a.balance)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P60D')))\n    Having: (((nsf_count GT 2) OR (late_fee_count GT 3)) OR (min_balance LT 0))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, nsf_count=nsf_count, late_fee_count=late_fee_count, min_balance=min_balance, default_risk_score=(nsf_count PLUS (late_fee_count MULTIPLY 2))\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#5-analyze-transaction-chains-to-assess-liquidity-patterns","title":"5. Analyze transaction chains to assess liquidity patterns","text":"<p>Application: Credit: Liquidity assessment</p> Notes <p>Examines internal transfer patterns to understand liquidity management. Frequent internal transfers may indicate cash flow stress.</p> OpenCypher Query Cypher<pre><code>MATCH path = (source:Account)-[:TRANSFER*1..3]-&gt;(sink:Account)\nWHERE source.customer_id = sink.customer_id\n  AND ALL(rel IN relationships(path) WHERE rel.timestamp &gt; TIMESTAMP() - DURATION('P30D'))\nWITH source.customer_id AS customer_id,\n     COUNT(DISTINCT path) AS transfer_chains,\n     AVG(LENGTH(path)) AS avg_chain_length\nRETURN customer_id, transfer_chains, avg_chain_length\nORDER BY transfer_chains DESC\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.source_account_id AS start_node,\n      e.target_account_id AS end_node,\n      1 AS depth,\n      ARRAY(e.source_account_id, e.target_account_id) AS path,\n      ARRAY(NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      ARRAY(e.source_account_id) AS visited\n    FROM catalog.credit.Transfer e\n    WHERE (e.timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY))\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.target_account_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.target_account_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.source_account_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.credit.Transfer e\n      ON p.end_node = e.source_account_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.target_account_id)\n      AND (e.timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY))\n  )\nSELECT \n   customer_id AS customer_id\n  ,transfer_chains AS transfer_chains\n  ,avg_chain_length AS avg_chain_length\nFROM (\n  SELECT \n     _gsql2rsql_source_customer_id AS customer_id\n    ,COUNT(DISTINCT _gsql2rsql_path_id) AS transfer_chains\n    ,AVG(CAST((SIZE(_gsql2rsql_path_id) - 1) AS DOUBLE)) AS avg_chain_length\n  FROM (\n    SELECT\n       sink.id AS _gsql2rsql_sink_id\n      ,sink.balance AS _gsql2rsql_sink_balance\n      ,sink.customer_id AS _gsql2rsql_sink_customer_id\n      ,source.id AS _gsql2rsql_source_id\n      ,source.balance AS _gsql2rsql_source_balance\n      ,source.customer_id AS _gsql2rsql_source_customer_id\n      ,p.start_node\n      ,p.end_node\n      ,p.depth\n      ,p.path AS _gsql2rsql_path_id\n      ,p.path_edges AS _gsql2rsql_path_edges\n    FROM paths_1 p\n    JOIN catalog.credit.Account sink\n      ON sink.id = p.end_node\n    JOIN catalog.credit.Account source\n      ON source.id = p.start_node\n    WHERE p.depth &gt;= 1 AND p.depth &lt;= 3\n  ) AS _proj\n  WHERE (_gsql2rsql_source_customer_id) = (_gsql2rsql_sink_customer_id)\n  GROUP BY _gsql2rsql_source_customer_id\n) AS _proj\nORDER BY transfer_chains DESC\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: source:Account\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: sink:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(TRANSFER*1..3, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=6;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=sink RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=4; OutOpIds=7;\n  ProjectionOperator(id=6)\n    Projections: customer_id=source.customer_id, transfer_chains=COUNT(DISTINCT path), avg_chain_length=AVG(LENGTH(path))\n    Filter: (source.customer_id EQ sink.customer_id)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=6; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: customer_id=customer_id, transfer_chains=transfer_chains, avg_chain_length=avg_chain_length\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#6-find-high-value-customers-for-premium-credit-products","title":"6. Find high-value customers for premium credit products","text":"<p>Application: Credit: Customer segmentation</p> Notes <p>Identifies high-value customers suitable for premium offerings. High transaction volume and balances indicate creditworthiness.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)-[:TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P180D')\nWITH c, SUM(t.amount) AS total_volume, AVG(a.balance) AS avg_balance, COUNT(DISTINCT a) AS account_count\nWHERE total_volume &gt; 100000 AND avg_balance &gt; 10000\nRETURN c.id, c.name, total_volume, avg_balance, account_count\nORDER BY total_volume DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,total_volume AS total_volume\n  ,avg_balance AS avg_balance\n  ,account_count AS account_count\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,SUM(_gsql2rsql_t_amount) AS total_volume\n    ,AVG(CAST(_gsql2rsql_a_balance AS DOUBLE)) AS avg_balance\n    ,COUNT(DISTINCT _gsql2rsql_a_id) AS account_count\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_right_2._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,account_id AS _gsql2rsql__anon1_account_id\n            FROM\n              catalog.credit.CustomerAccount\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a_id\n            ,balance AS _gsql2rsql_a_balance\n          FROM\n            catalog.credit.Account\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_a_id = _left_2._gsql2rsql__anon1_account_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.AccountTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 180 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING ((total_volume) &gt; (100000)) AND ((avg_balance) &gt; (10000))\n) AS _proj\nORDER BY total_volume DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, total_volume=SUM(t.amount), avg_balance=AVG(a.balance), account_count=COUNT(DISTINCT a)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P180D')))\n    Having: ((total_volume GT 100000) AND (avg_balance GT 10000))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, total_volume=total_volume, avg_balance=avg_balance, account_count=account_count\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#7-detect-early-warning-signs-of-financial-distress","title":"7. Detect early warning signs of financial distress","text":"<p>Application: Credit: Early warning system</p> Notes <p>Identifies customers with sudden balance declines. Sharp drops may indicate financial distress or income loss.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)-[:TRANSACTION]-&gt;(t:Transaction)\nWITH c, a,\n     AVG(CASE WHEN t.timestamp &gt; TIMESTAMP() - DURATION('P7D') THEN a.balance END) AS recent_avg,\n     AVG(CASE WHEN t.timestamp &lt;= TIMESTAMP() - DURATION('P30D') AND t.timestamp &gt; TIMESTAMP() - DURATION('P60D') THEN a.balance END) AS historical_avg\nWHERE historical_avg &gt; 0 AND recent_avg &lt; historical_avg * 0.5\nRETURN c.id, c.name, historical_avg, recent_avg,\n       ((historical_avg - recent_avg) / historical_avg) AS balance_decline_pct\nORDER BY balance_decline_pct DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,historical_avg AS historical_avg\n  ,recent_avg AS recent_avg\n  ,((historical_avg) - (recent_avg)) / (historical_avg) AS balance_decline_pct\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,AVG(CAST(CASE WHEN (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 7 DAY)) THEN _gsql2rsql_a_balance END AS DOUBLE)) AS recent_avg\n    ,AVG(CAST(CASE WHEN ((_gsql2rsql_t_timestamp) &lt;= ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY))) AND ((_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 60 DAY))) THEN _gsql2rsql_a_balance END AS DOUBLE)) AS historical_avg\n    ,_gsql2rsql_a_balance AS _gsql2rsql_a_balance\n    ,_gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n      ,_left_0._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n        ,_left_1._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_right_2._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n          ,_right_2._gsql2rsql_a_customer_id AS _gsql2rsql_a_customer_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,account_id AS _gsql2rsql__anon1_account_id\n            FROM\n              catalog.credit.CustomerAccount\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a_id\n            ,balance AS _gsql2rsql_a_balance\n            ,customer_id AS _gsql2rsql_a_customer_id\n          FROM\n            catalog.credit.Account\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_a_id = _left_2._gsql2rsql__anon1_account_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.AccountTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_a_id, _gsql2rsql_a_balance, _gsql2rsql_a_customer_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING ((historical_avg) &gt; (0)) AND ((recent_avg) &lt; ((historical_avg) * (0.5)))\n) AS _proj\nORDER BY balance_decline_pct DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=10;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=ProjectionOperator; InOpIds=9; OutOpIds=11;\n  ProjectionOperator(id=10)\n    Projections: c=c, a=a, recent_avg=AVG(CASE WHEN (t.timestamp GT (DATETIME() MINUS DURATION('P7D'))) THEN a.balance END), historical_avg=AVG(CASE WHEN ((t.timestamp LEQ (DATETIME() MINUS DURATION('P30D'))) AND (t.timestamp GT (DATETIME() MINUS DURATION('P60D')))) THEN a.balance END)\n    Having: ((historical_avg GT 0) AND (recent_avg LT (historical_avg MULTIPLY 0.5)))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=10; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: id=c.id, name=c.name, historical_avg=historical_avg, recent_avg=recent_avg, balance_decline_pct=((historical_avg MINUS recent_avg) DIVIDE historical_avg)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#8-assess-creditworthiness-via-social-network-analysis","title":"8. Assess creditworthiness via social network analysis","text":"<p>Application: Credit: Network-based scoring</p> Notes <p>Analyzes credit risk based on social network connections. Proximity to defaulted borrowers increases risk score.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:KNOWS*1..2]-(peer:Customer)-[:HAS_LOAN]-&gt;(l:Loan)\nWHERE l.status = 'defaulted'\nWITH c, COUNT(DISTINCT peer) AS defaulted_peers, COUNT(DISTINCT l) AS defaulted_loans\nWHERE defaulted_peers &gt; 0\nRETURN c.id, c.name, defaulted_peers, defaulted_loans,\n       (defaulted_peers * 1.0) AS network_risk_score\nORDER BY network_risk_score DESC\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT * FROM (\n    -- Forward direction\n    SELECT\n      e.customer_id AS start_node,\n      e.knows_customer_id AS end_node,\n      1 AS depth,\n      ARRAY(e.customer_id, e.knows_customer_id) AS path,\n      ARRAY(e.customer_id) AS visited\n    FROM catalog.credit.CustomerKnows e\n\n      UNION ALL\n\n    -- Backward direction\n    SELECT\n      e.knows_customer_id AS start_node,\n      e.customer_id AS end_node,\n      1 AS depth,\n      ARRAY(e.knows_customer_id, e.customer_id) AS path,\n      ARRAY(e.knows_customer_id) AS visited\n    FROM catalog.credit.CustomerKnows e\n    )\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT * FROM (\n    -- Forward direction\n    SELECT\n      p.start_node,\n      e.knows_customer_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.knows_customer_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.customer_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.credit.CustomerKnows e\n      ON p.end_node = e.customer_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.knows_customer_id)\n\n      UNION ALL\n\n    -- Backward direction\n    SELECT\n      p.start_node,\n      e.customer_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.customer_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.knows_customer_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.credit.CustomerKnows e\n      ON p.end_node = e.knows_customer_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.customer_id)\n    )\n  )\nSELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,defaulted_peers AS defaulted_peers\n  ,defaulted_loans AS defaulted_loans\n  ,(defaulted_peers) * (1.0) AS network_risk_score\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,COUNT(DISTINCT _gsql2rsql_peer_id) AS defaulted_peers\n    ,COUNT(DISTINCT _gsql2rsql_l_id) AS defaulted_loans\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql_peer_id AS _gsql2rsql_peer_id\n      ,_left_0._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n      ,_left_0._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n      ,_right_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,_right_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql_peer_id AS _gsql2rsql_peer_id\n        ,_right_1._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n        ,_right_1._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n      FROM (\n        SELECT\n           sink.id AS _gsql2rsql_peer_id\n          ,sink.name AS _gsql2rsql_peer_name\n          ,sink.status AS _gsql2rsql_peer_status\n          ,source.id AS _gsql2rsql_c_id\n          ,source.name AS _gsql2rsql_c_name\n          ,source.status AS _gsql2rsql_c_status\n          ,p.start_node\n          ,p.end_node\n          ,p.depth\n          ,p.path\n        FROM paths_1 p\n        JOIN catalog.credit.Customer sink\n          ON sink.id = p.end_node\n        JOIN catalog.credit.Customer source\n          ON source.id = p.start_node\n        WHERE p.depth &gt;= 1 AND p.depth &lt;= 2\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           customer_id AS _gsql2rsql__anon2_customer_id\n          ,loan_id AS _gsql2rsql__anon2_loan_id\n        FROM\n          catalog.credit.CustomerLoan\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_peer_id = _right_1._gsql2rsql__anon2_customer_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_l_id\n        ,status AS _gsql2rsql_l_status\n      FROM\n        catalog.credit.Loan\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_l_id = _left_0._gsql2rsql__anon2_loan_id\n  ) AS _proj\n  WHERE (_gsql2rsql_l_status) = ('defaulted')\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING (defaulted_peers) &gt; (0)\n) AS _proj\nORDER BY network_risk_score DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: peer:Customer\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=5)\n    DataSource: [_anon2:HAS_LOAN]-&gt;\n*\nOpId=7 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=7)\n    DataSource: l:Loan\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..2, direction=BOTH)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=6;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=peer RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=4,5; OutOpIds=8;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=peer RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=6,7; OutOpIds=10;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=ProjectionOperator; InOpIds=8; OutOpIds=11;\n  ProjectionOperator(id=10)\n    Projections: c=c, defaulted_peers=COUNT(DISTINCT peer), defaulted_loans=COUNT(DISTINCT l)\n    Filter: (l.status EQ 'defaulted')\n    Having: (defaulted_peers GT 0)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=10; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: id=c.id, name=c.name, defaulted_peers=defaulted_peers, defaulted_loans=defaulted_loans, network_risk_score=(defaulted_peers MULTIPLY 1.0)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#9-identify-seasonal-spending-patterns-for-credit-limit-adjustments","title":"9. Identify seasonal spending patterns for credit limit adjustments","text":"<p>Application: Credit: Seasonal analysis</p> Notes <p>Identifies months with above-average spending for each customer. Useful for temporary credit limit increases during peak periods.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_CARD]-&gt;(card:CreditCard)-[:CARD_TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P365D')\nWITH c, card,\n     month(t.timestamp) AS month,\n     SUM(t.amount) AS monthly_spend\nWITH c, card, month, monthly_spend,\n     AVG(monthly_spend) OVER (PARTITION BY c.id) AS avg_monthly_spend\nWHERE monthly_spend &gt; avg_monthly_spend * 1.5\nRETURN c.id, month, monthly_spend, avg_monthly_spend\nORDER BY monthly_spend DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS _gsql2rsql_c_id\n  ,_gsql2rsql_card_id AS _gsql2rsql_card_id\n  ,month AS month\n  ,monthly_spend AS monthly_spend\n  ,AVG(CAST(monthly_spend AS DOUBLE)) AS \n  ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n  ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  ,_gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n  ,_gsql2rsql_card_number AS _gsql2rsql_card_number\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_card_id AS _gsql2rsql_card_id\n    ,MONTH(_gsql2rsql_t_timestamp) AS month\n    ,SUM(_gsql2rsql_t_amount) AS monthly_spend\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    ,_gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n    ,_gsql2rsql_card_number AS _gsql2rsql_card_number\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_0._gsql2rsql_card_id AS _gsql2rsql_card_id\n      ,_left_0._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n      ,_left_0._gsql2rsql_card_number AS _gsql2rsql_card_number\n      ,_left_0._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_left_1._gsql2rsql_card_id AS _gsql2rsql_card_id\n        ,_left_1._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n        ,_left_1._gsql2rsql_card_number AS _gsql2rsql_card_number\n        ,_right_1._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_right_2._gsql2rsql_card_id AS _gsql2rsql_card_id\n          ,_right_2._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n          ,_right_2._gsql2rsql_card_number AS _gsql2rsql_card_number\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,card_id AS _gsql2rsql__anon1_card_id\n            FROM\n              catalog.credit.CustomerCard\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_card_id\n            ,credit_limit AS _gsql2rsql_card_credit_limit\n            ,number AS _gsql2rsql_card_number\n          FROM\n            catalog.credit.CreditCard\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_card_id = _left_2._gsql2rsql__anon1_card_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           card_id AS _gsql2rsql__anon2_card_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.CardTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_card_id = _right_1._gsql2rsql__anon2_card_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 365 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_card_id, MONTH(_gsql2rsql_t_timestamp), _gsql2rsql_c_name, _gsql2rsql_c_status, _gsql2rsql_card_credit_limit, _gsql2rsql_card_number\n) AS _proj\nGROUP BY _gsql2rsql_c_id, _gsql2rsql_card_id, month, monthly_spend, _gsql2rsql_c_name, _gsql2rsql_c_status, _gsql2rsql_card_credit_limit, _gsql2rsql_card_number\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: card:CreditCard\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:CARD_TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, card=card, month=DATE_MONTH(t.timestamp), monthly_spend=SUM(t.amount)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P365D')))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: c=c, card=card, month=month, monthly_spend=monthly_spend, =AVG(monthly_spend)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#10-calculate-debt-to-income-ratio-estimates-from-transaction-data","title":"10. Calculate debt-to-income ratio estimates from transaction data","text":"<p>Application: Credit: DTI estimation</p> Notes <p>Estimates debt-to-income ratio from transaction patterns. DTI is a critical metric for credit approval decisions.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)-[:TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P90D')\nWITH c,\n     SUM(CASE WHEN t.category = 'income' THEN t.amount ELSE 0 END) AS income,\n     SUM(CASE WHEN t.category = 'debt_payment' THEN t.amount ELSE 0 END) AS debt_payments\nWHERE income &gt; 0\nRETURN c.id, c.name, income, debt_payments,\n       (debt_payments * 1.0 / income) AS estimated_dti\nORDER BY estimated_dti DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,income AS income\n  ,debt_payments AS debt_payments\n  ,((debt_payments) * (1.0)) / (income) AS estimated_dti\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,SUM(CASE WHEN (_gsql2rsql_t_category) = ('income') THEN _gsql2rsql_t_amount ELSE 0 END) AS income\n    ,SUM(CASE WHEN (_gsql2rsql_t_category) = ('debt_payment') THEN _gsql2rsql_t_amount ELSE 0 END) AS debt_payments\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n      ,_right_0._gsql2rsql_t_category AS _gsql2rsql_t_category\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,account_id AS _gsql2rsql__anon1_account_id\n            FROM\n              catalog.credit.CustomerAccount\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a_id\n          FROM\n            catalog.credit.Account\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_a_id = _left_2._gsql2rsql__anon1_account_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.AccountTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n        ,category AS _gsql2rsql_t_category\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 90 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING (income) &gt; (0)\n) AS _proj\nORDER BY estimated_dti DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, income=SUM(CASE WHEN (t.category EQ 'income') THEN t.amount ELSE 0 END), debt_payments=SUM(CASE WHEN (t.category EQ 'debt_payment') THEN t.amount ELSE 0 END)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P90D')))\n    Having: (income GT 0)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, income=income, debt_payments=debt_payments, estimated_dti=((debt_payments MULTIPLY 1.0) DIVIDE income)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#11-find-cross-sell-opportunities-for-additional-credit-products","title":"11. Find cross-sell opportunities for additional credit products","text":"<p>Application: Credit: Cross-sell targeting</p> Notes <p>Identifies customers without loans but with strong deposit relationships. Prime candidates for personal loan or credit card offers.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_ACCOUNT]-&gt;(a:Account)\nWHERE NOT (c)-[:HAS_LOAN]-&gt;(:Loan) AND a.balance &gt; 5000\nWITH c, AVG(a.balance) AS avg_balance, COUNT(a) AS account_count\nWHERE account_count &gt;= 2\nRETURN c.id, c.name, avg_balance, account_count\nORDER BY avg_balance DESC\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,avg_balance AS avg_balance\n  ,account_count AS account_count\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,AVG(CAST(_gsql2rsql_a_balance AS DOUBLE)) AS avg_balance\n    ,COUNT(_gsql2rsql_a_id) AS account_count\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_right_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_right_0._gsql2rsql_a_balance AS _gsql2rsql_a_balance\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_right_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_right_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,name AS _gsql2rsql_c_name\n          ,status AS _gsql2rsql_c_status\n        FROM\n          catalog.credit.Customer\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           customer_id AS _gsql2rsql__anon1_customer_id\n          ,account_id AS _gsql2rsql__anon1_account_id\n        FROM\n          catalog.credit.CustomerAccount\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_c_id = _right_1._gsql2rsql__anon1_customer_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_a_id\n        ,balance AS _gsql2rsql_a_balance\n      FROM\n        catalog.credit.Account\n      WHERE ((balance) &gt; (5000))\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_a_id = _left_0._gsql2rsql__anon1_account_id\n  ) AS _proj\n  WHERE NOT (EXISTS (SELECT 1 FROM catalog.credit.CustomerLoan _exists_rel JOIN catalog.credit.Loan _exists_target ON _exists_rel.loan_id = _exists_target.id WHERE _exists_rel.customer_id = _gsql2rsql_c_id))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n  HAVING (account_count) &gt;= (2)\n) AS _proj\nORDER BY avg_balance DESC\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n    Filter: (a.balance GT 5000)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: c=c, avg_balance=AVG(a.balance), account_count=COUNT(a)\n    Filter: NOT(EXISTS { c:, [:HAS_LOAN]-&gt;, :Loan })\n    Having: (account_count GEQ 2)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=c.id, name=c.name, avg_balance=avg_balance, account_count=account_count\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#12-analyze-payment-velocity-to-detect-cash-flow-improvements","title":"12. Analyze payment velocity to detect cash flow improvements","text":"<p>Application: Credit: Payment velocity analysis</p> Notes <p>Detects customers increasing loan payment amounts. Indicates improved cash flow and reduced default risk.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_LOAN]-&gt;(l:Loan)-[:PAYMENT]-&gt;(p:Payment)\nWHERE p.timestamp &gt; TIMESTAMP() - DURATION('P180D')\nWITH c, l,\n     AVG(CASE WHEN p.timestamp &gt; TIMESTAMP() - DURATION('P30D') THEN p.amount END) AS recent_avg,\n     AVG(CASE WHEN p.timestamp &lt;= TIMESTAMP() - DURATION('P90D') THEN p.amount END) AS historical_avg\nWHERE historical_avg &gt; 0 AND recent_avg &gt; historical_avg * 1.2\nRETURN c.id, c.name, l.id AS loan_id, historical_avg, recent_avg,\n       ((recent_avg - historical_avg) / historical_avg) AS payment_increase_pct\nORDER BY payment_increase_pct DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,_gsql2rsql_l_id AS loan_id\n  ,historical_avg AS historical_avg\n  ,recent_avg AS recent_avg\n  ,((recent_avg) - (historical_avg)) / (historical_avg) AS payment_increase_pct\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_l_id AS _gsql2rsql_l_id\n    ,AVG(CAST(CASE WHEN (_gsql2rsql_p_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY)) THEN _gsql2rsql_p_amount END AS DOUBLE)) AS recent_avg\n    ,AVG(CAST(CASE WHEN (_gsql2rsql_p_timestamp) &lt;= ((CURRENT_TIMESTAMP()) - (INTERVAL 90 DAY)) THEN _gsql2rsql_p_amount END AS DOUBLE)) AS historical_avg\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    ,_gsql2rsql_l_amount AS _gsql2rsql_l_amount\n    ,_gsql2rsql_l_balance AS _gsql2rsql_l_balance\n    ,_gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n    ,_gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n    ,_gsql2rsql_l_status AS _gsql2rsql_l_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      ,_left_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,_left_0._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n      ,_left_0._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n      ,_left_0._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n      ,_left_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n      ,_left_0._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n      ,_left_0._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n      ,_left_0._gsql2rsql__anon2_payment_id AS _gsql2rsql__anon2_payment_id\n      ,_right_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_right_0._gsql2rsql_p_amount AS _gsql2rsql_p_amount\n      ,_right_0._gsql2rsql_p_timestamp AS _gsql2rsql_p_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n        ,_left_1._gsql2rsql_l_id AS _gsql2rsql_l_id\n        ,_left_1._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n        ,_left_1._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n        ,_left_1._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n        ,_left_1._gsql2rsql_l_status AS _gsql2rsql_l_status\n        ,_left_1._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n        ,_right_1._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n        ,_right_1._gsql2rsql__anon2_payment_id AS _gsql2rsql__anon2_payment_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n          ,_right_2._gsql2rsql_l_id AS _gsql2rsql_l_id\n          ,_right_2._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n          ,_right_2._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n          ,_right_2._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n          ,_right_2._gsql2rsql_l_status AS _gsql2rsql_l_status\n          ,_right_2._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,loan_id AS _gsql2rsql__anon1_loan_id\n            FROM\n              catalog.credit.CustomerLoan\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_l_id\n            ,amount AS _gsql2rsql_l_amount\n            ,balance AS _gsql2rsql_l_balance\n            ,interest_rate AS _gsql2rsql_l_interest_rate\n            ,status AS _gsql2rsql_l_status\n            ,origination_date AS _gsql2rsql_l_origination_date\n          FROM\n            catalog.credit.Loan\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_l_id = _left_2._gsql2rsql__anon1_loan_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           loan_id AS _gsql2rsql__anon2_loan_id\n          ,payment_id AS _gsql2rsql__anon2_payment_id\n        FROM\n          catalog.credit.LoanPayment\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_l_id = _right_1._gsql2rsql__anon2_loan_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,amount AS _gsql2rsql_p_amount\n        ,timestamp AS _gsql2rsql_p_timestamp\n      FROM\n        catalog.credit.Payment\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_p_id = _left_0._gsql2rsql__anon2_payment_id\n  ) AS _proj\n  WHERE (_gsql2rsql_p_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 180 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_l_id, _gsql2rsql_c_name, _gsql2rsql_c_status, _gsql2rsql_l_amount, _gsql2rsql_l_balance, _gsql2rsql_l_interest_rate, _gsql2rsql_l_origination_date, _gsql2rsql_l_status\n  HAVING ((historical_avg) &gt; (0)) AND ((recent_avg) &gt; ((historical_avg) * (1.2)))\n) AS _proj\nORDER BY payment_increase_pct DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_LOAN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: l:Loan\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:PAYMENT]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: p:Payment\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, l=l, recent_avg=AVG(CASE WHEN (p.timestamp GT (DATETIME() MINUS DURATION('P30D'))) THEN p.amount END), historical_avg=AVG(CASE WHEN (p.timestamp LEQ (DATETIME() MINUS DURATION('P90D'))) THEN p.amount END)\n    Filter: (p.timestamp GT (DATETIME() MINUS DURATION('P180D')))\n    Having: ((historical_avg GT 0) AND (recent_avg GT (historical_avg MULTIPLY 1.2)))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, loan_id=l.id, historical_avg=historical_avg, recent_avg=recent_avg, payment_increase_pct=((recent_avg MINUS historical_avg) DIVIDE historical_avg)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#13-identify-customers-suitable-for-credit-line-decreases","title":"13. Identify customers suitable for credit line decreases","text":"<p>Application: Credit: Risk mitigation</p> Notes <p>Finds credit cards with limits far exceeding usage patterns. Reducing limits can decrease exposure while maintaining customer satisfaction.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_CARD]-&gt;(card:CreditCard)-[:CARD_TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('P180D')\nWITH c, card,\n     MAX(card.credit_limit) AS credit_limit,\n     MAX(t.amount) AS max_transaction,\n     AVG(t.amount) AS avg_transaction\nWHERE max_transaction &lt; credit_limit * 0.3 AND avg_transaction &lt; credit_limit * 0.1\nRETURN c.id, card.id AS card_id, credit_limit, max_transaction, avg_transaction,\n       (credit_limit - max_transaction * 3) AS suggested_new_limit\nORDER BY suggested_new_limit DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_card_id AS card_id\n  ,credit_limit AS credit_limit\n  ,max_transaction AS max_transaction\n  ,avg_transaction AS avg_transaction\n  ,(credit_limit) - ((max_transaction) * (3)) AS suggested_new_limit\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_card_id AS _gsql2rsql_card_id\n    ,MAX(_gsql2rsql_card_credit_limit) AS credit_limit\n    ,MAX(_gsql2rsql_t_amount) AS max_transaction\n    ,AVG(CAST(_gsql2rsql_t_amount AS DOUBLE)) AS avg_transaction\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    ,_gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n    ,_gsql2rsql_card_number AS _gsql2rsql_card_number\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_0._gsql2rsql_card_id AS _gsql2rsql_card_id\n      ,_left_0._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n      ,_left_0._gsql2rsql_card_number AS _gsql2rsql_card_number\n      ,_left_0._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_left_1._gsql2rsql_card_id AS _gsql2rsql_card_id\n        ,_left_1._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n        ,_left_1._gsql2rsql_card_number AS _gsql2rsql_card_number\n        ,_right_1._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_right_2._gsql2rsql_card_id AS _gsql2rsql_card_id\n          ,_right_2._gsql2rsql_card_credit_limit AS _gsql2rsql_card_credit_limit\n          ,_right_2._gsql2rsql_card_number AS _gsql2rsql_card_number\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c_id\n              ,name AS _gsql2rsql_c_name\n              ,status AS _gsql2rsql_c_status\n            FROM\n              catalog.credit.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,card_id AS _gsql2rsql__anon1_card_id\n            FROM\n              catalog.credit.CustomerCard\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_card_id\n            ,credit_limit AS _gsql2rsql_card_credit_limit\n            ,number AS _gsql2rsql_card_number\n          FROM\n            catalog.credit.CreditCard\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_card_id = _left_2._gsql2rsql__anon1_card_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           card_id AS _gsql2rsql__anon2_card_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.credit.CardTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_card_id = _right_1._gsql2rsql__anon2_card_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.credit.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 180 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_card_id, _gsql2rsql_c_name, _gsql2rsql_c_status, _gsql2rsql_card_credit_limit, _gsql2rsql_card_number\n  HAVING ((max_transaction) &lt; ((credit_limit) * (0.3))) AND ((avg_transaction) &lt; ((credit_limit) * (0.1)))\n) AS _proj\nORDER BY suggested_new_limit DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: card:CreditCard\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:CARD_TRANSACTION]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, card=card, credit_limit=MAX(card.credit_limit), max_transaction=MAX(t.amount), avg_transaction=AVG(t.amount)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P180D')))\n    Having: ((max_transaction LT (credit_limit MULTIPLY 0.3)) AND (avg_transaction LT (credit_limit MULTIPLY 0.1)))\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, card_id=card.id, credit_limit=credit_limit, max_transaction=max_transaction, avg_transaction=avg_transaction, suggested_new_limit=(credit_limit MINUS (max_transaction MULTIPLY 3))\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#14-detect-refinancing-opportunities-via-interest-rate-comparison","title":"14. Detect refinancing opportunities via interest rate comparison","text":"<p>Application: Credit: Refinancing targeting</p> Notes <p>Identifies loans with rates significantly above current market. Proactive refinancing offers can improve retention and customer satisfaction.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:HAS_LOAN]-&gt;(l:Loan)\nWHERE l.status = 'active' AND l.origination_date &lt; TIMESTAMP() - DURATION('P730D')\n  AND l.interest_rate &gt; 7.0\nWITH c, l, l.interest_rate AS current_rate, 5.5 AS market_rate\nWHERE current_rate &gt; market_rate + 1.0\nRETURN c.id, c.name, l.id AS loan_id, l.balance, current_rate, market_rate,\n       (l.balance * (current_rate - market_rate) / 100) AS annual_savings_potential\nORDER BY annual_savings_potential DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,_gsql2rsql_l_id AS loan_id\n  ,_gsql2rsql_l_balance AS balance\n  ,current_rate AS current_rate\n  ,market_rate AS market_rate\n  ,((_gsql2rsql_l_balance) * ((current_rate) - (market_rate))) / (100) AS annual_savings_potential\nFROM (\n  SELECT *\n  FROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_gsql2rsql_l_id AS _gsql2rsql_l_id\n    ,_gsql2rsql_l_interest_rate AS current_rate\n    ,5.5 AS market_rate\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    ,_gsql2rsql_l_amount AS _gsql2rsql_l_amount\n    ,_gsql2rsql_l_balance AS _gsql2rsql_l_balance\n    ,_gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n    ,_gsql2rsql_l_status AS _gsql2rsql_l_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      ,_right_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,_right_0._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n      ,_right_0._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n      ,_right_0._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n      ,_right_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n      ,_right_0._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_right_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_right_1._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,name AS _gsql2rsql_c_name\n          ,status AS _gsql2rsql_c_status\n        FROM\n          catalog.credit.Customer\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           customer_id AS _gsql2rsql__anon1_customer_id\n          ,loan_id AS _gsql2rsql__anon1_loan_id\n        FROM\n          catalog.credit.CustomerLoan\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_c_id = _right_1._gsql2rsql__anon1_customer_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_l_id\n        ,amount AS _gsql2rsql_l_amount\n        ,balance AS _gsql2rsql_l_balance\n        ,interest_rate AS _gsql2rsql_l_interest_rate\n        ,status AS _gsql2rsql_l_status\n        ,origination_date AS _gsql2rsql_l_origination_date\n      FROM\n        catalog.credit.Loan\n      WHERE (((status) = ('active')) AND ((interest_rate) &gt; (7.0)))\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_l_id = _left_0._gsql2rsql__anon1_loan_id\n  ) AS _proj\n  WHERE (_gsql2rsql_l_origination_date) &lt; ((CURRENT_TIMESTAMP()) - (INTERVAL 730 DAY))\n  ) AS _filter\n  WHERE (current_rate) &gt; ((market_rate) + (1.0))\n) AS _proj\nORDER BY annual_savings_potential DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_LOAN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: l:Loan\n    Filter: ((l.status EQ 'active') AND (l.interest_rate GT 7.0))\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: c=c, l=l, current_rate=l.interest_rate, market_rate=5.5\n    Filter: (l.origination_date LT (DATETIME() MINUS DURATION('P730D')))\n    Having: (current_rate GT (market_rate PLUS 1.0))\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=c.id, name=c.name, loan_id=l.id, balance=l.balance, current_rate=current_rate, market_rate=market_rate, annual_savings_potential=((l.balance MULTIPLY (current_rate MINUS market_rate)) DIVIDE 100)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/credit/#15-analyze-co-borrower-relationships-for-joint-credit-assessment","title":"15. Analyze co-borrower relationships for joint credit assessment","text":"<p>Application: Credit: Co-borrower analysis</p> Notes <p>Examines financial strength of co-borrowers for joint loans. Combined liquidity assessment provides more accurate risk picture.</p> OpenCypher Query Cypher<pre><code>MATCH (c1:Customer)-[:CO_BORROWER]-&gt;(l:Loan)&lt;-[:CO_BORROWER]-(c2:Customer)\nWHERE c1.id &lt; c2.id\nMATCH (c1)-[:HAS_ACCOUNT]-&gt;(a1:Account), (c2)-[:HAS_ACCOUNT]-&gt;(a2:Account)\nWITH c1, c2, l,\n     AVG(a1.balance) AS c1_avg_balance,\n     AVG(a2.balance) AS c2_avg_balance\nRETURN c1.id, c2.id, l.id AS loan_id, l.balance,\n       c1_avg_balance, c2_avg_balance,\n       (c1_avg_balance + c2_avg_balance) AS combined_liquidity\nORDER BY combined_liquidity DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c1_id AS id\n  ,_gsql2rsql_c2_id AS id\n  ,_gsql2rsql_l_id AS loan_id\n  ,_gsql2rsql_l_balance AS balance\n  ,c1_avg_balance AS c1_avg_balance\n  ,c2_avg_balance AS c2_avg_balance\n  ,(c1_avg_balance) + (c2_avg_balance) AS combined_liquidity\nFROM (\n  SELECT \n     _gsql2rsql_c1_id AS _gsql2rsql_c1_id\n    ,_gsql2rsql_c2_id AS _gsql2rsql_c2_id\n    ,_gsql2rsql_l_id AS _gsql2rsql_l_id\n    ,AVG(CAST(_gsql2rsql_a1_balance AS DOUBLE)) AS c1_avg_balance\n    ,AVG(CAST(_gsql2rsql_a2_balance AS DOUBLE)) AS c2_avg_balance\n    ,_gsql2rsql_c1_name AS _gsql2rsql_c1_name\n    ,_gsql2rsql_c1_status AS _gsql2rsql_c1_status\n    ,_gsql2rsql_c2_name AS _gsql2rsql_c2_name\n    ,_gsql2rsql_c2_status AS _gsql2rsql_c2_status\n    ,_gsql2rsql_l_amount AS _gsql2rsql_l_amount\n    ,_gsql2rsql_l_balance AS _gsql2rsql_l_balance\n    ,_gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n    ,_gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n    ,_gsql2rsql_l_status AS _gsql2rsql_l_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n      ,_left_0._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n      ,_left_0._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n      ,_left_0._gsql2rsql_l_id AS _gsql2rsql_l_id\n      ,_left_0._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n      ,_left_0._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n      ,_left_0._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n      ,_left_0._gsql2rsql_l_status AS _gsql2rsql_l_status\n      ,_left_0._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n      ,_left_0._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n      ,_left_0._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n      ,_left_0._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n      ,_left_0._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n      ,_left_0._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n      ,_right_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_right_0._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n      ,_right_0._gsql2rsql_a1_balance AS _gsql2rsql_a1_balance\n      ,_right_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_right_0._gsql2rsql_a2_id AS _gsql2rsql_a2_id\n      ,_right_0._gsql2rsql_a2_balance AS _gsql2rsql_a2_balance\n    FROM (\n      SELECT *\n      FROM (\n        SELECT\n           _left_1._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n          ,_left_1._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n          ,_left_1._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n          ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_1._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n          ,_left_1._gsql2rsql_l_id AS _gsql2rsql_l_id\n          ,_left_1._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n          ,_left_1._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n          ,_left_1._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n          ,_left_1._gsql2rsql_l_status AS _gsql2rsql_l_status\n          ,_left_1._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n          ,_left_1._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n          ,_left_1._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n          ,_right_1._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n          ,_right_1._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n          ,_right_1._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n        FROM (\n          SELECT\n             _left_2._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n            ,_left_2._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n            ,_left_2._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n            ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_2._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n            ,_left_2._gsql2rsql_l_id AS _gsql2rsql_l_id\n            ,_left_2._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n            ,_left_2._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n            ,_left_2._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n            ,_left_2._gsql2rsql_l_status AS _gsql2rsql_l_status\n            ,_left_2._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n            ,_right_2._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n            ,_right_2._gsql2rsql__anon2_loan_id AS _gsql2rsql__anon2_loan_id\n          FROM (\n            SELECT\n               _left_3._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n              ,_left_3._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n              ,_left_3._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n              ,_left_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_left_3._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n              ,_right_3._gsql2rsql_l_id AS _gsql2rsql_l_id\n              ,_right_3._gsql2rsql_l_amount AS _gsql2rsql_l_amount\n              ,_right_3._gsql2rsql_l_balance AS _gsql2rsql_l_balance\n              ,_right_3._gsql2rsql_l_interest_rate AS _gsql2rsql_l_interest_rate\n              ,_right_3._gsql2rsql_l_status AS _gsql2rsql_l_status\n              ,_right_3._gsql2rsql_l_origination_date AS _gsql2rsql_l_origination_date\n            FROM (\n              SELECT\n                 _left_4._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n                ,_left_4._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n                ,_left_4._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n                ,_right_4._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n                ,_right_4._gsql2rsql__anon1_loan_id AS _gsql2rsql__anon1_loan_id\n              FROM (\n                SELECT\n                   id AS _gsql2rsql_c1_id\n                  ,name AS _gsql2rsql_c1_name\n                  ,status AS _gsql2rsql_c1_status\n                FROM\n                  catalog.credit.Customer\n              ) AS _left_4\n              INNER JOIN (\n                SELECT\n                   customer_id AS _gsql2rsql__anon1_customer_id\n                  ,loan_id AS _gsql2rsql__anon1_loan_id\n                FROM\n                  catalog.credit.CoBorrower\n              ) AS _right_4 ON\n                _left_4._gsql2rsql_c1_id = _right_4._gsql2rsql__anon1_customer_id\n            ) AS _left_3\n            INNER JOIN (\n              SELECT\n                 id AS _gsql2rsql_l_id\n                ,amount AS _gsql2rsql_l_amount\n                ,balance AS _gsql2rsql_l_balance\n                ,interest_rate AS _gsql2rsql_l_interest_rate\n                ,status AS _gsql2rsql_l_status\n                ,origination_date AS _gsql2rsql_l_origination_date\n              FROM\n                catalog.credit.Loan\n            ) AS _right_3 ON\n              _right_3._gsql2rsql_l_id = _left_3._gsql2rsql__anon1_loan_id\n          ) AS _left_2\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon2_customer_id\n              ,loan_id AS _gsql2rsql__anon2_loan_id\n            FROM\n              catalog.credit.CoBorrower\n          ) AS _right_2 ON\n            _left_2._gsql2rsql_l_id = _right_2._gsql2rsql__anon2_loan_id\n        ) AS _left_1\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_c2_id\n            ,name AS _gsql2rsql_c2_name\n            ,status AS _gsql2rsql_c2_status\n          FROM\n            catalog.credit.Customer\n        ) AS _right_1 ON\n          _right_1._gsql2rsql_c2_id = _left_1._gsql2rsql__anon2_customer_id\n      ) AS _filter\n      WHERE (_gsql2rsql_c1_id) &lt; (_gsql2rsql_c2_id)\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         _left_5._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n        ,_left_5._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n        ,_left_5._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n        ,_left_5._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_5._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_5._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n        ,_left_5._gsql2rsql_a1_balance AS _gsql2rsql_a1_balance\n        ,_left_5._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n        ,_left_5._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n        ,_left_5._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n        ,_left_5._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n        ,_left_5._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_5._gsql2rsql_a2_id AS _gsql2rsql_a2_id\n        ,_right_5._gsql2rsql_a2_balance AS _gsql2rsql_a2_balance\n      FROM (\n        SELECT\n           _left_6._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n          ,_left_6._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n          ,_left_6._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n          ,_left_6._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_6._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_left_6._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n          ,_left_6._gsql2rsql_a1_balance AS _gsql2rsql_a1_balance\n          ,_left_6._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n          ,_left_6._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n          ,_left_6._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n          ,_right_6._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n          ,_right_6._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        FROM (\n          SELECT\n             _left_7._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n            ,_left_7._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n            ,_left_7._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n            ,_left_7._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_7._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n            ,_left_7._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n            ,_left_7._gsql2rsql_a1_balance AS _gsql2rsql_a1_balance\n            ,_right_7._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n            ,_right_7._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n            ,_right_7._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n          FROM (\n            SELECT\n               _left_8._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n              ,_left_8._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n              ,_left_8._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n              ,_left_8._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_left_8._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n              ,_right_8._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n              ,_right_8._gsql2rsql_a1_balance AS _gsql2rsql_a1_balance\n            FROM (\n              SELECT\n                 _left_9._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n                ,_left_9._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n                ,_left_9._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n                ,_right_9._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n                ,_right_9._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n              FROM (\n                SELECT\n                   id AS _gsql2rsql_c1_id\n                  ,name AS _gsql2rsql_c1_name\n                  ,status AS _gsql2rsql_c1_status\n                FROM\n                  catalog.credit.Customer\n              ) AS _left_9\n              INNER JOIN (\n                SELECT\n                   customer_id AS _gsql2rsql__anon1_customer_id\n                  ,account_id AS _gsql2rsql__anon1_account_id\n                FROM\n                  catalog.credit.CustomerAccount\n              ) AS _right_9 ON\n                _left_9._gsql2rsql_c1_id = _right_9._gsql2rsql__anon1_customer_id\n            ) AS _left_8\n            INNER JOIN (\n              SELECT\n                 id AS _gsql2rsql_a1_id\n                ,balance AS _gsql2rsql_a1_balance\n              FROM\n                catalog.credit.Account\n            ) AS _right_8 ON\n              _right_8._gsql2rsql_a1_id = _left_8._gsql2rsql__anon1_account_id\n          ) AS _left_7\n          INNER JOIN (\n            SELECT\n               id AS _gsql2rsql_c2_id\n              ,name AS _gsql2rsql_c2_name\n              ,status AS _gsql2rsql_c2_status\n            FROM\n              catalog.credit.Customer\n          ) AS _right_7 ON\n            TRUE\n        ) AS _left_6\n        INNER JOIN (\n          SELECT\n             customer_id AS _gsql2rsql__anon2_customer_id\n            ,account_id AS _gsql2rsql__anon2_account_id\n          FROM\n            catalog.credit.CustomerAccount\n        ) AS _right_6 ON\n          _left_6._gsql2rsql_c2_id = _right_6._gsql2rsql__anon2_customer_id\n      ) AS _left_5\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_a2_id\n          ,balance AS _gsql2rsql_a2_balance\n        FROM\n          catalog.credit.Account\n      ) AS _right_5 ON\n        _right_5._gsql2rsql_a2_id = _left_5._gsql2rsql__anon2_account_id\n    ) AS _right_0 ON\n      _left_0._gsql2rsql_c1_id = _right_0._gsql2rsql_c1_id\n      AND _left_0._gsql2rsql_c2_id = _right_0._gsql2rsql_c2_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_c1_id, _gsql2rsql_c2_id, _gsql2rsql_l_id, _gsql2rsql_c1_name, _gsql2rsql_c1_status, _gsql2rsql_c2_name, _gsql2rsql_c2_status, _gsql2rsql_l_amount, _gsql2rsql_l_balance, _gsql2rsql_l_interest_rate, _gsql2rsql_l_origination_date, _gsql2rsql_l_status\n) AS _proj\nORDER BY combined_liquidity DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c1:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:CO_BORROWER]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: l:Loan\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:CO_BORROWER]&lt;-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: c2:Customer\n*\nOpId=11 Op=DataSourceOperator; InOpIds=; OutOpIds=17;\n  DataSourceOperator(id=11)\n    DataSource: c1:Customer\n*\nOpId=12 Op=DataSourceOperator; InOpIds=; OutOpIds=17;\n  DataSourceOperator(id=12)\n    DataSource: [_anon1:HAS_ACCOUNT]-&gt;\n*\nOpId=13 Op=DataSourceOperator; InOpIds=; OutOpIds=18;\n  DataSourceOperator(id=13)\n    DataSource: a1:Account\n*\nOpId=14 Op=DataSourceOperator; InOpIds=; OutOpIds=19;\n  DataSourceOperator(id=14)\n    DataSource: c2:Customer\n*\nOpId=15 Op=DataSourceOperator; InOpIds=; OutOpIds=20;\n  DataSourceOperator(id=15)\n    DataSource: [_anon2:HAS_ACCOUNT]-&gt;\n*\nOpId=16 Op=DataSourceOperator; InOpIds=; OutOpIds=21;\n  DataSourceOperator(id=16)\n    DataSource: a2:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=_anon1 Type=SOURCE\n*\nOpId=17 Op=JoinOperator; InOpIds=11,12; OutOpIds=18;\n  JoinOperator(id=17)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon1 Type=SINK\n*\nOpId=18 Op=JoinOperator; InOpIds=17,13; OutOpIds=19;\n  JoinOperator(id=18)\n    JoinType: INNER\n    Joins: JoinPair: Node=a1 RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=l RelOrNode=_anon2 Type=SINK\n*\nOpId=19 Op=JoinOperator; InOpIds=18,14; OutOpIds=20;\n  JoinOperator(id=19)\n    JoinType: INNER\n    Joins: \n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=10;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=c2 RelOrNode=_anon2 Type=SOURCE\n*\nOpId=20 Op=JoinOperator; InOpIds=19,15; OutOpIds=21;\n  JoinOperator(id=20)\n    JoinType: INNER\n    Joins: JoinPair: Node=c2 RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=SelectionOperator; InOpIds=9; OutOpIds=22;\n  SelectionOperator(id=10)\n    Filter: (c1.id LT c2.id)\n*\nOpId=21 Op=JoinOperator; InOpIds=20,16; OutOpIds=22;\n  JoinOperator(id=21)\n    JoinType: INNER\n    Joins: JoinPair: Node=a2 RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=22 Op=JoinOperator; InOpIds=10,21; OutOpIds=23;\n  JoinOperator(id=22)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=c1 Type=NODE_ID, JoinPair: Node=c2 RelOrNode=c2 Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=23 Op=ProjectionOperator; InOpIds=22; OutOpIds=24;\n  ProjectionOperator(id=23)\n    Projections: c1=c1, c2=c2, l=l, c1_avg_balance=AVG(a1.balance), c2_avg_balance=AVG(a2.balance)\n*\n----------------------------------------------------------------------\nLevel 8:\n----------------------------------------------------------------------\nOpId=24 Op=ProjectionOperator; InOpIds=23; OutOpIds=;\n  ProjectionOperator(id=24)\n    Projections: id=c1.id, id=c2.id, loan_id=l.id, balance=l.balance, c1_avg_balance=c1_avg_balance, c2_avg_balance=c2_avg_balance, combined_liquidity=(c1_avg_balance PLUS c2_avg_balance)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/","title":"Features Queries","text":"<p>This page contains transpiled examples for features queries queries.</p> <p>Disclaimer</p> <p>These examples were generated by Claude, and I believe Claude was overconfident about the usefulness of these queries. Therefore, these examples require further curation and validation, including the transpilation results. if you spot any issues, please open an issue or contribute at https://github.com/devmessias/gsql2rsql/issues</p> <p>Each example shows the original OpenCypher query and its corresponding Databricks SQL translation.</p>"},{"location":"examples/features/#1-simple-node-lookup-retrieve-all-nodes-of-a-type","title":"1. Simple node lookup - retrieve all nodes of a type","text":"<p>Application: Features: Basic MATCH</p> Notes <p>The simplest query pattern - retrieves all nodes with a label.</p> <p>WHY USEFUL: Foundation of all graph queries. Start here to explore data.</p> <p>DATABRICKS COMPLEXITY: O(n) - single table scan COST: Very low. Maps to: SELECT name, age FROM Person Optimizations: Partition pruning if table is partitioned.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN p.name, p.age\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_p_age AS age\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,age AS _gsql2rsql_p_age\n  FROM\n    catalog.demo.Person\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: name=p.name, age=p.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#2-property-filter-with-where-clause","title":"2. Property filter with WHERE clause","text":"<p>Application: Features: WHERE filtering</p> Notes <p>Filters nodes by property values using boolean conditions.</p> <p>WHY USEFUL: Essential for narrowing results. Supports =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, AND, OR, NOT.</p> <p>DATABRICKS COMPLEXITY: O(n) without index, O(log n) with Delta index COST: Low. WHERE pushdown to storage layer in Delta Lake. TIP: Create Z-ORDER on frequently filtered columns.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nWHERE p.age &gt; 30 AND p.active = true\nRETURN p.name, p.age\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_p_age AS age\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,age AS _gsql2rsql_p_age\n    ,active AS _gsql2rsql_p_active\n  FROM\n    catalog.demo.Person\n  WHERE (((age) &gt; (30)) AND ((active) = (TRUE)))\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=3;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: ((p.age GT 30) AND (p.active EQ true))\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=3 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=3)\n    Projections: name=p.name, age=p.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#3-property-projection-with-aliases","title":"3. Property projection with aliases","text":"<p>Application: Features: SELECT aliases</p> Notes <p>Projects specific properties with custom column names.</p> <p>WHY USEFUL: Control output schema, rename for clarity, reduce data transfer.</p> <p>DATABRICKS COMPLEXITY: O(n) - projection happens after scan COST: Very low. Column pruning reduces I/O. Note: Only requested columns are read from Delta Lake.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN p.name AS personName, p.age AS personAge, p.salary AS income\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS personName\n  ,_gsql2rsql_p_age AS personAge\n  ,_gsql2rsql_p_salary AS income\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,age AS _gsql2rsql_p_age\n    ,salary AS _gsql2rsql_p_salary\n  FROM\n    catalog.demo.Person\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: personName=p.name, personAge=p.age, income=p.salary\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#4-pagination-with-order-by-skip-and-limit","title":"4. Pagination with ORDER BY, SKIP and LIMIT","text":"<p>Application: Features: Pagination</p> Notes <p>Orders results and returns a specific page of data.</p> <p>WHY USEFUL: Implement pagination in APIs, get top-N results.</p> <p>DATABRICKS COMPLEXITY: O(n log n) for sorting COST: Medium. Full sort before SKIP/LIMIT. WARNING: SKIP without ORDER BY gives non-deterministic results. TIP: For large offsets, consider keyset pagination instead.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN p.name, p.age\nORDER BY p.age DESC\nSKIP 10 LIMIT 5\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_p_age AS age\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,age AS _gsql2rsql_p_age\n  FROM\n    catalog.demo.Person\n) AS _proj\nORDER BY _gsql2rsql_p_age DESC\nLIMIT 5\nOFFSET 10\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: name=p.name, age=p.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#5-count-aggregation-without-grouping","title":"5. COUNT aggregation without grouping","text":"<p>Application: Features: COUNT</p> Notes <p>Counts all nodes matching the pattern.</p> <p>WHY USEFUL: Get cardinality metrics, validate data.</p> <p>DATABRICKS COMPLEXITY: O(n) - single pass COST: Very low. COUNT(*) is highly optimized in Delta Lake. Returns single row. NULL values are counted.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN COUNT(p) AS totalPeople\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   COUNT(_gsql2rsql_p_id) AS totalPeople\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n  FROM\n    catalog.demo.Person\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: totalPeople=COUNT(p)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#6-group-by-with-multiple-aggregations","title":"6. GROUP BY with multiple aggregations","text":"<p>Application: Features: GROUP BY</p> Notes <p>Groups by non-aggregated columns, computes multiple metrics per group.</p> <p>WHY USEFUL: Analytics dashboards, summary reports, KPIs.</p> <p>DATABRICKS COMPLEXITY: O(n) with hash aggregation COST: Medium. Memory for hash table proportional to group count. Cypher implicit GROUP BY: all non-aggregated RETURN columns become keys.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:LIVES_IN]-&gt;(c:City)\nRETURN c.name AS city,\n       COUNT(p) AS population,\n       AVG(p.age) AS avgAge,\n       MIN(p.salary) AS minSalary,\n       MAX(p.salary) AS maxSalary\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_name AS city\n  ,COUNT(_gsql2rsql_p_id) AS population\n  ,AVG(CAST(_gsql2rsql_p_age AS DOUBLE)) AS avgAge\n  ,MIN(_gsql2rsql_p_salary) AS minSalary\n  ,MAX(_gsql2rsql_p_salary) AS maxSalary\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql_p_salary AS _gsql2rsql_p_salary\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_left_1._gsql2rsql_p_salary AS _gsql2rsql_p_salary\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,age AS _gsql2rsql_p_age\n        ,salary AS _gsql2rsql_p_salary\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,city_id AS _gsql2rsql__anon1_city_id\n      FROM\n        catalog.demo.LivesIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n      ,name AS _gsql2rsql_c_name\n    FROM\n      catalog.demo.City\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_city_id\n) AS _proj\nGROUP BY _gsql2rsql_c_name\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:City\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: city=c.name, population=COUNT(p), avgAge=AVG(p.age), minSalary=MIN(p.salary), maxSalary=MAX(p.salary)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#7-aggregation-with-order-by-on-aggregated-column","title":"7. Aggregation with ORDER BY on aggregated column","text":"<p>Application: Features: ORDER BY aggregates</p> Notes <p>Orders grouped results by aggregated values.</p> <p>WHY USEFUL: Find top cities, worst performers, outliers.</p> <p>DATABRICKS COMPLEXITY: O(n) aggregate + O(g log g) sort where g = groups COST: Medium. Sort happens after aggregation. TIP: LIMIT reduces sort cost significantly.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:LIVES_IN]-&gt;(c:City)\nRETURN c.name AS city, COUNT(p) AS population\nORDER BY population DESC\nLIMIT 10\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_name AS city\n  ,COUNT(_gsql2rsql_p_id) AS population\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,city_id AS _gsql2rsql__anon1_city_id\n      FROM\n        catalog.demo.LivesIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n      ,name AS _gsql2rsql_c_name\n    FROM\n      catalog.demo.City\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_city_id\n) AS _proj\nGROUP BY _gsql2rsql_c_name\nORDER BY population DESC\nLIMIT 10\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:City\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: city=c.name, population=COUNT(p)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#8-having-style-filter-using-withwhere","title":"8. HAVING-style filter using WITH...WHERE","text":"<p>Application: Features: HAVING filter</p> Notes <p>Filters aggregated results (SQL HAVING equivalent).</p> <p>WHY USEFUL: Filter groups by computed values. Find \"cities with &gt; 1000 people\".</p> <p>DATABRICKS COMPLEXITY: O(n) aggregate + O(g) filter COST: Low. Filter applied after aggregation, before final output. Pattern: WITH creates intermediate result, WHERE filters it.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:LIVES_IN]-&gt;(c:City)\nWITH c.name AS city, COUNT(p) AS population\nWHERE population &gt; 1000\nRETURN city, population\nORDER BY population DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   city AS city\n  ,population AS population\nFROM (\n  SELECT \n     _gsql2rsql_c_name AS city\n    ,COUNT(_gsql2rsql_p_id) AS population\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n      ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_right_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_p_id\n        FROM\n          catalog.demo.Person\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           person_id AS _gsql2rsql__anon1_person_id\n          ,city_id AS _gsql2rsql__anon1_city_id\n        FROM\n          catalog.demo.LivesIn\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_c_id\n        ,name AS _gsql2rsql_c_name\n      FROM\n        catalog.demo.City\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_city_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_c_name\n  HAVING (population) &gt; (1000)\n) AS _proj\nORDER BY population DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:City\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=7;\n  ProjectionOperator(id=6)\n    Projections: city=c.name, population=COUNT(p)\n    Having: (population GT 1000)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=6; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: city=city, population=population\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#9-collect-aggregation-into-arrays","title":"9. COLLECT aggregation into arrays","text":"<p>Application: Features: COLLECT_LIST</p> Notes <p>Collects values into an array per group.</p> <p>WHY USEFUL: Denormalize data, create nested structures for JSON APIs.</p> <p>DATABRICKS COMPLEXITY: O(n) - single pass COST: Medium-High. Memory for array construction. Maps to COLLECT_LIST() in Databricks SQL. WARNING: Large arrays can cause OOM. Consider LIMIT inside COLLECT.</p> OpenCypher Query Cypher<pre><code>MATCH (c:City)&lt;-[:LIVES_IN]-(p:Person)\nRETURN c.name AS city, COLLECT(p.name) AS residents\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_name AS city\n  ,COLLECT_LIST(_gsql2rsql_p_name) AS residents\nFROM (\n  SELECT\n     _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    ,_right_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_right_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_c_id\n        ,name AS _gsql2rsql_c_name\n      FROM\n        catalog.demo.City\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,city_id AS _gsql2rsql__anon1_city_id\n      FROM\n        catalog.demo.LivesIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_c_id = _right_1._gsql2rsql__anon1_city_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_p_id\n      ,name AS _gsql2rsql_p_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_p_id = _left_0._gsql2rsql__anon1_person_id\n) AS _proj\nGROUP BY _gsql2rsql_c_name\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: c:City\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]&lt;-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: city=c.name, residents=COLLECT(p.name)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#10-directed-relationship-traversal","title":"10. Directed relationship traversal","text":"<p>Application: Features: Directed edges</p> Notes <p>Matches directed relationships from source to target.</p> <p>WHY USEFUL: Traverse graph edges in specific direction.</p> <p>DATABRICKS COMPLEXITY: O(n * m) worst case, O(n + e) with proper joins COST: Medium. Translates to INNER JOIN. TIP: Ensure foreign keys have indexes/Z-ORDER.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)\nRETURN p.name AS actor, m.title AS movie\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS actor\n  ,_gsql2rsql_m_title AS movie\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    ,_right_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n    ,_right_0._gsql2rsql_m_title AS _gsql2rsql_m_title\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,movie_id AS _gsql2rsql__anon1_movie_id\n      FROM\n        catalog.demo.ActedIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_m_id\n      ,title AS _gsql2rsql_m_title\n    FROM\n      catalog.demo.Movie\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_m_id = _left_0._gsql2rsql__anon1_movie_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:ACTED_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: m:Movie\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: actor=p.name, movie=m.title\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#11-relationship-with-property-filter","title":"11. Relationship with property filter","text":"<p>Application: Features: Edge properties</p> Notes <p>Filters relationships by their properties.</p> <p>WHY USEFUL: Find \"strong\" relationships, recent connections.</p> <p>DATABRICKS COMPLEXITY: O(e) where e = edges COST: Medium. Filter on edge table reduces join size. Edge properties stored in edge table as columns.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[r:KNOWS]-&gt;(f:Person)\nWHERE r.since &gt; 2020 AND r.strength &gt; 0.8\nRETURN p.name AS person, f.name AS friend, r.since, r.strength\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS person\n  ,_gsql2rsql_f_name AS friend\n  ,_gsql2rsql_r_since AS since\n  ,_gsql2rsql_r_strength AS strength\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_r_person_id AS _gsql2rsql_r_person_id\n    ,_left_0._gsql2rsql_r_friend_id AS _gsql2rsql_r_friend_id\n    ,_left_0._gsql2rsql_r_since AS _gsql2rsql_r_since\n    ,_left_0._gsql2rsql_r_strength AS _gsql2rsql_r_strength\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql_r_person_id AS _gsql2rsql_r_person_id\n      ,_right_1._gsql2rsql_r_friend_id AS _gsql2rsql_r_friend_id\n      ,_right_1._gsql2rsql_r_since AS _gsql2rsql_r_since\n      ,_right_1._gsql2rsql_r_strength AS _gsql2rsql_r_strength\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql_r_person_id\n        ,friend_id AS _gsql2rsql_r_friend_id\n        ,since AS _gsql2rsql_r_since\n        ,strength AS _gsql2rsql_r_strength\n      FROM\n        catalog.demo.Knows\n      WHERE (((since) &gt; (2020)) AND ((strength) &gt; (0.8)))\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql_r_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql_r_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [r:KNOWS]-&gt;\n    Filter: ((r.since GT 2020) AND (r.strength GT 0.8))\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=r Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=r Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: person=p.name, friend=f.name, since=r.since, strength=r.strength\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#12-undirected-relationship-both-directions","title":"12. Undirected relationship (both directions)","text":"<p>Application: Features: Undirected edges</p> Notes <p>Matches relationships in both directions.</p> <p>WHY USEFUL: Social networks where direction doesn't matter.</p> <p>DATABRICKS COMPLEXITY: O(2e) - UNION of both directions COST: Higher. Translates to UNION of forward and reverse joins. May produce duplicates - use DISTINCT if needed.</p> <p>OPTIMIZATION: Predicate pushdown moves WHERE p.name = 'Alice' into the Person table subquery BEFORE the join, dramatically reducing rows.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice'\nRETURN DISTINCT f.name AS friend\n</code></pre> Generated SQL SQL<pre><code>SELECT DISTINCT \n   _gsql2rsql_f_name AS friend\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: friend=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#13-undirected-with-source-filter-pushdown","title":"13. Undirected with source filter pushdown","text":"<p>Application: Features: Predicate Pushdown</p> Notes <p>Compound source-only filter is pushed into the Person subquery.</p> <p>OPTIMIZATION APPLIED:   BEFORE: Full Person scan \u2192 Full KNOWS scan \u2192 Full Person scan \u2192 Filter   AFTER:  Filtered Person (name='Alice' AND age&gt;25) \u2192 KNOWS \u2192 Person</p> <p>WHY IT MATTERS: If Person table has 1M rows but only 1 Alice over 25, we process 1 row instead of 1M in the initial joins.</p> <p>SQL Pattern (optimized):   FROM (SELECT ... FROM Person WHERE name='Alice' AND age&gt;25) AS p   JOIN Knows ON (p.id = source_id OR p.id = target_id)   JOIN Person AS f ON ...</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice' AND p.age &gt; 25\nRETURN f.name AS friend, f.age AS friendAge\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_f_name AS friend\n  ,_gsql2rsql_f_age AS friendAge\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,age AS _gsql2rsql_p_age\n      FROM\n        catalog.demo.Person\n      WHERE (((name) = ('Alice')) AND ((age) &gt; (25)))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: ((p.name EQ 'Alice') AND (p.age GT 25))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: friend=f.name, friendAge=f.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#14-undirected-with-target-filter-not-pushed","title":"14. Undirected with target filter (not pushed)","text":"<p>Application: Features: Filter Semantics</p> Notes <p>Target node filter cannot be pushed to source - stays after join.</p> <p>WHY NOT PUSHED: The filter references 'f' (target), which is only known after traversing the relationship. The filter must remain after the join to correctly filter matching targets.</p> <p>SQL Pattern:   FROM Person AS p   JOIN Knows ON ...   JOIN Person AS f ON ...   WHERE f.age &gt; 30  -- Applied after all joins</p> <p>COST: Higher than source pushdown - full initial scans required.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE f.age &gt; 30\nRETURN p.name AS person, f.name AS olderFriend\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS person\n  ,_gsql2rsql_f_name AS olderFriend\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) &gt; (30))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age GT 30)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: person=p.name, olderFriend=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#15-undirected-with-mixed-filters-partial-pushdown","title":"15. Undirected with mixed filters (partial pushdown)","text":"<p>Application: Features: Filter Splitting</p> Notes <p>Source filters are pushed, target filter remains after join.</p> <p>FILTER ANALYSIS:   p.name = 'Alice'  \u2192 PUSHED (references only 'p')   p.active = true   \u2192 PUSHED (references only 'p')   f.age &gt; 30        \u2192 NOT PUSHED (references 'f')</p> <p>SQL Pattern (optimized):   FROM (SELECT ... FROM Person WHERE name='Alice' AND active=true) AS p   JOIN Knows ON ...   JOIN Person AS f ON ...   WHERE f.age &gt; 30  -- Target filter stays here</p> <p>BENEFIT: Source node filtering happens early, reducing join size. Target filtering still required but on smaller intermediate result.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice' AND f.age &gt; 30 AND p.active = true\nRETURN f.name AS friend, f.age AS friendAge\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_f_name AS friend\n  ,_gsql2rsql_f_age AS friendAge\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_active AS _gsql2rsql_p_active\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_active AS _gsql2rsql_p_active\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,active AS _gsql2rsql_p_active\n      FROM\n        catalog.demo.Person\n      WHERE (((name) = ('Alice')) AND ((active) = (TRUE)))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) &gt; (30))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: ((p.name EQ 'Alice') AND (p.active EQ true))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age GT 30)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: friend=f.name, friendAge=f.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#16-undirected-multi-hop-with-predicate-pushdown","title":"16. Undirected multi-hop with predicate pushdown","text":"<p>Application: Features: Complex Traversal</p> Notes <p>Multi-hop undirected traversal with source filter pushdown.</p> <p>PATTERN: Alice's friends' friends (2-hop undirected)</p> <p>OPTIMIZATION: Filter p.name='Alice' is pushed into first Person scan. Each hop doubles potential paths, so early filtering is critical.</p> <p>SQL Pattern:   FROM (SELECT ... FROM Person WHERE name='Alice') AS p   JOIN Knows k1 ON (p.id = k1.person_id OR p.id = k1.friend_id)   JOIN Person m ON (m.id = k1.person_id OR m.id = k1.friend_id)   JOIN Knows k2 ON (m.id = k2.person_id OR m.id = k2.friend_id)   JOIN Person f ON (f.id = k2.person_id OR f.id = k2.friend_id)</p> <p>DATABRICKS COMPLEXITY: O(k^2) where k = avg degree COST: High, but pushdown prevents O(n * k^2) explosion.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(m:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice'\nRETURN DISTINCT f.name AS friendOfFriend\n</code></pre> Generated SQL SQL<pre><code>SELECT DISTINCT \n   _gsql2rsql_f_name AS friendOfFriend\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_left_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n    ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n    ,_left_0._gsql2rsql__anon2_friend_id AS _gsql2rsql__anon2_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      ,_left_1._gsql2rsql_m_id AS _gsql2rsql_m_id\n      ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_right_1._gsql2rsql__anon2_friend_id AS _gsql2rsql__anon2_friend_id\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_2._gsql2rsql_p_name AS _gsql2rsql_p_name\n        ,_left_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_left_2._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n        ,_right_2._gsql2rsql_m_id AS _gsql2rsql_m_id\n      FROM (\n        SELECT\n           _left_3._gsql2rsql_p_id AS _gsql2rsql_p_id\n          ,_left_3._gsql2rsql_p_name AS _gsql2rsql_p_name\n          ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n          ,_right_3._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_p_id\n            ,name AS _gsql2rsql_p_name\n          FROM\n            catalog.demo.Person\n          WHERE ((name) = ('Alice'))\n        ) AS _left_3\n        INNER JOIN (\n          SELECT\n             person_id AS _gsql2rsql__anon1_person_id\n            ,friend_id AS _gsql2rsql__anon1_friend_id\n            ,since AS _gsql2rsql__anon1_since\n            ,strength AS _gsql2rsql__anon1_strength\n          FROM\n            catalog.demo.Knows\n          UNION ALL\n          SELECT\n             friend_id AS _gsql2rsql__anon1_person_id\n            ,person_id AS _gsql2rsql__anon1_friend_id\n            ,since AS _gsql2rsql__anon1_since\n            ,strength AS _gsql2rsql__anon1_strength\n          FROM\n            catalog.demo.Knows\n        ) AS _right_3 ON\n          _left_3._gsql2rsql_p_id = _right_3._gsql2rsql__anon1_person_id\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_m_id\n        FROM\n          catalog.demo.Person\n      ) AS _right_2 ON\n        _right_2._gsql2rsql_m_id = _left_2._gsql2rsql__anon1_friend_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon2_person_id\n        ,friend_id AS _gsql2rsql__anon2_friend_id\n        ,since AS _gsql2rsql__anon2_since\n        ,strength AS _gsql2rsql__anon2_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon2_person_id\n        ,person_id AS _gsql2rsql__anon2_friend_id\n        ,since AS _gsql2rsql__anon2_since\n        ,strength AS _gsql2rsql__anon2_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_m_id = _right_1._gsql2rsql__anon2_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon2_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: m:Person\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:KNOWS]-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon2 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon2 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: friendOfFriend=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#17-undirected-relationship-with-aggregation","title":"17. Undirected relationship with aggregation","text":"<p>Application: Features: Aggregation + Pushdown</p> Notes <p>Aggregation over undirected relationships with source filter.</p> <p>USE CASE: \"High earners and their social network metrics\"</p> <p>OPTIMIZATION: p.salary &gt; 100000 pushed to Person scan. Only high earners participate in the aggregation joins.</p> <p>SQL Pattern:   SELECT p.name, COUNT(f.id), AVG(f.age)   FROM (SELECT ... FROM Person WHERE salary &gt; 100000) AS p   JOIN Knows ON ...   JOIN Person AS f ON ...   GROUP BY p.id, p.name</p> <p>COST: Filter before aggregation = fewer GROUP BY operations.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[r:KNOWS]-(f:Person)\nWHERE p.salary &gt; 100000\nRETURN p.name AS highEarner,\n       COUNT(f) AS friendCount,\n       AVG(f.age) AS avgFriendAge\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS highEarner\n  ,COUNT(_gsql2rsql_f_id) AS friendCount\n  ,AVG(CAST(_gsql2rsql_f_age AS DOUBLE)) AS avgFriendAge\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_salary AS _gsql2rsql_p_salary\n    ,_left_0._gsql2rsql_r_person_id AS _gsql2rsql_r_person_id\n    ,_left_0._gsql2rsql_r_friend_id AS _gsql2rsql_r_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_salary AS _gsql2rsql_p_salary\n      ,_right_1._gsql2rsql_r_person_id AS _gsql2rsql_r_person_id\n      ,_right_1._gsql2rsql_r_friend_id AS _gsql2rsql_r_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,salary AS _gsql2rsql_p_salary\n      FROM\n        catalog.demo.Person\n      WHERE ((salary) &gt; (100000))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql_r_person_id\n        ,friend_id AS _gsql2rsql_r_friend_id\n        ,since AS _gsql2rsql_r_since\n        ,strength AS _gsql2rsql_r_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql_r_person_id\n        ,person_id AS _gsql2rsql_r_friend_id\n        ,since AS _gsql2rsql_r_since\n        ,strength AS _gsql2rsql_r_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql_r_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql_r_friend_id\n) AS _proj\nGROUP BY _gsql2rsql_p_name\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.salary GT 100000)\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [r:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=r Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=r Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: highEarner=p.name, friendCount=COUNT(f), avgFriendAge=AVG(f.age)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#18-optional-match-left-join-semantics","title":"18. OPTIONAL MATCH (left join semantics)","text":"<p>Application: Features: OPTIONAL MATCH</p> Notes <p>Returns all people, with movies if they exist (NULL otherwise).</p> <p>WHY USEFUL: Include all entities even without relationships.</p> <p>DATABRICKS COMPLEXITY: O(n + e) - LEFT JOIN COST: Medium. LEFT JOIN preserves all left-side rows. CRITICAL: Uses LEFT JOIN, not INNER JOIN. NULL values appear where no relationship exists.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nOPTIONAL MATCH (p)-[:ACTED_IN]-&gt;(m:Movie)\nRETURN p.name, m.title\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_m_title AS title\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_right_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_right_0._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    ,_right_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n    ,_right_0._gsql2rsql_m_title AS _gsql2rsql_m_title\n  FROM (\n    SELECT\n       id AS _gsql2rsql_p_id\n      ,name AS _gsql2rsql_p_name\n    FROM\n      catalog.demo.Person\n  ) AS _left_0\n  LEFT JOIN (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_1._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n      ,_right_1._gsql2rsql_m_id AS _gsql2rsql_m_id\n      ,_right_1._gsql2rsql_m_title AS _gsql2rsql_m_title\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_2._gsql2rsql_p_name AS _gsql2rsql_p_name\n        ,_right_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_right_2._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_p_id\n          ,name AS _gsql2rsql_p_name\n        FROM\n          catalog.demo.Person\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           person_id AS _gsql2rsql__anon1_person_id\n          ,movie_id AS _gsql2rsql__anon1_movie_id\n        FROM\n          catalog.demo.ActedIn\n      ) AS _right_2 ON\n        _left_2._gsql2rsql_p_id = _right_2._gsql2rsql__anon1_person_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_m_id\n        ,title AS _gsql2rsql_m_title\n      FROM\n        catalog.demo.Movie\n    ) AS _right_1 ON\n      _right_1._gsql2rsql_m_id = _left_1._gsql2rsql__anon1_movie_id\n  ) AS _right_0 ON\n    _left_0._gsql2rsql_p_id = _right_0._gsql2rsql_p_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=2)\n    DataSource: p:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: [_anon1:ACTED_IN]-&gt;\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=4)\n    DataSource: m:Movie\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=2,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=5,4; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=1,6; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: LEFT\n    Joins: JoinPair: Node=p RelOrNode=p Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: name=p.name, title=m.title\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#19-variable-length-path-traversal-1-to-3-hops","title":"19. Variable-length path traversal (1 to 3 hops)","text":"<p>Application: Features: Recursive paths</p> Notes <p>Finds all people reachable within 1-3 hops.</p> <p>WHY USEFUL: Friend-of-friend queries, network analysis, influence propagation.</p> <p>DATABRICKS COMPLEXITY: O(k^d) where k=avg degree, d=max depth COST: HIGH. Uses WITH RECURSIVE CTE. Includes cycle detection to prevent infinite loops.</p> <p>SQL Pattern: WITH RECURSIVE paths AS (   -- base case   UNION ALL   -- recursive case with depth &lt; max_depth )</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS*1..3]-&gt;(f:Person)\nWHERE p.name = 'Alice'\nRETURN DISTINCT f.name AS reachable\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n    JOIN catalog.demo.Person src ON src.id = e.person_id\n    WHERE (src.name) = ('Alice')\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT DISTINCT \n   _gsql2rsql_f_name AS reachable\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_f_id\n    ,sink.name AS _gsql2rsql_f_name\n    ,sink.age AS _gsql2rsql_f_age\n    ,sink.nickname AS _gsql2rsql_f_nickname\n    ,sink.salary AS _gsql2rsql_f_salary\n    ,sink.active AS _gsql2rsql_f_active\n    ,source.id AS _gsql2rsql_p_id\n    ,source.name AS _gsql2rsql_p_name\n    ,source.age AS _gsql2rsql_p_age\n    ,source.nickname AS _gsql2rsql_p_nickname\n    ,source.salary AS _gsql2rsql_p_salary\n    ,source.active AS _gsql2rsql_p_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 3\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..3)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: reachable=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#20-variable-length-path-with-zero-length-includes-self","title":"20. Variable-length path with zero-length (includes self)","text":"<p>Application: Features: Zero-length paths</p> Notes <p>Includes the starting node (depth=0) plus 1-2 hop neighbors.</p> <p>WHY USEFUL: Include self in results, optional relationship matching.</p> <p>DATABRICKS COMPLEXITY: O(1 + k + k^2) - identity + 1-hop + 2-hop COST: HIGH. Recursive CTE with special depth=0 base case. Depth 0 = no joins, just the starting node.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS*0..2]-&gt;(f:Person)\nWHERE p.name = 'Alice'\nRETURN DISTINCT f.name AS reachable\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: Zero-length paths (depth = 0)\n    SELECT\n      n.id AS start_node,\n      n.id AS end_node,\n      0 AS depth,\n      ARRAY(n.id) AS path,\n      ARRAY() AS visited\n    FROM catalog.demo.Person n\n    WHERE (n.name) = ('Alice')\n\n    UNION ALL\n\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n    JOIN catalog.demo.Person src ON src.id = e.person_id\n    WHERE (src.name) = ('Alice')\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT DISTINCT \n   _gsql2rsql_f_name AS reachable\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_f_id\n    ,sink.name AS _gsql2rsql_f_name\n    ,sink.age AS _gsql2rsql_f_age\n    ,sink.nickname AS _gsql2rsql_f_nickname\n    ,sink.salary AS _gsql2rsql_f_salary\n    ,sink.active AS _gsql2rsql_f_active\n    ,source.id AS _gsql2rsql_p_id\n    ,source.name AS _gsql2rsql_p_name\n    ,source.age AS _gsql2rsql_p_age\n    ,source.nickname AS _gsql2rsql_p_nickname\n    ,source.salary AS _gsql2rsql_p_salary\n    ,source.active AS _gsql2rsql_p_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 0 AND p.depth &lt;= 2\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*0..2)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: reachable=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#21-case-expression-for-conditional-values","title":"21. CASE expression for conditional values","text":"<p>Application: Features: CASE WHEN</p> Notes <p>Evaluates conditions sequentially, returns first match.</p> <p>WHY USEFUL: Categorize data, compute derived fields, business logic.</p> <p>DATABRICKS COMPLEXITY: O(n) - evaluated per row COST: Very low. Direct translation to SQL CASE. First matching WHEN wins. ELSE is optional (defaults to NULL). Can be used in WHERE, ORDER BY, GROUP BY.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN p.name,\n       CASE\n         WHEN p.age &lt; 18 THEN 'minor'\n         WHEN p.age &lt; 65 THEN 'adult'\n         ELSE 'senior'\n       END AS ageGroup\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,CASE WHEN (_gsql2rsql_p_age) &lt; (18) THEN 'minor' WHEN (_gsql2rsql_p_age) &lt; (65) THEN 'adult' ELSE 'senior' END AS ageGroup\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,age AS _gsql2rsql_p_age\n  FROM\n    catalog.demo.Person\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: name=p.name, ageGroup=CASE WHEN (p.age LT 18) THEN 'minor' WHEN (p.age LT 65) THEN 'adult' ELSE 'senior' END\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#22-coalesce-for-null-safe-default-values","title":"22. COALESCE for null-safe default values","text":"<p>Application: Features: COALESCE</p> Notes <p>Returns first non-NULL value from the argument list.</p> <p>WHY USEFUL: Handle missing data, provide defaults.</p> <p>DATABRICKS COMPLEXITY: O(n) - evaluated per row COST: Very low. Native Databricks function. Left-to-right evaluation with short-circuit. COALESCE(a, b, c) = first non-NULL of a, b, c.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)\nRETURN COALESCE(p.nickname, p.name) AS displayName,\n       COALESCE(p.salary, 0) AS salary\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   COALESCE(_gsql2rsql_p_nickname, _gsql2rsql_p_name) AS displayName\n  ,COALESCE(_gsql2rsql_p_salary, 0) AS salary\nFROM (\n  SELECT\n     id AS _gsql2rsql_p_id\n    ,name AS _gsql2rsql_p_name\n    ,nickname AS _gsql2rsql_p_nickname\n    ,salary AS _gsql2rsql_p_salary\n  FROM\n    catalog.demo.Person\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=ProjectionOperator; InOpIds=1; OutOpIds=;\n  ProjectionOperator(id=2)\n    Projections: displayName=COALESCE(p.nickname, p.name), salary=COALESCE(p.salary, 0)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#23-distinct-for-deduplication","title":"23. DISTINCT for deduplication","text":"<p>Application: Features: DISTINCT</p> Notes <p>Removes duplicate rows from results.</p> <p>WHY USEFUL: Get unique values, eliminate duplicates from traversals.</p> <p>DATABRICKS COMPLEXITY: O(n log n) or O(n) with hash COST: Medium. Requires sorting or hashing. NULL is treated as a distinct value. Compares ALL returned columns for uniqueness.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)\nRETURN DISTINCT m.genre\n</code></pre> Generated SQL SQL<pre><code>SELECT DISTINCT \n   _gsql2rsql_m_genre AS genre\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    ,_right_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n    ,_right_0._gsql2rsql_m_genre AS _gsql2rsql_m_genre\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,movie_id AS _gsql2rsql__anon1_movie_id\n      FROM\n        catalog.demo.ActedIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_m_id\n      ,genre AS _gsql2rsql_m_genre\n    FROM\n      catalog.demo.Movie\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_m_id = _left_0._gsql2rsql__anon1_movie_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:ACTED_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: m:Movie\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: genre=m.genre\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#24-union-to-combine-query-results","title":"24. UNION to combine query results","text":"<p>Application: Features: UNION</p> Notes <p>Combines results from two queries, removes duplicates.</p> <p>WHY USEFUL: Merge different query paths, find \"actors OR directors\".</p> <p>DATABRICKS COMPLEXITY: O(n + m + (n+m) log(n+m)) for dedup COST: High. UNION requires deduplication. Both queries must have same column count and compatible types. Use UNION ALL if duplicates are OK (faster).</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)\nRETURN p.name AS name\nUNION\nMATCH (d:Person)-[:DIRECTED]-&gt;(m:Movie)\nRETURN d.name AS name\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    ,_right_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,movie_id AS _gsql2rsql__anon1_movie_id\n      FROM\n        catalog.demo.ActedIn\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_m_id\n    FROM\n      catalog.demo.Movie\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_m_id = _left_0._gsql2rsql__anon1_movie_id\n) AS _proj\nUNION\nSELECT \n   _gsql2rsql_d_name AS name\nFROM (\n  SELECT\n     _left_2._gsql2rsql_d_id AS _gsql2rsql_d_id\n    ,_left_2._gsql2rsql_d_name AS _gsql2rsql_d_name\n    ,_left_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_2._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    ,_right_2._gsql2rsql_m_id AS _gsql2rsql_m_id\n  FROM (\n    SELECT\n       _left_3._gsql2rsql_d_id AS _gsql2rsql_d_id\n      ,_left_3._gsql2rsql_d_name AS _gsql2rsql_d_name\n      ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_3._gsql2rsql__anon1_movie_id AS _gsql2rsql__anon1_movie_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_d_id\n        ,name AS _gsql2rsql_d_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_3\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,movie_id AS _gsql2rsql__anon1_movie_id\n      FROM\n        catalog.demo.Directed\n    ) AS _right_3 ON\n      _left_3._gsql2rsql_d_id = _right_3._gsql2rsql__anon1_person_id\n  ) AS _left_2\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_m_id\n    FROM\n      catalog.demo.Movie\n  ) AS _right_2 ON\n    _right_2._gsql2rsql_m_id = _left_2._gsql2rsql__anon1_movie_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:ACTED_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: m:Movie\n*\nOpId=7 Op=DataSourceOperator; InOpIds=; OutOpIds=10;\n  DataSourceOperator(id=7)\n    DataSource: d:Person\n*\nOpId=8 Op=DataSourceOperator; InOpIds=; OutOpIds=10;\n  DataSourceOperator(id=8)\n    DataSource: [_anon1:DIRECTED]-&gt;\n*\nOpId=9 Op=DataSourceOperator; InOpIds=; OutOpIds=11;\n  DataSourceOperator(id=9)\n    DataSource: m:Movie\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\nOpId=10 Op=JoinOperator; InOpIds=7,8; OutOpIds=11;\n  JoinOperator(id=10)\n    JoinType: INNER\n    Joins: JoinPair: Node=d RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\nOpId=11 Op=JoinOperator; InOpIds=10,9; OutOpIds=12;\n  JoinOperator(id=11)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=13;\n  ProjectionOperator(id=6)\n    Projections: name=p.name\n*\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=13;\n  ProjectionOperator(id=12)\n    Projections: name=d.name\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=13 Op=SetOperator; InOpIds=6,12; OutOpIds=;\n  SetOperator(id=13)\n    SetOp: UNION\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#25-multi-hop-path-with-intermediate-filtering","title":"25. Multi-hop path with intermediate filtering","text":"<p>Application: Features: Chained patterns</p> Notes <p>Matches multiple relationship patterns from the same node.</p> <p>WHY USEFUL: Complex entity queries with multiple constraints.</p> <p>DATABRICKS COMPLEXITY: O(n * j1 * j2) worst case COST: Medium-High. Multiple JOINs. Comma-separated patterns share the same variable scope. Filter pushdown optimizes join order.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:LIVES_IN]-&gt;(c:City),\n      (p)-[:WORKS_AT]-&gt;(co:Company)\nWHERE c.country = 'USA' AND co.industry = 'Tech'\nRETURN p.name, c.name AS city, co.name AS company\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_c_name AS city\n  ,_gsql2rsql_co_name AS company\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n    ,_left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_left_0._gsql2rsql_c_country AS _gsql2rsql_c_country\n    ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n    ,_left_0._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    ,_right_0._gsql2rsql_co_id AS _gsql2rsql_co_id\n    ,_right_0._gsql2rsql_co_name AS _gsql2rsql_co_name\n    ,_right_0._gsql2rsql_co_industry AS _gsql2rsql_co_industry\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n      ,_left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_left_1._gsql2rsql_c_country AS _gsql2rsql_c_country\n      ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_right_1._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_2._gsql2rsql_p_name AS _gsql2rsql_p_name\n        ,_left_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_left_2._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n        ,_right_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_right_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_right_2._gsql2rsql_c_country AS _gsql2rsql_c_country\n      FROM (\n        SELECT\n           _left_3._gsql2rsql_p_id AS _gsql2rsql_p_id\n          ,_left_3._gsql2rsql_p_name AS _gsql2rsql_p_name\n          ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n          ,_right_3._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_p_id\n            ,name AS _gsql2rsql_p_name\n          FROM\n            catalog.demo.Person\n        ) AS _left_3\n        INNER JOIN (\n          SELECT\n             person_id AS _gsql2rsql__anon1_person_id\n            ,city_id AS _gsql2rsql__anon1_city_id\n          FROM\n            catalog.demo.LivesIn\n        ) AS _right_3 ON\n          _left_3._gsql2rsql_p_id = _right_3._gsql2rsql__anon1_person_id\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,name AS _gsql2rsql_c_name\n          ,country AS _gsql2rsql_c_country\n        FROM\n          catalog.demo.City\n        WHERE ((country) = ('USA'))\n      ) AS _right_2 ON\n        _right_2._gsql2rsql_c_id = _left_2._gsql2rsql__anon1_city_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon2_person_id\n        ,company_id AS _gsql2rsql__anon2_company_id\n      FROM\n        catalog.demo.WorksAt\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon2_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_co_id\n      ,name AS _gsql2rsql_co_name\n      ,industry AS _gsql2rsql_co_industry\n    FROM\n      catalog.demo.Company\n    WHERE ((industry) = ('Tech'))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_co_id = _left_0._gsql2rsql__anon2_company_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: c:City\n    Filter: (c.country EQ 'USA')\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:WORKS_AT]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: co:Company\n    Filter: (co.industry EQ 'Tech')\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=co RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: name=p.name, city=c.name, company=co.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#26-chained-with-for-multi-stage-computation","title":"26. Chained WITH for multi-stage computation","text":"<p>Application: Features: WITH chaining</p> Notes <p>Chains multiple WITH clauses for staged computation.</p> <p>WHY USEFUL: Break complex queries into steps, compute derived values.</p> <p>DATABRICKS COMPLEXITY: O(n) per stage COST: Medium. Each WITH creates a logical stage. Variables from previous WITH are available in next stage. Useful for aggregation \u2192 filtering \u2192 transformation pipelines.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:LIVES_IN]-&gt;(c:City)\nWITH c, COUNT(p) AS pop\nWHERE pop &gt; 100\nWITH c.name AS city, pop, pop * 1.0 / 1000 AS popK\nRETURN city, popK\nORDER BY popK DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   city AS city\n  ,popK AS popK\nFROM (\n  SELECT \n     _gsql2rsql_c_name AS city\n    ,pop AS pop\n    ,((pop) * (1.0)) / (1000) AS popK\n  FROM (\n    SELECT \n       _gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,COUNT(_gsql2rsql_p_id) AS pop\n      ,_gsql2rsql_c_country AS _gsql2rsql_c_country\n      ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_gsql2rsql_c_population AS _gsql2rsql_c_population\n    FROM (\n      SELECT\n         _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_left_0._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n        ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_right_0._gsql2rsql_c_population AS _gsql2rsql_c_population\n        ,_right_0._gsql2rsql_c_country AS _gsql2rsql_c_country\n      FROM (\n        SELECT\n           _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n          ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n          ,_right_1._gsql2rsql__anon1_city_id AS _gsql2rsql__anon1_city_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_p_id\n          FROM\n            catalog.demo.Person\n        ) AS _left_1\n        INNER JOIN (\n          SELECT\n             person_id AS _gsql2rsql__anon1_person_id\n            ,city_id AS _gsql2rsql__anon1_city_id\n          FROM\n            catalog.demo.LivesIn\n        ) AS _right_1 ON\n          _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n      ) AS _left_0\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,name AS _gsql2rsql_c_name\n          ,population AS _gsql2rsql_c_population\n          ,country AS _gsql2rsql_c_country\n        FROM\n          catalog.demo.City\n      ) AS _right_0 ON\n        _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_city_id\n    ) AS _proj\n    GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_country, _gsql2rsql_c_name, _gsql2rsql_c_population\n    HAVING (pop) &gt; (100)\n  ) AS _proj\n) AS _proj\nORDER BY popK DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:LIVES_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:City\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=7;\n  ProjectionOperator(id=6)\n    Projections: c=c, pop=COUNT(p)\n    Having: (pop GT 100)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=6; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: city=c.name, pop=pop, popK=((pop MULTIPLY 1.0) DIVIDE 1000)\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: city=city, popK=popK\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#27-simplest-sink-filter-pushdown","title":"27. Simplest sink filter pushdown","text":"<p>Application: Features: Sink Filter Pushdown</p> Notes <p>Minimal example: filter on sink node b is pushed into recursive join.</p> <p>SQL: WHERE p.depth &gt;= 1 AND p.depth &lt;= 2 AND (sink.age) &gt; (30)</p> OpenCypher Query Cypher<pre><code>MATCH (a:Person)-[:KNOWS*1..2]-&gt;(b:Person)\nWHERE b.age &gt; 30\nRETURN a.name, b.name\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_name AS name\n  ,_gsql2rsql_b_name AS name\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 2 AND (sink.age) &gt; (30)\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..2)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: name=a.name, name=b.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#28-variable-length-path-with-sink-filter-pushdown","title":"28. Variable-length path with sink filter pushdown","text":"<p>Application: Features: Recursive Sink Filter Pushdown</p> Notes <p>Filter on sink node (b.age &gt; 50) is pushed into the recursive join.</p> <p>OPTIMIZATION APPLIED:   BEFORE: CTE \u2192 JOIN sink \u2192 JOIN source \u2192 depth filter \u2192 OUTER sink filter   AFTER:  CTE \u2192 JOIN sink \u2192 JOIN source \u2192 WHERE depth AND sink.age &gt; 50</p> <p>WHY IT MATTERS: Instead of filtering 1000 paths after all joins complete, we filter during the join and only keep paths ending at older people.</p> <p>SQL Pattern (optimized):   FROM paths_1 p   JOIN Person sink ON sink.id = p.end_node   JOIN Person source ON source.id = p.start_node   WHERE p.depth &gt;= 2 AND p.depth &lt;= 4 AND (sink.age) &gt; (50)</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*2..4]-&gt;(b:Person)\nWHERE b.age &gt; 50\nRETURN a.id, b.id, LENGTH(path) AS chain_length\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 4\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS chain_length\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 2 AND p.depth &lt;= 4 AND (sink.age) &gt; (50)\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*2..4, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id, chain_length=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#29-variable-length-with-source-and-sink-filter-pushdown","title":"29. Variable-length with source AND sink filter pushdown","text":"<p>Application: Features: Dual Filter Pushdown</p> Notes <p>Both source and sink filters are optimized:   - Source filter (a.age &gt; 30) \u2192 pushed into CTE base case   - Sink filter (b.age &gt; 50) \u2192 pushed into recursive join</p> <p>BENEFIT: Maximum optimization for path queries between filtered nodes. We only explore paths starting from people over 30 (source filter) and only keep paths ending at people over 50 (sink filter).</p> <p>SQL Pattern:   Base case: ... JOIN Person src ON ... WHERE (src.age) &gt; (30)   Join: ... WHERE depth_bounds AND (sink.age) &gt; (50)</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*2..4]-&gt;(b:Person)\nWHERE a.age &gt; 30 AND b.age &gt; 50\nRETURN a.id, b.id\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n    JOIN catalog.demo.Person src ON src.id = e.person_id\n    WHERE (src.age) &gt; (30)\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 4\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 2 AND p.depth &lt;= 4 AND (sink.age) &gt; (50)\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*2..4, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#30-variable-length-with-compound-sink-filter","title":"30. Variable-length with compound sink filter","text":"<p>Application: Features: Compound Sink Filter Pushdown</p> Notes <p>Compound sink filter (AND of two conditions) is pushed together.</p> <p>OPTIMIZATION: Both conditions are applied in the recursive join WHERE:   WHERE p.depth &gt;= 1 AND ((sink.age) &gt; (40) AND sink.active = true)</p> <p>USE CASE: Find chains of connections ending at active people over 40.</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*1..3]-&gt;(b:Person)\nWHERE b.age &gt; 40 AND b.active = true\nRETURN a.id, b.id, [n IN nodes(path) | n.id] AS path_nodes\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,_gsql2rsql_path_id AS path_nodes\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 3 AND ((sink.age) &gt; (40)) AND ((sink.active) = (TRUE))\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..3, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id, path_nodes=[n IN NODES(path) | n.id]\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#31-variable-length-with-sink-filter-and-edge-predicate","title":"31. Variable-length with sink filter and edge predicate","text":"<p>Application: Features: Combined Optimizations</p> Notes <p>Combines multiple optimizations:   1. Edge predicate (since &gt; 2010) pushed into CTE base and recursive cases   2. Sink filter (age &gt; 60) pushed into recursive join</p> <p>USE CASE: Find chains of recent connections ending at seniors. Only explores paths where EVERY connection was made after 2010.</p> <p>SQL Pattern:   Base case: WHERE (e.since) &gt; (2010)   Recursive: WHERE depth &lt; 5 AND (e.since) &gt; (2010)   Join: WHERE depth_bounds AND (sink.age) &gt; (60)</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*2..5]-&gt;(b:Person)\nWHERE b.age &gt; 60\n  AND ALL(k IN relationships(path) WHERE k.since &gt; 2010)\nRETURN a.id, b.id, LENGTH(path) AS hops\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n    WHERE (e.since) &gt; (2010)\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 5\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n      AND (e.since) &gt; (2010)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 2 AND p.depth &lt;= 5 AND (sink.age) &gt; (60)\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*2..5, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#32-undirected-both-filters-pushdown-split-and-to-both-sources","title":"32. Undirected both filters pushdown - split AND to both sources","text":"<p>Application: Features: Conjunction Splitting Pushdown</p> Notes <p>BEFORE optimization (suboptimal):   Selection(p.name='Alice' AND f.age&gt;30) sits AFTER the join   \u2192 Joins ALL Person rows, then filters.</p> <p>AFTER optimization (with conjunction splitting):   - p.name = 'Alice' \u2192 pushed to DataSource(p)   - f.age &gt; 30 \u2192 pushed to DataSource(f)   \u2192 Both filters applied BEFORE the join!</p> <p>SQL Pattern (optimized):   FROM (SELECT ... FROM Person WHERE name = 'Alice') AS _left   JOIN ...   JOIN (SELECT ... FROM Person WHERE age &gt; 30) AS _right</p> <p>PERFORMANCE: Dramatically reduces join cardinality.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice' AND f.age &gt; 30\nRETURN p.name, f.name, f.age\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\n  ,_gsql2rsql_f_age AS age\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) &gt; (30))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age GT 30)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name, age=f.age\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#33-undirected-partial-pushdown-one-pushed-one-cross-variable","title":"33. Undirected partial pushdown - one pushed, one cross-variable","text":"<p>Application: Features: Partial Conjunction Pushdown</p> Notes <p>The optimizer splits the AND conjunction:   - p.age &gt; 25 \u2192 PUSHED to DataSource(p) (single-variable)   - p.name = f.name \u2192 KEPT in Selection (cross-variable, cannot push!)</p> <p>BENEFIT: Even partial pushdown reduces join input size. The cross-variable predicate (p.name = f.name) must be evaluated after the join because it compares values from both sides.</p> <p>SQL Pattern:   FROM (SELECT ... FROM Person WHERE age &gt; 25) AS _left  -- PUSHED   JOIN ...   WHERE p.name = f.name  -- KEPT (cross-variable)</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.age &gt; 25 AND p.name = f.name\nRETURN p.name, f.name\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,age AS _gsql2rsql_p_age\n      FROM\n        catalog.demo.Person\n      WHERE ((age) &gt; (25))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nWHERE (_gsql2rsql_p_name) = (_gsql2rsql_f_name)\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.age GT 25)\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n    Filter: (p.name EQ f.name)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#34-undirected-multiple-same-variable-predicates-combined","title":"34. Undirected multiple same-variable predicates combined","text":"<p>Application: Features: Predicate Combination</p> Notes <p>Multiple predicates for the same variable are combined with AND:   - p: (name='Bob' AND age&gt;18 AND active=true) \u2192 pushed to DataSource(p)   - f: (salary&gt;50000) \u2192 pushed to DataSource(f)</p> <p>OPTIMIZATION: All predicates pushed, SelectionOperator removed entirely!</p> <p>SQL Pattern:   FROM (SELECT ... FROM Person WHERE name='Bob' AND age&gt;18 AND active=true) AS _left   JOIN ...   JOIN (SELECT ... FROM Person WHERE salary &gt; 50000) AS _right</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Bob' AND p.age &gt; 18 AND p.active = true AND f.salary &gt; 50000\nRETURN p.id, f.id\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_id AS id\n  ,_gsql2rsql_f_id AS id\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql_p_active AS _gsql2rsql_p_active\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_salary AS _gsql2rsql_f_salary\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_left_1._gsql2rsql_p_active AS _gsql2rsql_p_active\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,age AS _gsql2rsql_p_age\n        ,active AS _gsql2rsql_p_active\n      FROM\n        catalog.demo.Person\n      WHERE ((((name) = ('Bob')) AND ((age) &gt; (18))) AND ((active) = (TRUE)))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,salary AS _gsql2rsql_f_salary\n    FROM\n      catalog.demo.Person\n    WHERE ((salary) &gt; (50000))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (((p.name EQ 'Bob') AND (p.age GT 18)) AND (p.active EQ true))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.salary GT 50000)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: id=p.id, id=f.id\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#35-undirected-with-or-predicate-cannot-split","title":"35. Undirected with OR predicate - cannot split","text":"<p>Application: Features: OR Predicate Handling</p> Notes <p>OR predicates CANNOT be split! This is algebraically unsafe:   \u03c3_{p(A) \u2228 q(B)}(A \u22c8 B) \u2262 \u03c3_{p(A)}(A) \u22c8 \u03c3_{q(B)}(B)</p> <p>If we pushed, we'd miss rows where:   - p.name != 'Alice' but f.age &gt; 30</p> <p>RESULT: Entire predicate stays in Selection (no pushdown).</p> <p>TODO: Future optimization could rewrite as UNION:   (MATCH ... WHERE p.name='Alice')   UNION   (MATCH ... WHERE f.age &gt; 30)</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)\nWHERE p.name = 'Alice' OR f.age &gt; 30\nRETURN p.name, f.name\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n      UNION ALL\n      SELECT\n         friend_id AS _gsql2rsql__anon1_person_id\n        ,person_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n        ,strength AS _gsql2rsql__anon1_strength\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nWHERE ((_gsql2rsql_p_name) = ('Alice')) OR ((_gsql2rsql_f_age) &gt; (30))\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n    Filter: ((p.name EQ 'Alice') OR (f.age GT 30))\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#36-undirected-three-way-mixed-filters","title":"36. Undirected three-way mixed filters","text":"<p>Application: Features: Complex Conjunction Splitting</p> Notes <p>Three-way join with filters on all three entities:   - p.age &gt; 25 \u2192 pushed to DataSource(p)   - f.salary &gt; 50000 \u2192 pushed to DataSource(f)   - c.industry = 'Tech' \u2192 pushed to DataSource\u00a9</p> <p>BENEFIT: All three table scans are filtered before any joins! The SelectionOperator is completely removed.</p> <p>SQL Pattern:   FROM (SELECT ... FROM Person WHERE age &gt; 25) AS p   JOIN ...   JOIN (SELECT ... FROM Person WHERE salary &gt; 50000) AS f   JOIN ...   JOIN (SELECT ... FROM Company WHERE industry = 'Tech') AS c</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-(f:Person)-[:WORKS_AT]-&gt;(c:Company)\nWHERE p.age &gt; 25 AND f.salary &gt; 50000 AND c.industry = 'Tech'\nRETURN p.name, f.name, c.name\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\n  ,_gsql2rsql_c_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_left_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_left_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_left_0._gsql2rsql_f_salary AS _gsql2rsql_f_salary\n    ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n    ,_left_0._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_right_0._gsql2rsql_c_industry AS _gsql2rsql_c_industry\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_left_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      ,_left_1._gsql2rsql_f_id AS _gsql2rsql_f_id\n      ,_left_1._gsql2rsql_f_name AS _gsql2rsql_f_name\n      ,_left_1._gsql2rsql_f_salary AS _gsql2rsql_f_salary\n      ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_right_1._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_2._gsql2rsql_p_name AS _gsql2rsql_p_name\n        ,_left_2._gsql2rsql_p_age AS _gsql2rsql_p_age\n        ,_left_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_left_2._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n        ,_right_2._gsql2rsql_f_id AS _gsql2rsql_f_id\n        ,_right_2._gsql2rsql_f_name AS _gsql2rsql_f_name\n        ,_right_2._gsql2rsql_f_salary AS _gsql2rsql_f_salary\n      FROM (\n        SELECT\n           _left_3._gsql2rsql_p_id AS _gsql2rsql_p_id\n          ,_left_3._gsql2rsql_p_name AS _gsql2rsql_p_name\n          ,_left_3._gsql2rsql_p_age AS _gsql2rsql_p_age\n          ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n          ,_right_3._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_p_id\n            ,name AS _gsql2rsql_p_name\n            ,age AS _gsql2rsql_p_age\n          FROM\n            catalog.demo.Person\n          WHERE ((age) &gt; (25))\n        ) AS _left_3\n        INNER JOIN (\n          SELECT\n             person_id AS _gsql2rsql__anon1_person_id\n            ,friend_id AS _gsql2rsql__anon1_friend_id\n            ,since AS _gsql2rsql__anon1_since\n            ,strength AS _gsql2rsql__anon1_strength\n          FROM\n            catalog.demo.Knows\n          UNION ALL\n          SELECT\n             friend_id AS _gsql2rsql__anon1_person_id\n            ,person_id AS _gsql2rsql__anon1_friend_id\n            ,since AS _gsql2rsql__anon1_since\n            ,strength AS _gsql2rsql__anon1_strength\n          FROM\n            catalog.demo.Knows\n        ) AS _right_3 ON\n          _left_3._gsql2rsql_p_id = _right_3._gsql2rsql__anon1_person_id\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_f_id\n          ,name AS _gsql2rsql_f_name\n          ,salary AS _gsql2rsql_f_salary\n        FROM\n          catalog.demo.Person\n        WHERE ((salary) &gt; (50000))\n      ) AS _right_2 ON\n        _right_2._gsql2rsql_f_id = _left_2._gsql2rsql__anon1_friend_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon2_person_id\n        ,company_id AS _gsql2rsql__anon2_company_id\n      FROM\n        catalog.demo.WorksAt\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_f_id = _right_1._gsql2rsql__anon2_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n      ,name AS _gsql2rsql_c_name\n      ,industry AS _gsql2rsql_c_industry\n    FROM\n      catalog.demo.Company\n    WHERE ((industry) = ('Tech'))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon2_company_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.age GT 25)\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.salary GT 50000)\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:WORKS_AT]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: c:Company\n    Filter: (c.industry EQ 'Tech')\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=EITHER_AS_SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=EITHER_AS_SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: name=p.name, name=f.name, name=c.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#37-variable-length-paths-with-multi-hop-traversal-and-aggregation","title":"37. Variable-length paths with multi-hop traversal and aggregation","text":"<p>Application: Features: Complex graph traversal with aggregation</p> Notes <p>This query demonstrates a powerful combination of features:   1. Variable-length path: KNOWS*1..3 (1 to 3 hops)   2. Pattern continuation after varlen path   3. Filter on final relationship target   4. Aggregation with COUNT(DISTINCT)   5. Ordering by aggregated column</p> <p>REAL-WORLD USE: Find people with the most connections to tech workers. Used in professional networking, talent acquisition, and social graph analysis.</p> <p>OPTIMIZATION: Filter on c.industry pushed down before joins.</p> <p>COMPLEXITY: O(n^3) for 3-hop traversal, but filtered early. Result deduplication via DISTINCT crucial for accurate counts.</p> <p>SQL Pattern:   WITH RECURSIVE path AS (...)  -- Variable-length expansion   SELECT p.name, COUNT(DISTINCT friend_id) AS tech_connections   FROM path   JOIN WorksAt ON ...   JOIN (SELECT ... FROM Company WHERE industry = 'Technology') AS c   GROUP BY p.name   ORDER BY tech_connections DESC   LIMIT 10</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS*1..3]-(friend:Person)-[:WORKS_AT]-&gt;(c:Company)\nWHERE c.industry = 'Technology'\nRETURN p.name, COUNT(DISTINCT friend) AS tech_connections\nORDER BY tech_connections DESC\nLIMIT 10\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT * FROM (\n    -- Forward direction\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n      UNION ALL\n\n    -- Backward direction\n    SELECT\n      e.friend_id AS start_node,\n      e.person_id AS end_node,\n      1 AS depth,\n      ARRAY(e.friend_id, e.person_id) AS path,\n      ARRAY(e.friend_id) AS visited\n    FROM catalog.demo.Knows e\n    )\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT * FROM (\n    -- Forward direction\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n\n      UNION ALL\n\n    -- Backward direction\n    SELECT\n      p.start_node,\n      e.person_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.person_id)) AS path,\n      CONCAT(p.visited, ARRAY(e.friend_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.friend_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.person_id)\n    )\n  )\nSELECT \n   _gsql2rsql_p_name AS name\n  ,COUNT(DISTINCT _gsql2rsql_friend_id) AS tech_connections\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_friend_id AS _gsql2rsql_friend_id\n    ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n    ,_left_0._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right_0._gsql2rsql_c_industry AS _gsql2rsql_c_industry\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_friend_id AS _gsql2rsql_friend_id\n      ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_right_1._gsql2rsql__anon2_company_id AS _gsql2rsql__anon2_company_id\n    FROM (\n      SELECT\n         sink.id AS _gsql2rsql_friend_id\n        ,sink.name AS _gsql2rsql_friend_name\n        ,sink.age AS _gsql2rsql_friend_age\n        ,sink.nickname AS _gsql2rsql_friend_nickname\n        ,sink.salary AS _gsql2rsql_friend_salary\n        ,sink.active AS _gsql2rsql_friend_active\n        ,source.id AS _gsql2rsql_p_id\n        ,source.name AS _gsql2rsql_p_name\n        ,source.age AS _gsql2rsql_p_age\n        ,source.nickname AS _gsql2rsql_p_nickname\n        ,source.salary AS _gsql2rsql_p_salary\n        ,source.active AS _gsql2rsql_p_active\n        ,p.start_node\n        ,p.end_node\n        ,p.depth\n        ,p.path\n      FROM paths_1 p\n      JOIN catalog.demo.Person sink\n        ON sink.id = p.end_node\n      JOIN catalog.demo.Person source\n        ON source.id = p.start_node\n      WHERE p.depth &gt;= 1 AND p.depth &lt;= 3\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon2_person_id\n        ,company_id AS _gsql2rsql__anon2_company_id\n      FROM\n        catalog.demo.WorksAt\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_friend_id = _right_1._gsql2rsql__anon2_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n      ,industry AS _gsql2rsql_c_industry\n    FROM\n      catalog.demo.Company\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon2_company_id\n) AS _proj\nWHERE (_gsql2rsql_c_industry) = ('Technology')\nGROUP BY _gsql2rsql_p_name\nORDER BY tech_connections DESC\nLIMIT 10\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: friend:Person\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=5)\n    DataSource: [_anon2:WORKS_AT]-&gt;\n*\nOpId=7 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=7)\n    DataSource: c:Company\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..3, direction=BOTH)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=6;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=friend RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=4,5; OutOpIds=8;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=friend RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=6,7; OutOpIds=10;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=ProjectionOperator; InOpIds=8; OutOpIds=;\n  ProjectionOperator(id=10)\n    Projections: name=p.name, tech_connections=COUNT(DISTINCT friend)\n    Filter: (c.industry EQ 'Technology')\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#38-inline-property-filter-on-source-node","title":"38. Inline property filter on source node","text":"<p>Application: Features: Inline filters (source node)</p> Notes <p>Inline property filter {name: 'Alice'} applied on source node.</p> <p>EQUIVALENT TO:   MATCH (p:Person)-[:KNOWS]-&gt;(f:Person)   WHERE p.name = 'Alice'   RETURN p.name, f.name</p> <p>SYNTAX: More compact and readable - filter is part of the pattern.</p> <p>SQL PATTERN:   FROM (SELECT ... FROM Person WHERE name = 'Alice') AS p   JOIN Knows ON p.id = person_id   JOIN Person AS f ON f.id = friend_id</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person {name: 'Alice'})-[:KNOWS]-&gt;(f:Person)\nRETURN p.name, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#39-inline-property-filter-on-target-node","title":"39. Inline property filter on target node","text":"<p>Application: Features: Inline filters (target node)</p> Notes <p>Inline property filter {age: 30} applied on target node.</p> <p>FILTER POSITION: Applied on right-hand side of the pattern.</p> <p>SQL PATTERN:   FROM Person AS p   JOIN Knows ON p.id = person_id   JOIN (SELECT ... FROM Person WHERE age = 30) AS f ON f.id = friend_id</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-&gt;(f:Person {age: 30})\nRETURN p.name, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) = (30))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age EQ 30)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#40-inline-property-filter-on-relationship","title":"40. Inline property filter on relationship","text":"<p>Application: Features: Inline filters (relationship)</p> Notes <p>Inline property filter {since: 2020} applied on relationship.</p> <p>USE CASE: Filter edges by their properties (timestamps, weights, etc).</p> <p>SQL PATTERN:   FROM Person AS p   JOIN (SELECT ... FROM Knows WHERE since = 2020) AS e ON p.id = e.person_id   JOIN Person AS f ON f.id = e.friend_id</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS {since: 2020}]-&gt;(f:Person)\nRETURN p.name, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_left_0._gsql2rsql__anon1_since AS _gsql2rsql__anon1_since\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      ,_right_1._gsql2rsql__anon1_since AS _gsql2rsql__anon1_since\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n      FROM\n        catalog.demo.Knows\n      WHERE ((since) = (2020))\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n    Filter: (_anon1.since EQ 2020)\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#41-multiple-inline-property-filters-on-same-element","title":"41. Multiple inline property filters on same element","text":"<p>Application: Features: Multiple inline filters</p> Notes <p>Multiple inline properties combined with AND automatically.</p> <p>EQUIVALENT TO:   WHERE p.name = 'Alice' AND p.age = 30 AND p.active = true</p> <p>READABILITY: All filters for one element are grouped together.</p> <p>SQL PATTERN:   FROM (     SELECT ... FROM Person     WHERE name = 'Alice' AND age = 30 AND active = true   ) AS p</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person {name: 'Alice', age: 30, active: true})-[:KNOWS]-&gt;(f:Person)\nRETURN p.name, p.age, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_p_age AS age\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql_p_age AS _gsql2rsql_p_age\n    ,_left_0._gsql2rsql_p_active AS _gsql2rsql_p_active\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_left_1._gsql2rsql_p_age AS _gsql2rsql_p_age\n      ,_left_1._gsql2rsql_p_active AS _gsql2rsql_p_active\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n        ,age AS _gsql2rsql_p_age\n        ,active AS _gsql2rsql_p_active\n      FROM\n        catalog.demo.Person\n      WHERE ((((name) = ('Alice')) AND ((age) = (30))) AND ((active) = (TRUE)))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (((p.name EQ 'Alice') AND (p.age EQ 30)) AND (p.active EQ true))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, age=p.age, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#42-combined-inline-filters-source-target-and-relationship","title":"42. Combined inline filters - source, target, and relationship","text":"<p>Application: Features: Inline filters (combined)</p> Notes <p>Inline filters on ALL three elements: source, relationship, target.</p> <p>EQUIVALENT TO:   WHERE p.name = 'Alice' AND r.since = 2020 AND f.age = 30</p> <p>READABILITY BENEFIT: Filters are positioned next to the elements they constrain.</p> <p>SQL PATTERN:   FROM (SELECT ... FROM Person WHERE name = 'Alice') AS p   JOIN (SELECT ... FROM Knows WHERE since = 2020) AS e ON ...   JOIN (SELECT ... FROM Person WHERE age = 30) AS f ON ...</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person {name: 'Alice'})-[:KNOWS {since: 2020}]-&gt;(f:Person {age: 30})\nRETURN p.name, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_left_0._gsql2rsql__anon1_since AS _gsql2rsql__anon1_since\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      ,_right_1._gsql2rsql__anon1_since AS _gsql2rsql__anon1_since\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n        ,since AS _gsql2rsql__anon1_since\n      FROM\n        catalog.demo.Knows\n      WHERE ((since) = (2020))\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) = (30))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n    Filter: (_anon1.since EQ 2020)\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age EQ 30)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#43-inline-filter-combined-with-explicit-where-clause","title":"43. Inline filter combined with explicit WHERE clause","text":"<p>Application: Features: Inline + WHERE</p> Notes <p>Inline filters can be combined with explicit WHERE clause.</p> <p>COMBINED AS: (p.name = 'Alice') AND (f.age &gt; 25)</p> <p>BEST PRACTICE:   - Use inline for equality filters (property = value)   - Use WHERE for complex predicates (&gt;, &lt;, BETWEEN, etc.)</p> <p>SQL PATTERN:   FROM (SELECT ... FROM Person WHERE name = 'Alice') AS p   JOIN Knows ON ...   JOIN Person AS f ON ...   WHERE f.age &gt; 25</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person {name: 'Alice'})-[:KNOWS]-&gt;(f:Person)\nWHERE f.age &gt; 25\nRETURN p.name, f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n    ,_right_0._gsql2rsql_f_age AS _gsql2rsql_f_age\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n      ,age AS _gsql2rsql_f_age\n    FROM\n      catalog.demo.Person\n    WHERE ((age) &gt; (25))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n    Filter: (f.age GT 25)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=p.name, name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#44-bfs-with-inline-source-filter-critical-optimization","title":"44. BFS with inline source filter (CRITICAL OPTIMIZATION)","text":"<p>Application: Features: Inline filters (BFS optimization)</p> Notes <p>CRITICAL OPTIMIZATION for variable-length paths!</p> <p>Inline filter on SOURCE node {name: 'Alice'} is pushed to the BASE CASE of the recursive CTE, so BFS starts ONLY from Alice, not from all nodes in the graph.</p> <p>PERFORMANCE IMPACT:   - Without filter: O(N * E^k) - starts from ALL N nodes   - With inline filter: O(1 * E^k) - starts from 1 node only   - For large graphs, this is the difference between seconds and hours!</p> <p>EQUIVALENT TO:   MATCH path = (a:Person)-[:KNOWS*1..3]-&gt;(b:Person)   WHERE a.name = 'Alice'</p> <p>SQL PATTERN:   WITH RECURSIVE bfs AS (     -- BASE CASE: Filter applied HERE (before traversal)     SELECT e.src, e.dst, 1 AS depth     FROM Knows e     JOIN Person src ON src.id = e.src     WHERE (src.name) = ('Alice')  \u2190 INLINE FILTER OPTIMIZATION</p> Text Only<pre><code>UNION ALL\n\n-- RECURSIVE CASE: No source filter (only depth check)\nSELECT e.src, e.dst, depth + 1\nFROM bfs b\nJOIN Knows e ON b.dst = e.src\nWHERE depth &lt; 3\n</code></pre> <p>)</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person {name: 'Alice'})-[:KNOWS*1..3]-&gt;(b:Person)\nRETURN b.name, length(path) AS hops\nORDER BY hops\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n    JOIN catalog.demo.Person src ON src.id = e.person_id\n    WHERE (src.name) = ('Alice')\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_b_name AS name\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 3\n) AS _proj\nORDER BY hops ASC\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..3, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: name=b.name, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#45-bfs-with-inline-filter-on-target-node","title":"45. BFS with inline filter on target node","text":"<p>Application: Features: Inline filters (target in BFS)</p> Notes <p>Inline filter on TARGET node {active: true} is applied AFTER traversal.</p> <p>DIFFERENCE FROM SOURCE FILTER:   - Source filter: Applied in BASE CASE (optimizes starting point)   - Target filter: Applied in FINAL WHERE (filters results)</p> <p>BFS BEHAVIOR:   1. Traverse graph from ALL source nodes (no starting point filter)   2. Follow KNOWS edges for 1-3 hops   3. Filter final results where b.active = true</p> <p>SQL PATTERN:   WITH RECURSIVE bfs AS (...)  -- Full traversal   SELECT a.name, b.name, depth AS hops   FROM bfs   JOIN Person b ON b.id = bfs.dst   WHERE (b.active) = (true)  \u2190 TARGET FILTER (post-traversal)</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*1..3]-&gt;(b:Person {active: true})\nRETURN a.name, b.name, length(path) AS hops\nORDER BY hops\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 3\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_name AS name\n  ,_gsql2rsql_b_name AS name\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 3 AND (sink.active) = (TRUE)\n) AS _proj\nORDER BY hops ASC\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..3, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: name=a.name, name=b.name, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#46-anonymous-node-with-inline-filter","title":"46. Anonymous node with inline filter","text":"<p>Application: Features: Inline filters (anonymous nodes)</p> Notes <p>Inline filters work on anonymous nodes (nodes without variables).</p> <p>USE CASE: Filter starting/ending nodes that aren't returned.</p> <p>TRANSPILER HANDLING:   1. Auto-assign alias: (:Person {name: 'Alice'}) \u2192 (_anon1:Person)   2. Convert filter: _anon1.name = 'Alice'   3. Push to DataSource</p> <p>SQL PATTERN:   FROM (SELECT ... FROM Person WHERE name = 'Alice') AS _anon1   JOIN Knows ON _anon1.id = person_id   JOIN Person AS f ON f.id = friend_id</p> OpenCypher Query Cypher<pre><code>MATCH (:Person {name: 'Alice'})-[:KNOWS]-&gt;(f:Person)\nRETURN f.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_f_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql__anon1_id AS _gsql2rsql__anon1_id\n    ,_left_0._gsql2rsql__anon1_name AS _gsql2rsql__anon1_name\n    ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n    ,_left_0._gsql2rsql__anon2_friend_id AS _gsql2rsql__anon2_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n    ,_right_0._gsql2rsql_f_name AS _gsql2rsql_f_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql__anon1_id AS _gsql2rsql__anon1_id\n      ,_left_1._gsql2rsql__anon1_name AS _gsql2rsql__anon1_name\n      ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_right_1._gsql2rsql__anon2_friend_id AS _gsql2rsql__anon2_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql__anon1_id\n        ,name AS _gsql2rsql__anon1_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon2_person_id\n        ,friend_id AS _gsql2rsql__anon2_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql__anon1_id = _right_1._gsql2rsql__anon2_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n      ,name AS _gsql2rsql_f_name\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon2_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: _anon1:Person\n    Filter: (_anon1.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon2:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=_anon1 RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: name=f.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#47-inline-filter-comparison-with-where-semantics","title":"47. Inline filter comparison with WHERE (semantics)","text":"<p>Application: Features: Inline vs WHERE semantics</p> Notes <p>SEMANTIC EQUIVALENCE: Inline filters generate identical SQL to WHERE.</p> <p>COMPARE WITH:   MATCH (p:Person)-[:KNOWS]-&gt;(f:Person)   WHERE p.name = 'Alice'   RETURN COUNT(*)</p> <p>Both queries produce the SAME SQL and SAME results.</p> <p>WHEN TO USE INLINE:   \u2705 Equality filters (property = literal_value)   \u2705 Structural constraints (part of the pattern)   \u2705 BFS/DFS source filters (visual clarity of optimization)</p> <p>WHEN TO USE WHERE:   \u2705 Complex predicates (&gt;, &lt;, BETWEEN, LIKE, IN)   \u2705 Cross-variable filters (p.age &gt; f.age)   \u2705 Dynamic values (property = $parameter)</p> <p>CURRENT LIMITATION:   \u26a0\ufe0f  Inline filters only support LITERAL values   \u26a0\ufe0f  Variable references not supported yet       Example that doesn't work: {id: $param}</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person {name: 'Alice'})-[:KNOWS]-&gt;(f:Person)\nRETURN COUNT(*) AS count_inline\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   COUNT(*) AS count_inline\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_f_id AS _gsql2rsql_f_id\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n      WHERE ((name) = ('Alice'))\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_f_id\n    FROM\n      catalog.demo.Person\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_f_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n    Filter: (p.name EQ 'Alice')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: f:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=f RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: count_inline=COUNT(*)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#48-no-label-source-node-without-label","title":"48. NO LABEL: Source node without label","text":"<p>Application: Features: No-label source node</p> Notes <p>Source node 'a' has no label - matches ANY node type.</p> <p>OPENCYPHER STANDARD: Unlabeled nodes match all node types.</p> <p>SQL PATTERN:   FROM nodes AS a  -- NO type filter for 'a'   JOIN edges ON a.id = edges.src   JOIN (SELECT ... FROM Company) AS c ON edges.dst = c.id   WHERE edges.relationship_type = 'WORKS_AT'</p> <p>USE CASE: Find all entities that work at companies (could be Person, Bot, etc).</p> <p>PERFORMANCE: Full table scan on source. Use labels when possible for filtering.</p> OpenCypher Query Cypher<pre><code>MATCH (a)-[:WORKS_AT]-&gt;(c:Company)\nRETURN a.name, c.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_name AS name\n  ,_gsql2rsql_c_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_left_0._gsql2rsql_a_name AS _gsql2rsql_a_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_company_id AS _gsql2rsql__anon1_company_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_1._gsql2rsql_a_name AS _gsql2rsql_a_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_company_id AS _gsql2rsql__anon1_company_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_a_id\n        ,name AS _gsql2rsql_a_name\n      FROM\n        catalog.demo.AllNodes\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,company_id AS _gsql2rsql__anon1_company_id\n      FROM\n        catalog.demo.WorksAt\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n      ,name AS _gsql2rsql_c_name\n    FROM\n      catalog.demo.Company\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_company_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:WORKS_AT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:Company\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: name=a.name, name=c.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#49-no-label-target-node-without-label","title":"49. NO LABEL: Target node without label","text":"<p>Application: Features: No-label target node</p> Notes <p>Target node 'target' has no label - matches ANY node type.</p> <p>USE CASE: Find all connections of a person regardless of type.</p> <p>SQL PATTERN:   FROM (SELECT ... FROM Person) AS p   JOIN edges ON p.id = edges.src   JOIN nodes AS target ON edges.dst = target.id  -- NO type filter   WHERE edges.relationship_type = 'KNOWS'</p> <p>BENEFIT: Explore graph structure without knowing all node types.</p> OpenCypher Query Cypher<pre><code>MATCH (p:Person)-[:KNOWS]-&gt;(target)\nRETURN p.name, target.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_name AS name\n  ,_gsql2rsql_target_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,_left_0._gsql2rsql_p_name AS _gsql2rsql_p_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_target_id AS _gsql2rsql_target_id\n    ,_right_0._gsql2rsql_target_name AS _gsql2rsql_target_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_1._gsql2rsql_p_name AS _gsql2rsql_p_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_p_id\n        ,name AS _gsql2rsql_p_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_target_id\n      ,name AS _gsql2rsql_target_name\n    FROM\n      catalog.demo.AllNodes\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_target_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: target:\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=target RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: name=p.name, name=target.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#50-no-label-both-endpoints-without-labels","title":"50. NO LABEL: Both endpoints without labels","text":"<p>Application: Features: No-label both nodes</p> Notes <p>Both nodes 'a' and 'b' have no labels - match ANY node types.</p> <p>SQL PATTERN:   FROM nodes AS a   JOIN edges ON a.id = edges.src   JOIN nodes AS b ON edges.dst = b.id   WHERE edges.relationship_type = 'KNOWS'</p> <p>USE CASE: Explore all KNOWS relationships regardless of node types.</p> <p>WARNING: Can be expensive on large graphs - no type filtering applied!</p> OpenCypher Query Cypher<pre><code>MATCH (a)-[:KNOWS]-&gt;(b)\nRETURN a.name, b.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_name AS name\n  ,_gsql2rsql_b_name AS name\nFROM (\n  SELECT\n     _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_left_0._gsql2rsql_a_name AS _gsql2rsql_a_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_0._gsql2rsql_b_id AS _gsql2rsql_b_id\n    ,_right_0._gsql2rsql_b_name AS _gsql2rsql_b_name\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_1._gsql2rsql_a_name AS _gsql2rsql_a_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_a_id\n        ,name AS _gsql2rsql_a_name\n      FROM\n        catalog.demo.AllNodes\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,friend_id AS _gsql2rsql__anon1_friend_id\n      FROM\n        catalog.demo.Knows\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_b_id\n      ,name AS _gsql2rsql_b_name\n    FROM\n      catalog.demo.AllNodes\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_b_id = _left_0._gsql2rsql__anon1_friend_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: b:\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: name=a.name, name=b.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#51-no-label-variable-length-path-without-labels","title":"51. NO LABEL: Variable-length path without labels","text":"<p>Application: Features: No-label VLP</p> Notes <p>Variable-length path where both endpoints have no labels.</p> <p>SQL PATTERN (WITH RECURSIVE):   WITH RECURSIVE paths AS (     -- Base case: no type filters on source     UNION ALL     -- Recursive case: traverses any matching edge   )   SELECT ... FROM paths   JOIN nodes AS a ON ...  -- No type filter   JOIN nodes AS b ON ...  -- No type filter</p> <p>USE CASE: Generic graph traversal - find all paths of any type.</p> <p>COMPLEXITY: O(k^d) where k=avg degree, d=max depth WARNING: Expensive without labels. Use sparingly on large graphs.</p> OpenCypher Query Cypher<pre><code>MATCH path = (a)-[:KNOWS*1..2]-&gt;(b)\nRETURN a.id, b.id, length(path) AS hops\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,sink.population AS _gsql2rsql_b_population\n    ,sink.country AS _gsql2rsql_b_country\n    ,sink.title AS _gsql2rsql_b_title\n    ,sink.year AS _gsql2rsql_b_year\n    ,sink.genre AS _gsql2rsql_b_genre\n    ,sink.rating AS _gsql2rsql_b_rating\n    ,sink.industry AS _gsql2rsql_b_industry\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,source.population AS _gsql2rsql_a_population\n    ,source.country AS _gsql2rsql_a_country\n    ,source.title AS _gsql2rsql_a_title\n    ,source.year AS _gsql2rsql_a_year\n    ,source.genre AS _gsql2rsql_a_genre\n    ,source.rating AS _gsql2rsql_a_rating\n    ,source.industry AS _gsql2rsql_a_industry\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.AllNodes sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.AllNodes source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 2\n) AS _proj\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..2, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#52-no-label-vlp-with-labeled-source-unlabeled-target","title":"52. NO LABEL: VLP with labeled source, unlabeled target","text":"<p>Application: Features: No-label VLP (partial)</p> Notes <p>Variable-length path: source has label, target has no label.</p> <p>SOURCE FILTER: a:Person adds WHERE node_type = 'Person' to base case TARGET: No filter applied - matches any node type</p> <p>SQL PATTERN:   WITH RECURSIVE paths AS (     -- Base case: source filter applied     SELECT ... FROM edges     JOIN (SELECT ... FROM Person) AS src ON ...     WHERE ...</p> Text Only<pre><code>UNION ALL\n...\n</code></pre> <p>)   SELECT ... FROM paths   JOIN nodes AS b ON ...  -- No type filter for target</p> <p>USE CASE: \"Find everything a Person can reach via KNOWS relationships\"</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Person)-[:KNOWS*1..2]-&gt;(b)\nRETURN a.name, b.id, length(path) AS hops\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_name AS name\n  ,_gsql2rsql_b_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,sink.population AS _gsql2rsql_b_population\n    ,sink.country AS _gsql2rsql_b_country\n    ,sink.title AS _gsql2rsql_b_title\n    ,sink.year AS _gsql2rsql_b_year\n    ,sink.genre AS _gsql2rsql_b_genre\n    ,sink.rating AS _gsql2rsql_b_rating\n    ,sink.industry AS _gsql2rsql_b_industry\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.AllNodes sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.Person source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 2\n) AS _proj\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..2, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: name=a.name, id=b.id, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#53-no-label-vlp-with-unlabeled-source-labeled-target","title":"53. NO LABEL: VLP with unlabeled source, labeled target","text":"<p>Application: Features: No-label VLP (reverse partial)</p> Notes <p>Variable-length path: source has no label, target has label.</p> <p>SOURCE: No filter - starts from any node type TARGET FILTER: b:Person applied in final join</p> <p>SQL PATTERN:   WITH RECURSIVE paths AS (     -- Base case: no source filter (all nodes)     UNION ALL     ...   )   SELECT ... FROM paths   JOIN (SELECT ... FROM Person) AS b ON ...  -- Target filter</p> <p>USE CASE: \"Find all paths ending at a Person, regardless of start\"</p> <p>NOTE: VLP type filter rendering for labeled nodes may be a pre-existing gap in some cases - but binding and SQL generation work correctly.</p> OpenCypher Query Cypher<pre><code>MATCH path = (a)-[:KNOWS*1..2]-&gt;(b:Person)\nRETURN a.id, b.name, length(path) AS hops\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.person_id AS start_node,\n      e.friend_id AS end_node,\n      1 AS depth,\n      ARRAY(e.person_id, e.friend_id) AS path,\n      ARRAY(NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      ARRAY(e.person_id) AS visited\n    FROM catalog.demo.Knows e\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.friend_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.friend_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('person_id', e.person_id, 'friend_id', e.friend_id, 'since', e.since, 'strength', e.strength)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.person_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.demo.Knows e\n      ON p.end_node = e.person_id\n    WHERE p.depth &lt; 2\n      AND NOT ARRAY_CONTAINS(p.visited, e.friend_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_name AS name\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.name AS _gsql2rsql_b_name\n    ,sink.age AS _gsql2rsql_b_age\n    ,sink.nickname AS _gsql2rsql_b_nickname\n    ,sink.salary AS _gsql2rsql_b_salary\n    ,sink.active AS _gsql2rsql_b_active\n    ,source.id AS _gsql2rsql_a_id\n    ,source.name AS _gsql2rsql_a_name\n    ,source.age AS _gsql2rsql_a_age\n    ,source.nickname AS _gsql2rsql_a_nickname\n    ,source.salary AS _gsql2rsql_a_salary\n    ,source.active AS _gsql2rsql_a_active\n    ,source.population AS _gsql2rsql_a_population\n    ,source.country AS _gsql2rsql_a_country\n    ,source.title AS _gsql2rsql_a_title\n    ,source.year AS _gsql2rsql_a_year\n    ,source.genre AS _gsql2rsql_a_genre\n    ,source.rating AS _gsql2rsql_a_rating\n    ,source.industry AS _gsql2rsql_a_industry\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.demo.Person sink\n    ON sink.id = p.end_node\n  JOIN catalog.demo.AllNodes source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 1 AND p.depth &lt;= 2\n) AS _proj\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(KNOWS*1..2, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, name=b.name, hops=LENGTH(path)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/features/#54-no-label-node-reused-after-with-type-already-bound","title":"54. NO LABEL: Node reused after WITH (type already bound)","text":"<p>Application: Features: No-label after WITH</p> Notes <p>Node 'a' has no label in second MATCH, but type was already bound in first MATCH.</p> <p>BEHAVIOR:   - First MATCH: 'a' is bound to Person (label specified)   - WITH: 'a' is passed through with its type   - Second MATCH: 'a' reuses existing binding (no label needed)</p> <p>SQL PATTERN:   WITH first_match AS (     SELECT a.*, COUNT(c.id) AS company_count     FROM Person AS a     JOIN ... Company AS c     GROUP BY a.id   )   SELECT ... FROM first_match   JOIN edges ON ...   JOIN Person AS friend ON ...</p> <p>USE CASE: Multi-stage queries where type is established early.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Person)-[:WORKS_AT]-&gt;(c:Company)\nWITH a, COUNT(c) AS company_count\nMATCH (a)-[:KNOWS]-&gt;(friend:Person)\nRETURN a.name, company_count, friend.name\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>WITH\nagg_boundary_1 AS (\n  SELECT\n    _gsql2rsql_a_id AS `a`,\n    COUNT(_gsql2rsql_c_id) AS `company_count`\n  FROM (\n  SELECT\n     _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_left_0._gsql2rsql_a_name AS _gsql2rsql_a_name\n    ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_left_0._gsql2rsql__anon1_company_id AS _gsql2rsql__anon1_company_id\n    ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_1._gsql2rsql_a_name AS _gsql2rsql_a_name\n      ,_right_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_right_1._gsql2rsql__anon1_company_id AS _gsql2rsql__anon1_company_id\n    FROM (\n      SELECT\n         id AS _gsql2rsql_a_id\n        ,name AS _gsql2rsql_a_name\n      FROM\n        catalog.demo.Person\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         person_id AS _gsql2rsql__anon1_person_id\n        ,company_id AS _gsql2rsql__anon1_company_id\n      FROM\n        catalog.demo.WorksAt\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_person_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_c_id\n    FROM\n      catalog.demo.Company\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon1_company_id\n  ) AS _agg_input\n  GROUP BY _gsql2rsql_a_id\n)\nSELECT \n   _gsql2rsql_a_name AS name\n  ,company_count AS company_count\n  ,_gsql2rsql_friend_name AS name\nFROM (\n  SELECT\n     _left_3.`a` AS `a`\n    ,_left_3.`company_count` AS `company_count`\n    ,_right_3._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n    ,_right_3._gsql2rsql_a_name AS _gsql2rsql_a_name\n    ,_right_3._gsql2rsql_friend_id AS _gsql2rsql_friend_id\n    ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n    ,_right_3._gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_right_3._gsql2rsql_friend_name AS _gsql2rsql_friend_name\n  FROM (\n    SELECT\n       `a`\n      ,`company_count`\n    FROM agg_boundary_1\n  ) AS _left_3\n  INNER JOIN (\n    SELECT\n       _left_4._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_4._gsql2rsql_a_name AS _gsql2rsql_a_name\n      ,_left_4._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_4._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      ,_right_4._gsql2rsql_friend_id AS _gsql2rsql_friend_id\n      ,_right_4._gsql2rsql_friend_name AS _gsql2rsql_friend_name\n    FROM (\n      SELECT\n         _left_5._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_5._gsql2rsql_a_name AS _gsql2rsql_a_name\n        ,_right_5._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_right_5._gsql2rsql__anon1_friend_id AS _gsql2rsql__anon1_friend_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_a_id\n          ,name AS _gsql2rsql_a_name\n        FROM\n          catalog.demo.Person\n      ) AS _left_5\n      INNER JOIN (\n        SELECT\n           person_id AS _gsql2rsql__anon1_person_id\n          ,friend_id AS _gsql2rsql__anon1_friend_id\n        FROM\n          catalog.demo.Knows\n      ) AS _right_5 ON\n        _left_5._gsql2rsql_a_id = _right_5._gsql2rsql__anon1_person_id\n    ) AS _left_4\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_friend_id\n        ,name AS _gsql2rsql_friend_name\n      FROM\n        catalog.demo.Person\n    ) AS _right_4 ON\n      _right_4._gsql2rsql_friend_id = _left_4._gsql2rsql__anon1_friend_id\n  ) AS _right_3 ON\n    _left_3.`a` = _right_3._gsql2rsql_a_id\n) AS _proj\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:WORKS_AT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: c:Company\n*\nOpId=7 Op=DataSourceOperator; InOpIds=; OutOpIds=10;\n  DataSourceOperator(id=7)\n    DataSource: a:Person\n*\nOpId=8 Op=DataSourceOperator; InOpIds=; OutOpIds=10;\n  DataSourceOperator(id=8)\n    DataSource: [_anon1:KNOWS]-&gt;\n*\nOpId=9 Op=DataSourceOperator; InOpIds=; OutOpIds=11;\n  DataSourceOperator(id=9)\n    DataSource: friend:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\nOpId=10 Op=JoinOperator; InOpIds=7,8; OutOpIds=11;\n  JoinOperator(id=10)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SINK\n*\nOpId=11 Op=JoinOperator; InOpIds=10,9; OutOpIds=12;\n  JoinOperator(id=11)\n    JoinType: INNER\n    Joins: JoinPair: Node=friend RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=AggregationBoundaryOperator; InOpIds=5; OutOpIds=12;\n  AggregationBoundaryOperator(id=6)\n    GroupBy: [a]\n    Aggregates: [company_count]\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=12 Op=JoinOperator; InOpIds=6,11; OutOpIds=13;\n  JoinOperator(id=12)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=agg_boundary_1 Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=13 Op=ProjectionOperator; InOpIds=12; OutOpIds=;\n  ProjectionOperator(id=13)\n    Projections: name=a.name, company_count=company_count, name=friend.name\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/","title":"Fraud Queries","text":"<p>This page contains transpiled examples for fraud queries queries.</p> <p>Disclaimer</p> <p>These examples were generated by Claude, and I believe Claude was overconfident about the usefulness of these queries. Therefore, these examples require further curation and validation, including the transpilation results. if you spot any issues, please open an issue or contribute at https://github.com/devmessias/gsql2rsql/issues</p> <p>Each example shows the original OpenCypher query and its corresponding Databricks SQL translation.</p>"},{"location":"examples/fraud/#1-detect-co-shopper-fraud-rings-via-shared-transaction-paths","title":"1. Detect co-shopper fraud rings via shared transaction paths","text":"<p>Application: Fraud: Co-shopper detection</p> Notes <p>Finds pairs of accounts that share transactions at the same merchant. High shared transaction counts may indicate coordinated fraud or account sharing.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:TRANSACTION]-&gt;(m:Merchant)&lt;-[:TRANSACTION]-(b:Account)\nWHERE a.id &lt;&gt; b.id\nRETURN a.id, b.id, m.name, COUNT(*) AS shared_transactions\nORDER BY shared_transactions DESC\nLIMIT 10\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,_gsql2rsql_m_name AS name\n  ,COUNT(*) AS shared_transactions\nFROM (\n  SELECT\n     _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n    ,_left_0._gsql2rsql__anon1_merchant_id AS _gsql2rsql__anon1_merchant_id\n    ,_left_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n    ,_left_0._gsql2rsql_m_name AS _gsql2rsql_m_name\n    ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n    ,_left_0._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n    ,_right_0._gsql2rsql_b_id AS _gsql2rsql_b_id\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_1._gsql2rsql__anon1_merchant_id AS _gsql2rsql__anon1_merchant_id\n      ,_left_1._gsql2rsql_m_id AS _gsql2rsql_m_id\n      ,_left_1._gsql2rsql_m_name AS _gsql2rsql_m_name\n      ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_right_1._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_2._gsql2rsql__anon1_merchant_id AS _gsql2rsql__anon1_merchant_id\n        ,_right_2._gsql2rsql_m_id AS _gsql2rsql_m_id\n        ,_right_2._gsql2rsql_m_name AS _gsql2rsql_m_name\n      FROM (\n        SELECT\n           _left_3._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_right_3._gsql2rsql__anon1_merchant_id AS _gsql2rsql__anon1_merchant_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_a_id\n          FROM\n            catalog.fraud.Account\n        ) AS _left_3\n        INNER JOIN (\n          SELECT\n             account_id AS _gsql2rsql__anon1_account_id\n            ,merchant_id AS _gsql2rsql__anon1_merchant_id\n          FROM\n            catalog.fraud.AccountTransaction\n        ) AS _right_3 ON\n          _left_3._gsql2rsql_a_id = _right_3._gsql2rsql__anon1_account_id\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_m_id\n          ,name AS _gsql2rsql_m_name\n        FROM\n          catalog.fraud.Merchant\n      ) AS _right_2 ON\n        _right_2._gsql2rsql_m_id = _left_2._gsql2rsql__anon1_merchant_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         account_id AS _gsql2rsql__anon2_account_id\n        ,merchant_id AS _gsql2rsql__anon2_merchant_id\n      FROM\n        catalog.fraud.AccountTransaction\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_m_id = _right_1._gsql2rsql__anon2_merchant_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_b_id\n    FROM\n      catalog.fraud.Account\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_b_id = _left_0._gsql2rsql__anon2_account_id\n) AS _proj\nWHERE (_gsql2rsql_a_id) != (_gsql2rsql_b_id)\nGROUP BY _gsql2rsql_a_id, _gsql2rsql_b_id, _gsql2rsql_m_name\nORDER BY shared_transactions DESC\nLIMIT 10\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: m:Merchant\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TRANSACTION]&lt;-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: b:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=;\n  ProjectionOperator(id=11)\n    Projections: id=a.id, id=b.id, name=m.name, shared_transactions=COUNT(*)\n    Filter: (a.id NEQ b.id)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#2-identify-camouflage-patterns-with-hidden-relationship-chains","title":"2. Identify camouflage patterns with hidden relationship chains","text":"<p>Application: Fraud: Camouflage detection</p> Notes <p>Detects indirect transfer chains between high-risk accounts. Fraudsters often use intermediary accounts to obscure direct connections.</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Account)-[:TRANSFER*2..4]-&gt;(b:Account)\nWHERE a.risk_score &gt; 70 AND b.risk_score &gt; 70\nRETURN a.id, b.id, LENGTH(path) AS chain_length,\n       [node IN nodes(path) | node.id] AS path_nodes\nORDER BY chain_length DESC\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.source_account_id AS start_node,\n      e.target_account_id AS end_node,\n      1 AS depth,\n      ARRAY(e.source_account_id, e.target_account_id) AS path,\n      ARRAY(NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      ARRAY(e.source_account_id) AS visited\n    FROM catalog.fraud.Transfer e\n    JOIN catalog.fraud.Account src ON src.id = e.source_account_id\n    WHERE (src.risk_score) &gt; (70)\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.target_account_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.target_account_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.source_account_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.fraud.Transfer e\n      ON p.end_node = e.source_account_id\n    WHERE p.depth &lt; 4\n      AND NOT ARRAY_CONTAINS(p.visited, e.target_account_id)\n  )\nSELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_b_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS chain_length\n  ,_gsql2rsql_path_id AS path_nodes\nFROM (\n  SELECT\n     sink.id AS _gsql2rsql_b_id\n    ,sink.holder_name AS _gsql2rsql_b_holder_name\n    ,sink.risk_score AS _gsql2rsql_b_risk_score\n    ,sink.status AS _gsql2rsql_b_status\n    ,sink.default_date AS _gsql2rsql_b_default_date\n    ,sink.home_country AS _gsql2rsql_b_home_country\n    ,sink.kyc_status AS _gsql2rsql_b_kyc_status\n    ,sink.days_since_creation AS _gsql2rsql_b_days_since_creation\n    ,source.id AS _gsql2rsql_a_id\n    ,source.holder_name AS _gsql2rsql_a_holder_name\n    ,source.risk_score AS _gsql2rsql_a_risk_score\n    ,source.status AS _gsql2rsql_a_status\n    ,source.default_date AS _gsql2rsql_a_default_date\n    ,source.home_country AS _gsql2rsql_a_home_country\n    ,source.kyc_status AS _gsql2rsql_a_kyc_status\n    ,source.days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,p.start_node\n    ,p.end_node\n    ,p.depth\n    ,p.path AS _gsql2rsql_path_id\n    ,p.path_edges AS _gsql2rsql_path_edges\n  FROM paths_1 p\n  JOIN catalog.fraud.Account sink\n    ON sink.id = p.end_node\n  JOIN catalog.fraud.Account source\n    ON source.id = p.start_node\n  WHERE p.depth &gt;= 2 AND p.depth &lt;= 4 AND (sink.risk_score) &gt; (70)\n) AS _proj\nORDER BY chain_length DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: b:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(TRANSFER*2..4, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=b RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=;\n  ProjectionOperator(id=5)\n    Projections: id=a.id, id=b.id, chain_length=LENGTH(path), path_nodes=[node IN NODES(path) | node.id]\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#3-find-high-risk-pos-machines-with-suspicious-transaction-patterns","title":"3. Find high-risk POS machines with suspicious transaction patterns","text":"<p>Application: Fraud: High-risk device monitoring</p> Notes <p>Monitors POS machines already flagged as high-risk for ongoing suspicious activity. Filters by vertex metadata (risk_status, flagged) to focus on known problem devices. Total volume and transaction counts help prioritize investigation.</p> OpenCypher Query Cypher<pre><code>MATCH (p:POS)-[:PROCESSED]-&gt;(t:Transaction)\nWHERE p.risk_status = 'high_risk' OR p.flagged = true\nWITH p,\n     COUNT(t) AS total_transactions,\n     SUM(t.amount) AS total_volume,\n     AVG(t.amount) AS avg_amount,\n     STDDEV(t.amount) AS stddev_amount\nWHERE total_transactions &gt; 50\nRETURN p.id, p.location, p.risk_status,\n       total_transactions, total_volume, avg_amount, stddev_amount\nORDER BY total_volume DESC\nLIMIT 20\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_p_id AS id\n  ,_gsql2rsql_p_location AS location\n  ,_gsql2rsql_p_risk_status AS risk_status\n  ,total_transactions AS total_transactions\n  ,total_volume AS total_volume\n  ,avg_amount AS avg_amount\n  ,stddev_amount AS stddev_amount\nFROM (\n  SELECT \n     _gsql2rsql_p_id AS _gsql2rsql_p_id\n    ,COUNT(_gsql2rsql_t_id) AS total_transactions\n    ,SUM(_gsql2rsql_t_amount) AS total_volume\n    ,AVG(CAST(_gsql2rsql_t_amount AS DOUBLE)) AS avg_amount\n    ,STDDEV(_gsql2rsql_t_amount) AS stddev_amount\n    ,_gsql2rsql_p_flagged AS _gsql2rsql_p_flagged\n    ,_gsql2rsql_p_location AS _gsql2rsql_p_location\n    ,_gsql2rsql_p_risk_status AS _gsql2rsql_p_risk_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n      ,_left_0._gsql2rsql_p_location AS _gsql2rsql_p_location\n      ,_left_0._gsql2rsql_p_risk_status AS _gsql2rsql_p_risk_status\n      ,_left_0._gsql2rsql_p_flagged AS _gsql2rsql_p_flagged\n      ,_left_0._gsql2rsql__anon1_pos_id AS _gsql2rsql__anon1_pos_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_1._gsql2rsql_p_location AS _gsql2rsql_p_location\n        ,_left_1._gsql2rsql_p_risk_status AS _gsql2rsql_p_risk_status\n        ,_left_1._gsql2rsql_p_flagged AS _gsql2rsql_p_flagged\n        ,_right_1._gsql2rsql__anon1_pos_id AS _gsql2rsql__anon1_pos_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_p_id\n          ,location AS _gsql2rsql_p_location\n          ,risk_status AS _gsql2rsql_p_risk_status\n          ,flagged AS _gsql2rsql_p_flagged\n        FROM\n          catalog.fraud.POS\n        WHERE (((risk_status) = ('high_risk')) OR ((flagged) = (TRUE)))\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           pos_id AS _gsql2rsql__anon1_pos_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.POSTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon1_pos_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n      FROM\n        catalog.fraud.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_p_id, _gsql2rsql_p_flagged, _gsql2rsql_p_location, _gsql2rsql_p_risk_status\n  HAVING (total_transactions) &gt; (50)\n) AS _proj\nORDER BY total_volume DESC\nLIMIT 20\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: p:POS\n    Filter: ((p.risk_status EQ 'high_risk') OR (p.flagged EQ true))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:PROCESSED]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: p=p, total_transactions=COUNT(t), total_volume=SUM(t.amount), avg_amount=AVG(t.amount), stddev_amount=STDEV(t.amount)\n    Having: (total_transactions GT 50)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=p.id, location=p.location, risk_status=p.risk_status, total_transactions=total_transactions, total_volume=total_volume, avg_amount=avg_amount, stddev_amount=stddev_amount\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#4-detect-synthetic-identity-networks-via-shared-attributes","title":"4. Detect synthetic identity networks via shared attributes","text":"<p>Application: Fraud: Synthetic identity detection</p> Notes <p>Finds addresses associated with multiple recently created accounts. May indicate synthetic identities or identity fabrication rings. Uses WITH...WHERE pattern for HAVING-like filtering on aggregated columns.</p> OpenCypher Query Cypher<pre><code>MATCH (p1:Person)-[:HAS_ADDRESS]-&gt;(addr:Address)&lt;-[:HAS_ADDRESS]-(p2:Person)\nWHERE p1.id &lt;&gt; p2.id AND p1.creation_date &gt; DATE('2023-01-01')\nWITH addr.street AS street, addr.city AS city, COUNT(DISTINCT p1.id) AS person_count\nWHERE person_count &gt; 5\nRETURN street, city, person_count\nORDER BY person_count DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   street AS street\n  ,city AS city\n  ,person_count AS person_count\nFROM (\n  SELECT \n     _gsql2rsql_addr_street AS street\n    ,_gsql2rsql_addr_city AS city\n    ,COUNT(DISTINCT _gsql2rsql_p1_id) AS person_count\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_p1_id AS _gsql2rsql_p1_id\n      ,_left_0._gsql2rsql_p1_creation_date AS _gsql2rsql_p1_creation_date\n      ,_left_0._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n      ,_left_0._gsql2rsql__anon1_address_id AS _gsql2rsql__anon1_address_id\n      ,_left_0._gsql2rsql_addr_id AS _gsql2rsql_addr_id\n      ,_left_0._gsql2rsql_addr_street AS _gsql2rsql_addr_street\n      ,_left_0._gsql2rsql_addr_city AS _gsql2rsql_addr_city\n      ,_left_0._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n      ,_left_0._gsql2rsql__anon2_address_id AS _gsql2rsql__anon2_address_id\n      ,_right_0._gsql2rsql_p2_id AS _gsql2rsql_p2_id\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_p1_id AS _gsql2rsql_p1_id\n        ,_left_1._gsql2rsql_p1_creation_date AS _gsql2rsql_p1_creation_date\n        ,_left_1._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n        ,_left_1._gsql2rsql__anon1_address_id AS _gsql2rsql__anon1_address_id\n        ,_left_1._gsql2rsql_addr_id AS _gsql2rsql_addr_id\n        ,_left_1._gsql2rsql_addr_street AS _gsql2rsql_addr_street\n        ,_left_1._gsql2rsql_addr_city AS _gsql2rsql_addr_city\n        ,_right_1._gsql2rsql__anon2_person_id AS _gsql2rsql__anon2_person_id\n        ,_right_1._gsql2rsql__anon2_address_id AS _gsql2rsql__anon2_address_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_p1_id AS _gsql2rsql_p1_id\n          ,_left_2._gsql2rsql_p1_creation_date AS _gsql2rsql_p1_creation_date\n          ,_left_2._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n          ,_left_2._gsql2rsql__anon1_address_id AS _gsql2rsql__anon1_address_id\n          ,_right_2._gsql2rsql_addr_id AS _gsql2rsql_addr_id\n          ,_right_2._gsql2rsql_addr_street AS _gsql2rsql_addr_street\n          ,_right_2._gsql2rsql_addr_city AS _gsql2rsql_addr_city\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_p1_id AS _gsql2rsql_p1_id\n            ,_left_3._gsql2rsql_p1_creation_date AS _gsql2rsql_p1_creation_date\n            ,_right_3._gsql2rsql__anon1_person_id AS _gsql2rsql__anon1_person_id\n            ,_right_3._gsql2rsql__anon1_address_id AS _gsql2rsql__anon1_address_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_p1_id\n              ,creation_date AS _gsql2rsql_p1_creation_date\n            FROM\n              catalog.fraud.Person\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               person_id AS _gsql2rsql__anon1_person_id\n              ,address_id AS _gsql2rsql__anon1_address_id\n            FROM\n              catalog.fraud.PersonAddress\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_p1_id = _right_3._gsql2rsql__anon1_person_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_addr_id\n            ,street AS _gsql2rsql_addr_street\n            ,city AS _gsql2rsql_addr_city\n          FROM\n            catalog.fraud.Address\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_addr_id = _left_2._gsql2rsql__anon1_address_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           person_id AS _gsql2rsql__anon2_person_id\n          ,address_id AS _gsql2rsql__anon2_address_id\n        FROM\n          catalog.fraud.PersonAddress\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_addr_id = _right_1._gsql2rsql__anon2_address_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_p2_id\n      FROM\n        catalog.fraud.Person\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_p2_id = _left_0._gsql2rsql__anon2_person_id\n  ) AS _proj\n  WHERE ((_gsql2rsql_p1_id) != (_gsql2rsql_p2_id)) AND ((_gsql2rsql_p1_creation_date) &gt; (TO_DATE('2023-01-01')))\n  GROUP BY _gsql2rsql_addr_street, _gsql2rsql_addr_city\n  HAVING (person_count) &gt; (5)\n) AS _proj\nORDER BY person_count DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: p1:Person\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_ADDRESS]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: addr:Address\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:HAS_ADDRESS]&lt;-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: p2:Person\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=p1 RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=addr RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=addr RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=p2 RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: street=addr.street, city=addr.city, person_count=COUNT(DISTINCT p1.id)\n    Filter: ((p1.id NEQ p2.id) AND (p1.creation_date GT DATE('2023-01-01')))\n    Having: (person_count GT 5)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: street=street, city=city, person_count=person_count\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#5-identify-card-testing-patterns-with-small-probe-transactions","title":"5. Identify card testing patterns with small probe transactions","text":"<p>Application: Fraud: Card testing</p> Notes <p>Detects cards with many small-value transactions in a short time. Common pattern for fraudsters testing stolen card validity.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Card)-[:USED_IN]-&gt;(t:Transaction)\nWHERE t.amount &lt; 1.00 AND t.timestamp &gt; TIMESTAMP() - DURATION('P1D')\nWITH c, COUNT(t) AS small_tx_count, COLLECT(t.merchant_id) AS merchants\nWHERE small_tx_count &gt; 10\nRETURN c.number, small_tx_count, SIZE(merchants) AS merchant_count\nORDER BY small_tx_count DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_number AS number\n  ,small_tx_count AS small_tx_count\n  ,SIZE(merchants) AS merchant_count\nFROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,COUNT(_gsql2rsql_t_id) AS small_tx_count\n    ,COLLECT_LIST(_gsql2rsql_t_merchant_id) AS merchants\n    ,_gsql2rsql_c_number AS _gsql2rsql_c_number\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_left_0._gsql2rsql_c_number AS _gsql2rsql_c_number\n      ,_left_0._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n      ,_right_0._gsql2rsql_t_merchant_id AS _gsql2rsql_t_merchant_id\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_1._gsql2rsql_c_number AS _gsql2rsql_c_number\n        ,_right_1._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_c_id\n          ,number AS _gsql2rsql_c_number\n        FROM\n          catalog.fraud.Card\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           card_id AS _gsql2rsql__anon1_card_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.CardTransaction\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_c_id = _right_1._gsql2rsql__anon1_card_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n        ,merchant_id AS _gsql2rsql_t_merchant_id\n      FROM\n        catalog.fraud.Transaction\n      WHERE ((amount) &lt; (1.0))\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 1 DAY))\n  GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_number\n  HAVING (small_tx_count) &gt; (10)\n) AS _proj\nORDER BY small_tx_count DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: c:Card\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:USED_IN]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n    Filter: (t.amount LT 1.0)\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: c=c, small_tx_count=COUNT(t), merchants=COLLECT(t.merchant_id)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('P1D')))\n    Having: (small_tx_count GT 10)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: number=c.number, small_tx_count=small_tx_count, merchant_count=SIZE(merchants)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#6-find-collusion-networks-via-coordinated-transaction-timing","title":"6. Find collusion networks via coordinated transaction timing","text":"<p>Application: Fraud: Collusion detection</p> Notes <p>Identifies accounts making synchronized transactions at the same merchant. May indicate coordinated fraud or collusion rings. Uses WITH...WHERE pattern for HAVING-like filtering on aggregated columns.</p> OpenCypher Query Cypher<pre><code>MATCH (a1:Account)-[:HAS_TRANSACTION]-&gt;(t1:Transaction),\n      (a2:Account)-[:HAS_TRANSACTION]-&gt;(t2:Transaction)\nWHERE a1.id &lt; a2.id\n  AND ABS(t1.timestamp - t2.timestamp) &lt; DURATION('PT5M')\n  AND t1.merchant_id = t2.merchant_id\nWITH a1.id AS a1_id, a2.id AS a2_id, t1.merchant_id AS merchant_id, COUNT(*) AS coordinated_count\nWHERE coordinated_count &gt; 5\nRETURN a1_id, a2_id, merchant_id, coordinated_count\nORDER BY coordinated_count DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   a1_id AS a1_id\n  ,a2_id AS a2_id\n  ,merchant_id AS merchant_id\n  ,coordinated_count AS coordinated_count\nFROM (\n  SELECT \n     _gsql2rsql_a1_id AS a1_id\n    ,_gsql2rsql_a2_id AS a2_id\n    ,_gsql2rsql_t1_merchant_id AS merchant_id\n    ,COUNT(*) AS coordinated_count\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_left_0._gsql2rsql_t1_id AS _gsql2rsql_t1_id\n      ,_left_0._gsql2rsql_t1_timestamp AS _gsql2rsql_t1_timestamp\n      ,_left_0._gsql2rsql_t1_merchant_id AS _gsql2rsql_t1_merchant_id\n      ,_left_0._gsql2rsql_a2_id AS _gsql2rsql_a2_id\n      ,_left_0._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_right_0._gsql2rsql_t2_id AS _gsql2rsql_t2_id\n      ,_right_0._gsql2rsql_t2_timestamp AS _gsql2rsql_t2_timestamp\n      ,_right_0._gsql2rsql_t2_merchant_id AS _gsql2rsql_t2_merchant_id\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n        ,_left_1._gsql2rsql_t1_id AS _gsql2rsql_t1_id\n        ,_left_1._gsql2rsql_t1_timestamp AS _gsql2rsql_t1_timestamp\n        ,_left_1._gsql2rsql_t1_merchant_id AS _gsql2rsql_t1_merchant_id\n        ,_left_1._gsql2rsql_a2_id AS _gsql2rsql_a2_id\n        ,_right_1._gsql2rsql__anon2_account_id AS _gsql2rsql__anon2_account_id\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_left_2._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n          ,_left_2._gsql2rsql_t1_id AS _gsql2rsql_t1_id\n          ,_left_2._gsql2rsql_t1_timestamp AS _gsql2rsql_t1_timestamp\n          ,_left_2._gsql2rsql_t1_merchant_id AS _gsql2rsql_t1_merchant_id\n          ,_right_2._gsql2rsql_a2_id AS _gsql2rsql_a2_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n            ,_left_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n            ,_left_3._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n            ,_right_3._gsql2rsql_t1_id AS _gsql2rsql_t1_id\n            ,_right_3._gsql2rsql_t1_timestamp AS _gsql2rsql_t1_timestamp\n            ,_right_3._gsql2rsql_t1_merchant_id AS _gsql2rsql_t1_merchant_id\n          FROM (\n            SELECT\n               _left_4._gsql2rsql_a1_id AS _gsql2rsql_a1_id\n              ,_right_4._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n              ,_right_4._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n            FROM (\n              SELECT\n                 id AS _gsql2rsql_a1_id\n              FROM\n                catalog.fraud.Account\n            ) AS _left_4\n            INNER JOIN (\n              SELECT\n                 account_id AS _gsql2rsql__anon1_account_id\n                ,transaction_id AS _gsql2rsql__anon1_transaction_id\n              FROM\n                catalog.fraud.AccountTx\n            ) AS _right_4 ON\n              _left_4._gsql2rsql_a1_id = _right_4._gsql2rsql__anon1_account_id\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               id AS _gsql2rsql_t1_id\n              ,timestamp AS _gsql2rsql_t1_timestamp\n              ,merchant_id AS _gsql2rsql_t1_merchant_id\n            FROM\n              catalog.fraud.Transaction\n          ) AS _right_3 ON\n            _right_3._gsql2rsql_t1_id = _left_3._gsql2rsql__anon1_transaction_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_a2_id\n          FROM\n            catalog.fraud.Account\n        ) AS _right_2 ON\n          TRUE\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon2_account_id\n          ,transaction_id AS _gsql2rsql__anon2_transaction_id\n        FROM\n          catalog.fraud.AccountTx\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a2_id = _right_1._gsql2rsql__anon2_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t2_id\n        ,timestamp AS _gsql2rsql_t2_timestamp\n        ,merchant_id AS _gsql2rsql_t2_merchant_id\n      FROM\n        catalog.fraud.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t2_id = _left_0._gsql2rsql__anon2_transaction_id\n  ) AS _proj\n  WHERE (((_gsql2rsql_a1_id) &lt; (_gsql2rsql_a2_id)) AND ((ABS((UNIX_TIMESTAMP(_gsql2rsql_t1_timestamp) - UNIX_TIMESTAMP(_gsql2rsql_t2_timestamp)))) &lt; (300))) AND ((_gsql2rsql_t1_merchant_id) = (_gsql2rsql_t2_merchant_id))\n  GROUP BY _gsql2rsql_a1_id, _gsql2rsql_a2_id, _gsql2rsql_t1_merchant_id\n  HAVING (coordinated_count) &gt; (5)\n) AS _proj\nORDER BY coordinated_count DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=1)\n    DataSource: a1:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=3)\n    DataSource: t1:Transaction\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=4)\n    DataSource: a2:Account\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=10;\n  DataSourceOperator(id=5)\n    DataSource: [_anon2:HAS_TRANSACTION]-&gt;\n*\nOpId=6 Op=DataSourceOperator; InOpIds=; OutOpIds=11;\n  DataSourceOperator(id=6)\n    DataSource: t2:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=1,2; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=a1 RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,3; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=t1 RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,4; OutOpIds=10;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: \n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=10 Op=JoinOperator; InOpIds=9,5; OutOpIds=11;\n  JoinOperator(id=10)\n    JoinType: INNER\n    Joins: JoinPair: Node=a2 RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=JoinOperator; InOpIds=10,6; OutOpIds=13;\n  JoinOperator(id=11)\n    JoinType: INNER\n    Joins: JoinPair: Node=t2 RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=13 Op=ProjectionOperator; InOpIds=11; OutOpIds=14;\n  ProjectionOperator(id=13)\n    Projections: a1_id=a1.id, a2_id=a2.id, merchant_id=t1.merchant_id, coordinated_count=COUNT(*)\n    Filter: (((a1.id LT a2.id) AND (ABS((t1.timestamp MINUS t2.timestamp)) LT DURATION('PT5M'))) AND (t1.merchant_id EQ t2.merchant_id))\n    Having: (coordinated_count GT 5)\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=14 Op=ProjectionOperator; InOpIds=13; OutOpIds=;\n  ProjectionOperator(id=14)\n    Projections: a1_id=a1_id, a2_id=a2_id, merchant_id=merchant_id, coordinated_count=coordinated_count\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#7-trace-money-mule-networks-with-rapid-transfer-chains","title":"7. Trace money mule networks with rapid transfer chains","text":"<p>Application: Fraud: Money mule detection</p> Notes <p>Finds multi-hop transfer chains moving large amounts quickly. Classic pattern for money laundering via mule accounts.</p> OpenCypher Query Cypher<pre><code>MATCH path = (source:Account)-[:TRANSFER*3..6]-&gt;(sink:Account)\nWHERE ALL(rel IN relationships(path) WHERE rel.timestamp &gt; TIMESTAMP() - DURATION('P7D'))\n  AND ALL(rel IN relationships(path) WHERE rel.amount &gt; 1000)\nWITH source, sink, path,\n     REDUCE(total = 0, rel IN relationships(path) | total + rel.amount) AS total_amount\nRETURN source.id, sink.id, LENGTH(path) AS hops, total_amount\nORDER BY total_amount DESC\nLIMIT 15\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.source_account_id AS start_node,\n      e.target_account_id AS end_node,\n      1 AS depth,\n      ARRAY(e.source_account_id, e.target_account_id) AS path,\n      ARRAY(NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      ARRAY(e.source_account_id) AS visited\n    FROM catalog.fraud.Transfer e\n    WHERE ((e.timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 7 DAY))) AND ((e.amount) &gt; (1000))\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.target_account_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.target_account_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.source_account_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.fraud.Transfer e\n      ON p.end_node = e.source_account_id\n    WHERE p.depth &lt; 6\n      AND NOT ARRAY_CONTAINS(p.visited, e.target_account_id)\n      AND ((e.timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 7 DAY))) AND ((e.amount) &gt; (1000))\n  )\nSELECT \n   _gsql2rsql_source_id AS id\n  ,_gsql2rsql_sink_id AS id\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS hops\n  ,total_amount AS total_amount\nFROM (\n  SELECT \n     _gsql2rsql_source_id AS _gsql2rsql_source_id\n    ,_gsql2rsql_sink_id AS _gsql2rsql_sink_id\n    ,_gsql2rsql_path_id AS _gsql2rsql_path_id\n    ,AGGREGATE(_gsql2rsql_path_edges, CAST(0 AS DOUBLE), (total, rel) -&gt; (total) + (rel.amount)) AS total_amount\n    ,_gsql2rsql_sink_days_since_creation AS _gsql2rsql_sink_days_since_creation\n    ,_gsql2rsql_sink_default_date AS _gsql2rsql_sink_default_date\n    ,_gsql2rsql_sink_holder_name AS _gsql2rsql_sink_holder_name\n    ,_gsql2rsql_sink_home_country AS _gsql2rsql_sink_home_country\n    ,_gsql2rsql_sink_kyc_status AS _gsql2rsql_sink_kyc_status\n    ,_gsql2rsql_sink_risk_score AS _gsql2rsql_sink_risk_score\n    ,_gsql2rsql_sink_status AS _gsql2rsql_sink_status\n    ,_gsql2rsql_source_days_since_creation AS _gsql2rsql_source_days_since_creation\n    ,_gsql2rsql_source_default_date AS _gsql2rsql_source_default_date\n    ,_gsql2rsql_source_holder_name AS _gsql2rsql_source_holder_name\n    ,_gsql2rsql_source_home_country AS _gsql2rsql_source_home_country\n    ,_gsql2rsql_source_kyc_status AS _gsql2rsql_source_kyc_status\n    ,_gsql2rsql_source_risk_score AS _gsql2rsql_source_risk_score\n    ,_gsql2rsql_source_status AS _gsql2rsql_source_status\n  FROM (\n    SELECT\n       sink.id AS _gsql2rsql_sink_id\n      ,sink.holder_name AS _gsql2rsql_sink_holder_name\n      ,sink.risk_score AS _gsql2rsql_sink_risk_score\n      ,sink.status AS _gsql2rsql_sink_status\n      ,sink.default_date AS _gsql2rsql_sink_default_date\n      ,sink.home_country AS _gsql2rsql_sink_home_country\n      ,sink.kyc_status AS _gsql2rsql_sink_kyc_status\n      ,sink.days_since_creation AS _gsql2rsql_sink_days_since_creation\n      ,source.id AS _gsql2rsql_source_id\n      ,source.holder_name AS _gsql2rsql_source_holder_name\n      ,source.risk_score AS _gsql2rsql_source_risk_score\n      ,source.status AS _gsql2rsql_source_status\n      ,source.default_date AS _gsql2rsql_source_default_date\n      ,source.home_country AS _gsql2rsql_source_home_country\n      ,source.kyc_status AS _gsql2rsql_source_kyc_status\n      ,source.days_since_creation AS _gsql2rsql_source_days_since_creation\n      ,p.start_node\n      ,p.end_node\n      ,p.depth\n      ,p.path AS _gsql2rsql_path_id\n      ,p.path_edges AS _gsql2rsql_path_edges\n    FROM paths_1 p\n    JOIN catalog.fraud.Account sink\n      ON sink.id = p.end_node\n    JOIN catalog.fraud.Account source\n      ON source.id = p.start_node\n    WHERE p.depth &gt;= 3 AND p.depth &lt;= 6\n  ) AS _proj\n) AS _proj\nORDER BY total_amount DESC\nLIMIT 15\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: source:Account\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: sink:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(TRANSFER*3..6, path=path)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=sink RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=5 Op=ProjectionOperator; InOpIds=4; OutOpIds=6;\n  ProjectionOperator(id=5)\n    Projections: source=source, sink=sink, path=path, total_amount=REDUCE(total = 0, rel IN RELATIONSHIPS(path) | (total PLUS rel.amount))\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=;\n  ProjectionOperator(id=6)\n    Projections: id=source.id, id=sink.id, hops=LENGTH(path), total_amount=total_amount\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#8-calculate-customer-similarity-via-shared-card-usage-patterns","title":"8. Calculate customer similarity via shared card usage patterns","text":"<p>Application: Fraud: Customer similarity clustering</p> Notes <p>Measures similarity between customers based on shared cards and merchants. High similarity scores may indicate card sharing, family fraud, or organized rings. Combines multiple metrics for more accurate clustering.</p> OpenCypher Query Cypher<pre><code>MATCH (c1:Customer)-[:HAS_CARD]-&gt;(card:Card)&lt;-[:HAS_CARD]-(c2:Customer)\nWHERE c1.id &lt; c2.id\nWITH c1, c2, COUNT(DISTINCT card) AS shared_cards\nWHERE shared_cards &gt; 0\nMATCH (c1)-[:HAS_CARD]-&gt;(card1:Card)-[:USED_AT]-&gt;(m:Merchant)\nMATCH (c2)-[:HAS_CARD]-&gt;(card2:Card)-[:USED_AT]-&gt;(m)\nWITH c1, c2, shared_cards,\n     COUNT(DISTINCT m) AS shared_merchants,\n     shared_cards * 1.0 / (shared_cards + shared_merchants) AS similarity_score\nWHERE similarity_score &gt; 0.3\nRETURN c1.id, c2.id, shared_cards, shared_merchants, similarity_score\nORDER BY similarity_score DESC\nLIMIT 50\n</code></pre> Generated SQL SQL<pre><code>WITH\nagg_boundary_1 AS (\n  SELECT\n    _gsql2rsql_c1_id AS `c1`,\n    _gsql2rsql_c2_id AS `c2`,\n    COUNT(DISTINCT _gsql2rsql_card_id) AS `shared_cards`\n  FROM (\n  SELECT *\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n      ,_left_0._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n      ,_left_0._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n      ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_0._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_0._gsql2rsql_card_id AS _gsql2rsql_card_id\n      ,_left_0._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n      ,_left_0._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n      ,_right_0._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n      ,_right_0._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n      ,_right_0._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n        ,_left_1._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n        ,_left_1._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n        ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_1._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_left_1._gsql2rsql_card_id AS _gsql2rsql_card_id\n        ,_right_1._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n        ,_right_1._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n          ,_left_2._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n          ,_left_2._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n          ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_2._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_right_2._gsql2rsql_card_id AS _gsql2rsql_card_id\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n            ,_left_3._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n            ,_left_3._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n            ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_right_3._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_c1_id\n              ,name AS _gsql2rsql_c1_name\n              ,status AS _gsql2rsql_c1_status\n            FROM\n              catalog.fraud.Customer\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               customer_id AS _gsql2rsql__anon1_customer_id\n              ,card_id AS _gsql2rsql__anon1_card_id\n            FROM\n              catalog.fraud.CustomerCard\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_c1_id = _right_3._gsql2rsql__anon1_customer_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_card_id\n          FROM\n            catalog.fraud.Card\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_card_id = _left_2._gsql2rsql__anon1_card_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           customer_id AS _gsql2rsql__anon2_customer_id\n          ,card_id AS _gsql2rsql__anon2_card_id\n        FROM\n          catalog.fraud.CustomerCard\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_card_id = _right_1._gsql2rsql__anon2_card_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_c2_id\n        ,name AS _gsql2rsql_c2_name\n        ,status AS _gsql2rsql_c2_status\n      FROM\n        catalog.fraud.Customer\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_c2_id = _left_0._gsql2rsql__anon2_customer_id\n  ) AS _filter\n  WHERE (_gsql2rsql_c1_id) &lt; (_gsql2rsql_c2_id)\n  ) AS _agg_input\n  GROUP BY _gsql2rsql_c1_id, _gsql2rsql_c2_id\n  HAVING (shared_cards) &gt; (0)\n)\nSELECT \n   _gsql2rsql_c1_id AS id\n  ,_gsql2rsql_c2_id AS id\n  ,shared_cards AS shared_cards\n  ,shared_merchants AS shared_merchants\n  ,similarity_score AS similarity_score\nFROM (\n  SELECT \n     _gsql2rsql_c1_id AS _gsql2rsql_c1_id\n    ,_gsql2rsql_c2_id AS _gsql2rsql_c2_id\n    ,shared_cards AS shared_cards\n    ,COUNT(DISTINCT _gsql2rsql_m_id) AS shared_merchants\n    ,((shared_cards) * (1.0)) / ((shared_cards) + (shared_merchants)) AS similarity_score\n    ,_gsql2rsql_c1_name AS _gsql2rsql_c1_name\n    ,_gsql2rsql_c1_status AS _gsql2rsql_c1_status\n    ,_gsql2rsql_c2_name AS _gsql2rsql_c2_name\n    ,_gsql2rsql_c2_status AS _gsql2rsql_c2_status\n  FROM (\n    SELECT\n       _left_4.c1 AS c1\n      ,_left_4.c2 AS c2\n      ,_left_4.shared_cards AS shared_cards\n      ,_left_4._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n      ,_left_4._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n      ,_left_4._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n      ,_left_4._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_4._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_4._gsql2rsql_card1_id AS _gsql2rsql_card1_id\n      ,_left_4._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n      ,_left_4._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n      ,_left_4._gsql2rsql_m_id AS _gsql2rsql_m_id\n      ,_right_4._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n      ,_right_4._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n      ,_right_4._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n      ,_right_4._gsql2rsql_card2_id AS _gsql2rsql_card2_id\n    FROM (\n      SELECT\n         _left_6.`c1` AS `c1`\n        ,_left_6.`c2` AS `c2`\n        ,_left_6.`shared_cards` AS `shared_cards`\n        ,_right_6._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_right_6._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n        ,_right_6._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n        ,_right_6._gsql2rsql_m_id AS _gsql2rsql_m_id\n        ,_right_6._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n        ,_right_6._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n        ,_right_6._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n        ,_right_6._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_right_6._gsql2rsql_card1_id AS _gsql2rsql_card1_id\n      FROM (\n        SELECT\n           `c1`\n          ,`c2`\n          ,`shared_cards`\n        FROM agg_boundary_1\n      ) AS _left_6\n      INNER JOIN (\n        SELECT\n           _left_7._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n          ,_left_7._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n          ,_left_7._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n          ,_left_7._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_7._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_left_7._gsql2rsql_card1_id AS _gsql2rsql_card1_id\n          ,_left_7._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n          ,_left_7._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n          ,_right_7._gsql2rsql_m_id AS _gsql2rsql_m_id\n        FROM (\n          SELECT\n             _left_8._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n            ,_left_8._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n            ,_left_8._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n            ,_left_8._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_8._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n            ,_left_8._gsql2rsql_card1_id AS _gsql2rsql_card1_id\n            ,_right_8._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n            ,_right_8._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n          FROM (\n            SELECT\n               _left_9._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n              ,_left_9._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n              ,_left_9._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n              ,_left_9._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_left_9._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n              ,_right_9._gsql2rsql_card1_id AS _gsql2rsql_card1_id\n            FROM (\n              SELECT\n                 _left_10._gsql2rsql_c1_id AS _gsql2rsql_c1_id\n                ,_left_10._gsql2rsql_c1_name AS _gsql2rsql_c1_name\n                ,_left_10._gsql2rsql_c1_status AS _gsql2rsql_c1_status\n                ,_right_10._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n                ,_right_10._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n              FROM (\n                SELECT\n                   id AS _gsql2rsql_c1_id\n                  ,name AS _gsql2rsql_c1_name\n                  ,status AS _gsql2rsql_c1_status\n                FROM\n                  catalog.fraud.Customer\n              ) AS _left_10\n              INNER JOIN (\n                SELECT\n                   customer_id AS _gsql2rsql__anon1_customer_id\n                  ,card_id AS _gsql2rsql__anon1_card_id\n                FROM\n                  catalog.fraud.CustomerCard\n              ) AS _right_10 ON\n                _left_10._gsql2rsql_c1_id = _right_10._gsql2rsql__anon1_customer_id\n            ) AS _left_9\n            INNER JOIN (\n              SELECT\n                 id AS _gsql2rsql_card1_id\n              FROM\n                catalog.fraud.Card\n            ) AS _right_9 ON\n              _right_9._gsql2rsql_card1_id = _left_9._gsql2rsql__anon1_card_id\n          ) AS _left_8\n          INNER JOIN (\n            SELECT\n               card_id AS _gsql2rsql__anon2_card_id\n              ,merchant_id AS _gsql2rsql__anon2_merchant_id\n            FROM\n              catalog.fraud.CardMerchant\n          ) AS _right_8 ON\n            _left_8._gsql2rsql_card1_id = _right_8._gsql2rsql__anon2_card_id\n        ) AS _left_7\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_m_id\n          FROM\n            catalog.fraud.Merchant\n        ) AS _right_7 ON\n          _right_7._gsql2rsql_m_id = _left_7._gsql2rsql__anon2_merchant_id\n      ) AS _right_6 ON\n        _left_6.`c1` = _right_6._gsql2rsql_c1_id\n    ) AS _left_4\n    INNER JOIN (\n      SELECT\n         _left_11._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n        ,_left_11._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n        ,_left_11._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n        ,_left_11._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_11._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_left_11._gsql2rsql_card2_id AS _gsql2rsql_card2_id\n        ,_left_11._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n        ,_left_11._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n        ,_right_11._gsql2rsql_m_id AS _gsql2rsql_m_id\n      FROM (\n        SELECT\n           _left_12._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n          ,_left_12._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n          ,_left_12._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n          ,_left_12._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_12._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_left_12._gsql2rsql_card2_id AS _gsql2rsql_card2_id\n          ,_right_12._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n          ,_right_12._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n        FROM (\n          SELECT\n             _left_13._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n            ,_left_13._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n            ,_left_13._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n            ,_left_13._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_13._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n            ,_right_13._gsql2rsql_card2_id AS _gsql2rsql_card2_id\n          FROM (\n            SELECT\n               _left_14._gsql2rsql_c2_id AS _gsql2rsql_c2_id\n              ,_left_14._gsql2rsql_c2_name AS _gsql2rsql_c2_name\n              ,_left_14._gsql2rsql_c2_status AS _gsql2rsql_c2_status\n              ,_right_14._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_right_14._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n            FROM (\n              SELECT\n                 id AS _gsql2rsql_c2_id\n                ,name AS _gsql2rsql_c2_name\n                ,status AS _gsql2rsql_c2_status\n              FROM\n                catalog.fraud.Customer\n            ) AS _left_14\n            INNER JOIN (\n              SELECT\n                 customer_id AS _gsql2rsql__anon1_customer_id\n                ,card_id AS _gsql2rsql__anon1_card_id\n              FROM\n                catalog.fraud.CustomerCard\n            ) AS _right_14 ON\n              _left_14._gsql2rsql_c2_id = _right_14._gsql2rsql__anon1_customer_id\n          ) AS _left_13\n          INNER JOIN (\n            SELECT\n               id AS _gsql2rsql_card2_id\n            FROM\n              catalog.fraud.Card\n          ) AS _right_13 ON\n            _right_13._gsql2rsql_card2_id = _left_13._gsql2rsql__anon1_card_id\n        ) AS _left_12\n        INNER JOIN (\n          SELECT\n             card_id AS _gsql2rsql__anon2_card_id\n            ,merchant_id AS _gsql2rsql__anon2_merchant_id\n          FROM\n            catalog.fraud.CardMerchant\n        ) AS _right_12 ON\n          _left_12._gsql2rsql_card2_id = _right_12._gsql2rsql__anon2_card_id\n      ) AS _left_11\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_m_id\n        FROM\n          catalog.fraud.Merchant\n      ) AS _right_11 ON\n        _right_11._gsql2rsql_m_id = _left_11._gsql2rsql__anon2_merchant_id\n    ) AS _right_4 ON\n      _left_4._gsql2rsql_m_id = _right_4._gsql2rsql_m_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_c1_id, _gsql2rsql_c2_id, shared_cards, _gsql2rsql_c1_name, _gsql2rsql_c1_status, _gsql2rsql_c2_name, _gsql2rsql_c2_status\n  HAVING (similarity_score) &gt; (0.3)\n) AS _proj\nORDER BY similarity_score DESC\nLIMIT 50\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c1:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: card:Card\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:HAS_CARD]&lt;-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: c2:Customer\n*\nOpId=12 Op=DataSourceOperator; InOpIds=; OutOpIds=17;\n  DataSourceOperator(id=12)\n    DataSource: c1:Customer\n*\nOpId=13 Op=DataSourceOperator; InOpIds=; OutOpIds=17;\n  DataSourceOperator(id=13)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=14 Op=DataSourceOperator; InOpIds=; OutOpIds=18;\n  DataSourceOperator(id=14)\n    DataSource: card1:Card\n*\nOpId=15 Op=DataSourceOperator; InOpIds=; OutOpIds=19;\n  DataSourceOperator(id=15)\n    DataSource: [_anon2:USED_AT]-&gt;\n*\nOpId=16 Op=DataSourceOperator; InOpIds=; OutOpIds=20;\n  DataSourceOperator(id=16)\n    DataSource: m:Merchant\n*\nOpId=22 Op=DataSourceOperator; InOpIds=; OutOpIds=27;\n  DataSourceOperator(id=22)\n    DataSource: c2:Customer\n*\nOpId=23 Op=DataSourceOperator; InOpIds=; OutOpIds=27;\n  DataSourceOperator(id=23)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=24 Op=DataSourceOperator; InOpIds=; OutOpIds=28;\n  DataSourceOperator(id=24)\n    DataSource: card2:Card\n*\nOpId=25 Op=DataSourceOperator; InOpIds=; OutOpIds=29;\n  DataSourceOperator(id=25)\n    DataSource: [_anon2:USED_AT]-&gt;\n*\nOpId=26 Op=DataSourceOperator; InOpIds=; OutOpIds=30;\n  DataSourceOperator(id=26)\n    DataSource: m:Merchant\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=_anon1 Type=SOURCE\n*\nOpId=17 Op=JoinOperator; InOpIds=12,13; OutOpIds=18;\n  JoinOperator(id=17)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=_anon1 Type=SOURCE\n*\nOpId=27 Op=JoinOperator; InOpIds=22,23; OutOpIds=28;\n  JoinOperator(id=27)\n    JoinType: INNER\n    Joins: JoinPair: Node=c2 RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon1 Type=SINK\n*\nOpId=18 Op=JoinOperator; InOpIds=17,14; OutOpIds=19;\n  JoinOperator(id=18)\n    JoinType: INNER\n    Joins: JoinPair: Node=card1 RelOrNode=_anon1 Type=SINK\n*\nOpId=28 Op=JoinOperator; InOpIds=27,24; OutOpIds=29;\n  JoinOperator(id=28)\n    JoinType: INNER\n    Joins: JoinPair: Node=card2 RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon2 Type=SINK\n*\nOpId=19 Op=JoinOperator; InOpIds=18,15; OutOpIds=20;\n  JoinOperator(id=19)\n    JoinType: INNER\n    Joins: JoinPair: Node=card1 RelOrNode=_anon2 Type=SOURCE\n*\nOpId=29 Op=JoinOperator; InOpIds=28,25; OutOpIds=30;\n  JoinOperator(id=29)\n    JoinType: INNER\n    Joins: JoinPair: Node=card2 RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=10;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=c2 RelOrNode=_anon2 Type=SOURCE\n*\nOpId=20 Op=JoinOperator; InOpIds=19,16; OutOpIds=21;\n  JoinOperator(id=20)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon2 Type=SINK\n*\nOpId=30 Op=JoinOperator; InOpIds=29,26; OutOpIds=31;\n  JoinOperator(id=30)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=SelectionOperator; InOpIds=9; OutOpIds=11;\n  SelectionOperator(id=10)\n    Filter: (c1.id LT c2.id)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=11 Op=AggregationBoundaryOperator; InOpIds=10; OutOpIds=21;\n  AggregationBoundaryOperator(id=11)\n    GroupBy: [c1, c2]\n    Aggregates: [shared_cards]\n    Having: (shared_cards GT 0)\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=21 Op=JoinOperator; InOpIds=11,20; OutOpIds=31;\n  JoinOperator(id=21)\n    JoinType: INNER\n    Joins: JoinPair: Node=c1 RelOrNode=agg_boundary_1 Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 8:\n----------------------------------------------------------------------\nOpId=31 Op=JoinOperator; InOpIds=21,30; OutOpIds=32;\n  JoinOperator(id=31)\n    JoinType: INNER\n    Joins: JoinPair: Node=c2 RelOrNode=agg_boundary_1 Type=NODE_ID, JoinPair: Node=m RelOrNode=m Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 9:\n----------------------------------------------------------------------\nOpId=32 Op=ProjectionOperator; InOpIds=31; OutOpIds=33;\n  ProjectionOperator(id=32)\n    Projections: c1=c1, c2=c2, shared_cards=shared_cards, shared_merchants=COUNT(DISTINCT m), similarity_score=((shared_cards MULTIPLY 1.0) DIVIDE (shared_cards PLUS shared_merchants))\n    Having: (similarity_score GT 0.3)\n*\n----------------------------------------------------------------------\nLevel 10:\n----------------------------------------------------------------------\nOpId=33 Op=ProjectionOperator; InOpIds=32; OutOpIds=;\n  ProjectionOperator(id=33)\n    Projections: id=c1.id, id=c2.id, shared_cards=shared_cards, shared_merchants=shared_merchants, similarity_score=similarity_score\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#9-find-velocity-abuse-patterns-with-high-frequency-transactions","title":"9. Find velocity abuse patterns with high-frequency transactions","text":"<p>Application: Fraud: Velocity abuse</p> Notes <p>Detects accounts with abnormally high transaction frequency. May indicate automated fraud, account compromise, or velocity attacks.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:HAS_TRANSACTION]-&gt;(t:Transaction)\nWHERE t.timestamp &gt; TIMESTAMP() - DURATION('PT1H')\nWITH a, COUNT(t) AS tx_per_hour, SUM(t.amount) AS total_amount\nWHERE tx_per_hour &gt; 20\nRETURN a.id, a.holder_name, tx_per_hour, total_amount\nORDER BY tx_per_hour DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_a_holder_name AS holder_name\n  ,tx_per_hour AS tx_per_hour\n  ,total_amount AS total_amount\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,COUNT(_gsql2rsql_t_id) AS tx_per_hour\n    ,SUM(_gsql2rsql_t_amount) AS total_amount\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_right_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_a_id\n          ,holder_name AS _gsql2rsql_a_holder_name\n          ,risk_score AS _gsql2rsql_a_risk_score\n          ,status AS _gsql2rsql_a_status\n          ,default_date AS _gsql2rsql_a_default_date\n          ,home_country AS _gsql2rsql_a_home_country\n          ,kyc_status AS _gsql2rsql_a_kyc_status\n          ,days_since_creation AS _gsql2rsql_a_days_since_creation\n        FROM\n          catalog.fraud.Account\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon1_account_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.AccountTx\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.fraud.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 1 HOUR))\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status\n  HAVING (tx_per_hour) &gt; (20)\n) AS _proj\nORDER BY tx_per_hour DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: a=a, tx_per_hour=COUNT(t), total_amount=SUM(t.amount)\n    Filter: (t.timestamp GT (DATETIME() MINUS DURATION('PT1H')))\n    Having: (tx_per_hour GT 20)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=a.id, holder_name=a.holder_name, tx_per_hour=tx_per_hour, total_amount=total_amount\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#10-identify-return-fraud-patterns-with-high-return-rates","title":"10. Identify return fraud patterns with high return rates","text":"<p>Application: Fraud: Return fraud</p> Notes <p>Finds customers with suspiciously high return rates. May indicate wardrobing, receipt fraud, or return fraud schemes.</p> OpenCypher Query Cypher<pre><code>MATCH (c:Customer)-[:MADE_PURCHASE]-&gt;(p:Purchase)-[:RETURNED]-&gt;(r:Return)\nWITH c, COUNT(p) AS total_purchases, COUNT(r) AS total_returns\nWHERE total_purchases &gt; 10\nWITH c, total_purchases, total_returns,\n     (total_returns * 1.0 / total_purchases) AS return_rate\nWHERE return_rate &gt; 0.5\nRETURN c.id, c.name, total_purchases, total_returns, return_rate\nORDER BY return_rate DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_c_id AS id\n  ,_gsql2rsql_c_name AS name\n  ,total_purchases AS total_purchases\n  ,total_returns AS total_returns\n  ,return_rate AS return_rate\nFROM (\n  SELECT *\n  FROM (\n  SELECT \n     _gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,total_purchases AS total_purchases\n    ,total_returns AS total_returns\n    ,((total_returns) * (1.0)) / (total_purchases) AS return_rate\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n    ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n  FROM (\n    SELECT \n       _gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,COUNT(_gsql2rsql_p_id) AS total_purchases\n      ,COUNT(_gsql2rsql_r_id) AS total_returns\n      ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n      ,_gsql2rsql_c_status AS _gsql2rsql_c_status\n    FROM (\n      SELECT\n         _left_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n        ,_left_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n        ,_left_0._gsql2rsql_c_status AS _gsql2rsql_c_status\n        ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_0._gsql2rsql__anon1_purchase_id AS _gsql2rsql__anon1_purchase_id\n        ,_left_0._gsql2rsql_p_id AS _gsql2rsql_p_id\n        ,_left_0._gsql2rsql__anon2_purchase_id AS _gsql2rsql__anon2_purchase_id\n        ,_left_0._gsql2rsql__anon2_return_id AS _gsql2rsql__anon2_return_id\n        ,_right_0._gsql2rsql_r_id AS _gsql2rsql_r_id\n      FROM (\n        SELECT\n           _left_1._gsql2rsql_c_id AS _gsql2rsql_c_id\n          ,_left_1._gsql2rsql_c_name AS _gsql2rsql_c_name\n          ,_left_1._gsql2rsql_c_status AS _gsql2rsql_c_status\n          ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_left_1._gsql2rsql__anon1_purchase_id AS _gsql2rsql__anon1_purchase_id\n          ,_left_1._gsql2rsql_p_id AS _gsql2rsql_p_id\n          ,_right_1._gsql2rsql__anon2_purchase_id AS _gsql2rsql__anon2_purchase_id\n          ,_right_1._gsql2rsql__anon2_return_id AS _gsql2rsql__anon2_return_id\n        FROM (\n          SELECT\n             _left_2._gsql2rsql_c_id AS _gsql2rsql_c_id\n            ,_left_2._gsql2rsql_c_name AS _gsql2rsql_c_name\n            ,_left_2._gsql2rsql_c_status AS _gsql2rsql_c_status\n            ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n            ,_left_2._gsql2rsql__anon1_purchase_id AS _gsql2rsql__anon1_purchase_id\n            ,_right_2._gsql2rsql_p_id AS _gsql2rsql_p_id\n          FROM (\n            SELECT\n               _left_3._gsql2rsql_c_id AS _gsql2rsql_c_id\n              ,_left_3._gsql2rsql_c_name AS _gsql2rsql_c_name\n              ,_left_3._gsql2rsql_c_status AS _gsql2rsql_c_status\n              ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n              ,_right_3._gsql2rsql__anon1_purchase_id AS _gsql2rsql__anon1_purchase_id\n            FROM (\n              SELECT\n                 id AS _gsql2rsql_c_id\n                ,name AS _gsql2rsql_c_name\n                ,status AS _gsql2rsql_c_status\n              FROM\n                catalog.fraud.Customer\n            ) AS _left_3\n            INNER JOIN (\n              SELECT\n                 customer_id AS _gsql2rsql__anon1_customer_id\n                ,purchase_id AS _gsql2rsql__anon1_purchase_id\n              FROM\n                catalog.fraud.CustomerPurchase\n            ) AS _right_3 ON\n              _left_3._gsql2rsql_c_id = _right_3._gsql2rsql__anon1_customer_id\n          ) AS _left_2\n          INNER JOIN (\n            SELECT\n               id AS _gsql2rsql_p_id\n            FROM\n              catalog.fraud.Purchase\n          ) AS _right_2 ON\n            _right_2._gsql2rsql_p_id = _left_2._gsql2rsql__anon1_purchase_id\n        ) AS _left_1\n        INNER JOIN (\n          SELECT\n             purchase_id AS _gsql2rsql__anon2_purchase_id\n            ,return_id AS _gsql2rsql__anon2_return_id\n          FROM\n            catalog.fraud.PurchaseReturn\n        ) AS _right_1 ON\n          _left_1._gsql2rsql_p_id = _right_1._gsql2rsql__anon2_purchase_id\n      ) AS _left_0\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_r_id\n        FROM\n          catalog.fraud.Return\n      ) AS _right_0 ON\n        _right_0._gsql2rsql_r_id = _left_0._gsql2rsql__anon2_return_id\n    ) AS _proj\n    GROUP BY _gsql2rsql_c_id, _gsql2rsql_c_name, _gsql2rsql_c_status\n    HAVING (total_purchases) &gt; (10)\n  ) AS _proj\n  ) AS _filter\n  WHERE (return_rate) &gt; (0.5)\n) AS _proj\nORDER BY return_rate DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: c:Customer\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:MADE_PURCHASE]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: p:Purchase\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:RETURNED]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: r:Return\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=p RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=10;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=r RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=10 Op=ProjectionOperator; InOpIds=9; OutOpIds=11;\n  ProjectionOperator(id=10)\n    Projections: c=c, total_purchases=COUNT(p), total_returns=COUNT(r)\n    Having: (total_purchases GT 10)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=10; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: c=c, total_purchases=total_purchases, total_returns=total_returns, return_rate=((total_returns MULTIPLY 1.0) DIVIDE total_purchases)\n    Having: (return_rate GT 0.5)\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=c.id, name=c.name, total_purchases=total_purchases, total_returns=total_returns, return_rate=return_rate\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#11-detect-bust-out-fraud-with-sudden-spending-spikes-before-default","title":"11. Detect bust-out fraud with sudden spending spikes before default","text":"<p>Application: Fraud: Bust-out fraud</p> Notes <p>Identifies accounts with sudden spending increases before defaulting. Classic bust-out fraud pattern where fraudsters max out credit before disappearing.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:HAS_TRANSACTION]-&gt;(t:Transaction)\nWHERE a.status = 'defaulted' AND t.timestamp &gt; a.default_date - DURATION('P30D')\nWITH a,\n     SUM(CASE WHEN t.timestamp &gt; a.default_date - DURATION('P7D') THEN t.amount ELSE 0 END) AS last_week,\n     SUM(CASE WHEN t.timestamp &lt;= a.default_date - DURATION('P7D') THEN t.amount ELSE 0 END) AS prior_weeks\nWHERE prior_weeks &gt; 0 AND (last_week / prior_weeks) &gt; 5.0\nRETURN a.id, last_week, prior_weeks, (last_week / prior_weeks) AS spike_ratio\nORDER BY spike_ratio DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,last_week AS last_week\n  ,prior_weeks AS prior_weeks\n  ,(last_week) / (prior_weeks) AS spike_ratio\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,SUM(CASE WHEN (_gsql2rsql_t_timestamp) &gt; ((_gsql2rsql_a_default_date) - (INTERVAL 7 DAY)) THEN _gsql2rsql_t_amount ELSE 0 END) AS last_week\n    ,SUM(CASE WHEN (_gsql2rsql_t_timestamp) &lt;= ((_gsql2rsql_a_default_date) - (INTERVAL 7 DAY)) THEN _gsql2rsql_t_amount ELSE 0 END) AS prior_weeks\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_right_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_a_id\n          ,holder_name AS _gsql2rsql_a_holder_name\n          ,risk_score AS _gsql2rsql_a_risk_score\n          ,status AS _gsql2rsql_a_status\n          ,default_date AS _gsql2rsql_a_default_date\n          ,home_country AS _gsql2rsql_a_home_country\n          ,kyc_status AS _gsql2rsql_a_kyc_status\n          ,days_since_creation AS _gsql2rsql_a_days_since_creation\n        FROM\n          catalog.fraud.Account\n        WHERE ((status) = ('defaulted'))\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon1_account_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.AccountTx\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.fraud.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_t_timestamp) &gt; ((_gsql2rsql_a_default_date) - (INTERVAL 30 DAY))\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status\n  HAVING ((prior_weeks) &gt; (0)) AND (((last_week) / (prior_weeks)) &gt; (5.0))\n) AS _proj\nORDER BY spike_ratio DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n    Filter: (a.status EQ 'defaulted')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: a=a, last_week=SUM(CASE WHEN (t.timestamp GT (a.default_date MINUS DURATION('P7D'))) THEN t.amount ELSE 0 END), prior_weeks=SUM(CASE WHEN (t.timestamp LEQ (a.default_date MINUS DURATION('P7D'))) THEN t.amount ELSE 0 END)\n    Filter: (t.timestamp GT (a.default_date MINUS DURATION('P30D')))\n    Having: ((prior_weeks GT 0) AND ((last_week DIVIDE prior_weeks) GT 5.0))\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=a.id, last_week=last_week, prior_weeks=prior_weeks, spike_ratio=(last_week DIVIDE prior_weeks)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#12-find-circular-payment-patterns-indicating-money-laundering","title":"12. Find circular payment patterns indicating money laundering","text":"<p>Application: Fraud: Circular payment detection</p> Notes <p>Detects circular money flows where funds return to origin account. Strong indicator of structuring or layering in money laundering.</p> OpenCypher Query Cypher<pre><code>MATCH path = (a:Account)-[:TRANSFER*4..8]-&gt;(a)\nWHERE ALL(rel IN relationships(path) WHERE rel.amount &gt; 500)\n  AND LENGTH(path) &gt;= 4\nWITH path, REDUCE(total = 0, rel IN relationships(path) | total + rel.amount) AS cycle_amount\nRETURN [node IN nodes(path) | node.id] AS cycle_accounts,\n       LENGTH(path) AS cycle_length,\n       cycle_amount\nORDER BY cycle_amount DESC\nLIMIT 10\n</code></pre> Generated SQL SQL<pre><code>WITH RECURSIVE\n  paths_1 AS (\n    -- Base case: direct edges (depth = 1)\n    SELECT\n      e.source_account_id AS start_node,\n      e.target_account_id AS end_node,\n      1 AS depth,\n      ARRAY(e.source_account_id, e.target_account_id) AS path,\n      ARRAY(NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      ARRAY(e.source_account_id) AS visited\n    FROM catalog.fraud.Transfer e\n    WHERE (e.amount) &gt; (500)\n\n    UNION ALL\n\n    -- Recursive case: extend paths\n    SELECT\n      p.start_node,\n      e.target_account_id AS end_node,\n      p.depth + 1 AS depth,\n      CONCAT(p.path, ARRAY(e.target_account_id)) AS path,\n      ARRAY_APPEND(p.path_edges, NAMED_STRUCT('source_account_id', e.source_account_id, 'target_account_id', e.target_account_id, 'amount', e.amount, 'timestamp', e.timestamp)) AS path_edges,\n      CONCAT(p.visited, ARRAY(e.source_account_id)) AS visited\n    FROM paths_1 p\n    JOIN catalog.fraud.Transfer e\n      ON p.end_node = e.source_account_id\n    WHERE p.depth &lt; 8\n      AND NOT ARRAY_CONTAINS(p.visited, e.target_account_id)\n      AND (e.amount) &gt; (500)\n  )\nSELECT \n   _gsql2rsql_path_id AS cycle_accounts\n  ,(SIZE(_gsql2rsql_path_id) - 1) AS cycle_length\n  ,cycle_amount AS cycle_amount\nFROM (\n  SELECT \n     _gsql2rsql_path_id AS _gsql2rsql_path_id\n    ,AGGREGATE(_gsql2rsql_path_edges, CAST(0 AS DOUBLE), (total, rel) -&gt; (total) + (rel.amount)) AS cycle_amount\n  FROM (\n    SELECT\n       sink.id AS _gsql2rsql_a_id\n      ,sink.holder_name AS _gsql2rsql_a_holder_name\n      ,sink.risk_score AS _gsql2rsql_a_risk_score\n      ,sink.status AS _gsql2rsql_a_status\n      ,sink.default_date AS _gsql2rsql_a_default_date\n      ,sink.home_country AS _gsql2rsql_a_home_country\n      ,sink.kyc_status AS _gsql2rsql_a_kyc_status\n      ,sink.days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,p.start_node\n      ,p.end_node\n      ,p.depth\n      ,p.path AS _gsql2rsql_path_id\n      ,p.path_edges AS _gsql2rsql_path_edges\n    FROM paths_1 p\n    JOIN catalog.fraud.Account sink\n      ON sink.id = p.end_node\n    JOIN catalog.fraud.Account source\n      ON source.id = p.start_node\n    WHERE p.depth &gt;= 4 AND p.depth &lt;= 8 AND p.start_node = p.end_node\n  ) AS _proj\n  WHERE ((SIZE(_gsql2rsql_path_id) - 1)) &gt;= (4)\n) AS _proj\nORDER BY cycle_amount DESC\nLIMIT 10\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=2;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=3)\n    DataSource: a:Account\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=2 Op=RecursiveTraversalOperator; InOpIds=1; OutOpIds=4;\n  RecursiveTraversal(TRANSFER*4..8, path=path, circular=True)\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=2,3; OutOpIds=6;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=paths__anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=4; OutOpIds=7;\n  ProjectionOperator(id=6)\n    Projections: path=path, cycle_amount=REDUCE(total = 0, rel IN RELATIONSHIPS(path) | (total PLUS rel.amount))\n    Filter: (LENGTH(path) GEQ 4)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=6; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: cycle_accounts=[node IN NODES(path) | node.id], cycle_length=LENGTH(path), cycle_amount=cycle_amount\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#13-identify-anomalous-cross-border-transaction-patterns","title":"13. Identify anomalous cross-border transaction patterns","text":"<p>Application: Fraud: Cross-border anomaly</p> Notes <p>Finds accounts with high-value cross-border transaction activity. May indicate trade-based money laundering or sanctions evasion.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:HAS_TRANSACTION]-&gt;(t:Transaction)-[:TO_COUNTRY]-&gt;(c:Country)\nWHERE c.code &lt;&gt; a.home_country AND t.amount &gt; 10000\nWITH a, c, COUNT(t) AS cross_border_count, SUM(t.amount) AS total_amount\nWHERE cross_border_count &gt; 5\nRETURN a.id, c.name AS destination_country, cross_border_count, total_amount\nORDER BY total_amount DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_c_name AS destination_country\n  ,cross_border_count AS cross_border_count\n  ,total_amount AS total_amount\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_gsql2rsql_c_id AS _gsql2rsql_c_id\n    ,COUNT(_gsql2rsql_t_id) AS cross_border_count\n    ,SUM(_gsql2rsql_t_amount) AS total_amount\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n    ,_gsql2rsql_c_code AS _gsql2rsql_c_code\n    ,_gsql2rsql_c_name AS _gsql2rsql_c_name\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_left_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_left_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_left_0._gsql2rsql__anon2_country_id AS _gsql2rsql__anon2_country_id\n      ,_right_0._gsql2rsql_c_id AS _gsql2rsql_c_id\n      ,_right_0._gsql2rsql_c_code AS _gsql2rsql_c_code\n      ,_right_0._gsql2rsql_c_name AS _gsql2rsql_c_name\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n        ,_left_1._gsql2rsql_t_id AS _gsql2rsql_t_id\n        ,_left_1._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n        ,_right_1._gsql2rsql__anon2_country_id AS _gsql2rsql__anon2_country_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_left_2._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n          ,_left_2._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n          ,_left_2._gsql2rsql_a_status AS _gsql2rsql_a_status\n          ,_left_2._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n          ,_left_2._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n          ,_left_2._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n          ,_left_2._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_left_2._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n          ,_right_2._gsql2rsql_t_id AS _gsql2rsql_t_id\n          ,_right_2._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_a_id AS _gsql2rsql_a_id\n            ,_left_3._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n            ,_left_3._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n            ,_left_3._gsql2rsql_a_status AS _gsql2rsql_a_status\n            ,_left_3._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n            ,_left_3._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n            ,_left_3._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n            ,_left_3._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n            ,_right_3._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_a_id\n              ,holder_name AS _gsql2rsql_a_holder_name\n              ,risk_score AS _gsql2rsql_a_risk_score\n              ,status AS _gsql2rsql_a_status\n              ,default_date AS _gsql2rsql_a_default_date\n              ,home_country AS _gsql2rsql_a_home_country\n              ,kyc_status AS _gsql2rsql_a_kyc_status\n              ,days_since_creation AS _gsql2rsql_a_days_since_creation\n            FROM\n              catalog.fraud.Account\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               account_id AS _gsql2rsql__anon1_account_id\n              ,transaction_id AS _gsql2rsql__anon1_transaction_id\n            FROM\n              catalog.fraud.AccountTx\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_a_id = _right_3._gsql2rsql__anon1_account_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_t_id\n            ,amount AS _gsql2rsql_t_amount\n          FROM\n            catalog.fraud.Transaction\n          WHERE ((amount) &gt; (10000))\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_t_id = _left_2._gsql2rsql__anon1_transaction_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           transaction_id AS _gsql2rsql__anon2_transaction_id\n          ,country_id AS _gsql2rsql__anon2_country_id\n        FROM\n          catalog.fraud.TransactionCountry\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_t_id = _right_1._gsql2rsql__anon2_transaction_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_c_id\n        ,code AS _gsql2rsql_c_code\n        ,name AS _gsql2rsql_c_name\n      FROM\n        catalog.fraud.Country\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_c_id = _left_0._gsql2rsql__anon2_country_id\n  ) AS _proj\n  WHERE (_gsql2rsql_c_code) != (_gsql2rsql_a_home_country)\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_c_id, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status, _gsql2rsql_c_code, _gsql2rsql_c_name\n  HAVING (cross_border_count) &gt; (5)\n) AS _proj\nORDER BY total_amount DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n    Filter: (t.amount GT 10000)\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:TO_COUNTRY]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: c:Country\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=c RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: a=a, c=c, cross_border_count=COUNT(t), total_amount=SUM(t.amount)\n    Filter: (c.code NEQ a.home_country)\n    Having: (cross_border_count GT 5)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=a.id, destination_country=c.name, cross_border_count=cross_border_count, total_amount=total_amount\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#14-detect-account-takeover-via-sudden-behavioral-changes","title":"14. Detect account takeover via sudden behavioral changes","text":"<p>Application: Fraud: Account takeover</p> Notes <p>Identifies accounts with dramatic changes in transaction patterns. Sudden increases may indicate account takeover by fraudsters.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:HAS_TRANSACTION]-&gt;(t:Transaction)\nWITH a,\n     AVG(CASE WHEN t.timestamp &lt; TIMESTAMP() - DURATION('P30D') THEN t.amount END) AS avg_30d_ago,\n     AVG(CASE WHEN t.timestamp &gt;= TIMESTAMP() - DURATION('P7D') THEN t.amount END) AS avg_recent\nWHERE avg_30d_ago IS NOT NULL AND avg_recent &gt; avg_30d_ago * 3\nRETURN a.id, avg_30d_ago, avg_recent, (avg_recent / avg_30d_ago) AS behavior_change_ratio\nORDER BY behavior_change_ratio DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,avg_30d_ago AS avg_30d_ago\n  ,avg_recent AS avg_recent\n  ,(avg_recent) / (avg_30d_ago) AS behavior_change_ratio\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,AVG(CAST(CASE WHEN (_gsql2rsql_t_timestamp) &lt; ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY)) THEN _gsql2rsql_t_amount END AS DOUBLE)) AS avg_30d_ago\n    ,AVG(CAST(CASE WHEN (_gsql2rsql_t_timestamp) &gt;= ((CURRENT_TIMESTAMP()) - (INTERVAL 7 DAY)) THEN _gsql2rsql_t_amount END AS DOUBLE)) AS avg_recent\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_0._gsql2rsql_t_timestamp AS _gsql2rsql_t_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_right_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_a_id\n          ,holder_name AS _gsql2rsql_a_holder_name\n          ,risk_score AS _gsql2rsql_a_risk_score\n          ,status AS _gsql2rsql_a_status\n          ,default_date AS _gsql2rsql_a_default_date\n          ,home_country AS _gsql2rsql_a_home_country\n          ,kyc_status AS _gsql2rsql_a_kyc_status\n          ,days_since_creation AS _gsql2rsql_a_days_since_creation\n        FROM\n          catalog.fraud.Account\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon1_account_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.AccountTx\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_t_id\n        ,amount AS _gsql2rsql_t_amount\n        ,timestamp AS _gsql2rsql_t_timestamp\n      FROM\n        catalog.fraud.Transaction\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_t_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status\n  HAVING ((avg_30d_ago) IS NOT NULL) AND ((avg_recent) &gt; ((avg_30d_ago) * (3)))\n) AS _proj\nORDER BY behavior_change_ratio DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=6;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=6 Op=ProjectionOperator; InOpIds=5; OutOpIds=7;\n  ProjectionOperator(id=6)\n    Projections: a=a, avg_30d_ago=AVG(CASE WHEN (t.timestamp LT (DATETIME() MINUS DURATION('P30D'))) THEN t.amount END), avg_recent=AVG(CASE WHEN (t.timestamp GEQ (DATETIME() MINUS DURATION('P7D'))) THEN t.amount END)\n    Having: (IS_NOT_NULL(avg_30d_ago) AND (avg_recent GT (avg_30d_ago MULTIPLY 3)))\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=6; OutOpIds=;\n  ProjectionOperator(id=7)\n    Projections: id=a.id, avg_30d_ago=avg_30d_ago, avg_recent=avg_recent, behavior_change_ratio=(avg_recent DIVIDE avg_30d_ago)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#15-find-smurfing-patterns-with-structured-deposits-below-reporting-thresholds","title":"15. Find smurfing patterns with structured deposits below reporting thresholds","text":"<p>Application: Fraud: Structuring/Smurfing</p> Notes <p>Detects multiple deposits just under regulatory reporting thresholds. Classic smurfing/structuring pattern to avoid currency transaction reports.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:DEPOSIT]-&gt;(d:Transaction)\nWHERE d.amount &gt; 9000 AND d.amount &lt; 10000\n  AND d.timestamp &gt; TIMESTAMP() - DURATION('P30D')\nWITH a, COUNT(d) AS deposit_count, SUM(d.amount) AS total_deposits\nWHERE deposit_count &gt; 5\nRETURN a.id, deposit_count, total_deposits, (total_deposits / deposit_count) AS avg_deposit\nORDER BY deposit_count DESC\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,deposit_count AS deposit_count\n  ,total_deposits AS total_deposits\n  ,(total_deposits) / (deposit_count) AS avg_deposit\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,COUNT(_gsql2rsql_d_id) AS deposit_count\n    ,SUM(_gsql2rsql_d_amount) AS total_deposits\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_right_0._gsql2rsql_d_id AS _gsql2rsql_d_id\n      ,_right_0._gsql2rsql_d_amount AS _gsql2rsql_d_amount\n      ,_right_0._gsql2rsql_d_timestamp AS _gsql2rsql_d_timestamp\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_right_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_right_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      FROM (\n        SELECT\n           id AS _gsql2rsql_a_id\n          ,holder_name AS _gsql2rsql_a_holder_name\n          ,risk_score AS _gsql2rsql_a_risk_score\n          ,status AS _gsql2rsql_a_status\n          ,default_date AS _gsql2rsql_a_default_date\n          ,home_country AS _gsql2rsql_a_home_country\n          ,kyc_status AS _gsql2rsql_a_kyc_status\n          ,days_since_creation AS _gsql2rsql_a_days_since_creation\n        FROM\n          catalog.fraud.Account\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           account_id AS _gsql2rsql__anon1_account_id\n          ,transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM\n          catalog.fraud.AccountDeposit\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_a_id = _right_1._gsql2rsql__anon1_account_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_d_id\n        ,amount AS _gsql2rsql_d_amount\n        ,timestamp AS _gsql2rsql_d_timestamp\n      FROM\n        catalog.fraud.Transaction\n      WHERE (((amount) &gt; (9000)) AND ((amount) &lt; (10000)))\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_d_id = _left_0._gsql2rsql__anon1_transaction_id\n  ) AS _proj\n  WHERE (_gsql2rsql_d_timestamp) &gt; ((CURRENT_TIMESTAMP()) - (INTERVAL 30 DAY))\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status\n  HAVING (deposit_count) &gt; (5)\n) AS _proj\nORDER BY deposit_count DESC\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=4;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:DEPOSIT]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=5;\n  DataSourceOperator(id=3)\n    DataSource: d:Transaction\n    Filter: ((d.amount GT 9000) AND (d.amount LT 10000))\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=4 Op=JoinOperator; InOpIds=1,2; OutOpIds=5;\n  JoinOperator(id=4)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=5 Op=JoinOperator; InOpIds=4,3; OutOpIds=7;\n  JoinOperator(id=5)\n    JoinType: INNER\n    Joins: JoinPair: Node=d RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=7 Op=ProjectionOperator; InOpIds=5; OutOpIds=8;\n  ProjectionOperator(id=7)\n    Projections: a=a, deposit_count=COUNT(d), total_deposits=SUM(d.amount)\n    Filter: (d.timestamp GT (DATETIME() MINUS DURATION('P30D')))\n    Having: (deposit_count GT 5)\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=8 Op=ProjectionOperator; InOpIds=7; OutOpIds=;\n  ProjectionOperator(id=8)\n    Projections: id=a.id, deposit_count=deposit_count, total_deposits=total_deposits, avg_deposit=(total_deposits DIVIDE deposit_count)\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#16-analyze-transaction-volumes-by-merchant-category-for-suspicious-accounts","title":"16. Analyze transaction volumes by merchant category for suspicious accounts","text":"<p>Application: Fraud: Category-based volume analysis</p> Notes <p>Filters accounts by metadata (KYC status, account age) to focus on risky profiles. Aggregates transaction volumes by merchant category to identify unusual spending patterns. New accounts with high volumes in specific categories (e.g., electronics, gift cards) are red flags. Combines vertex filtering with edge aggregation for comprehensive risk assessment.</p> OpenCypher Query Cypher<pre><code>MATCH (a:Account)-[:HAS_TRANSACTION]-&gt;(t:Transaction)-[:AT_MERCHANT]-&gt;(m:Merchant)\nWHERE a.kyc_status = 'incomplete' OR a.days_since_creation &lt; 30\nWITH a,\n     m.category AS merchant_category,\n     COUNT(t) AS transaction_count,\n     SUM(t.amount) AS total_volume,\n     AVG(t.amount) AS avg_transaction\nWHERE transaction_count &gt; 10\nRETURN a.id,\n       a.kyc_status,\n       a.days_since_creation,\n       merchant_category,\n       transaction_count,\n       total_volume,\n       avg_transaction\nORDER BY total_volume DESC\nLIMIT 100\n</code></pre> Generated SQL SQL<pre><code>SELECT \n   _gsql2rsql_a_id AS id\n  ,_gsql2rsql_a_kyc_status AS kyc_status\n  ,_gsql2rsql_a_days_since_creation AS days_since_creation\n  ,merchant_category AS merchant_category\n  ,transaction_count AS transaction_count\n  ,total_volume AS total_volume\n  ,avg_transaction AS avg_transaction\nFROM (\n  SELECT \n     _gsql2rsql_a_id AS _gsql2rsql_a_id\n    ,_gsql2rsql_m_category AS merchant_category\n    ,COUNT(_gsql2rsql_t_id) AS transaction_count\n    ,SUM(_gsql2rsql_t_amount) AS total_volume\n    ,AVG(CAST(_gsql2rsql_t_amount AS DOUBLE)) AS avg_transaction\n    ,_gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n    ,_gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n    ,_gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n    ,_gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n    ,_gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n    ,_gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n    ,_gsql2rsql_a_status AS _gsql2rsql_a_status\n  FROM (\n    SELECT\n       _left_0._gsql2rsql_a_id AS _gsql2rsql_a_id\n      ,_left_0._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n      ,_left_0._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n      ,_left_0._gsql2rsql_a_status AS _gsql2rsql_a_status\n      ,_left_0._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n      ,_left_0._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n      ,_left_0._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n      ,_left_0._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n      ,_left_0._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n      ,_left_0._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n      ,_left_0._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_left_0._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_left_0._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n      ,_left_0._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n      ,_right_0._gsql2rsql_m_id AS _gsql2rsql_m_id\n      ,_right_0._gsql2rsql_m_category AS _gsql2rsql_m_category\n    FROM (\n      SELECT\n         _left_1._gsql2rsql_a_id AS _gsql2rsql_a_id\n        ,_left_1._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n        ,_left_1._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n        ,_left_1._gsql2rsql_a_status AS _gsql2rsql_a_status\n        ,_left_1._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n        ,_left_1._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n        ,_left_1._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n        ,_left_1._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n        ,_left_1._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n        ,_left_1._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n        ,_left_1._gsql2rsql_t_id AS _gsql2rsql_t_id\n        ,_left_1._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n        ,_right_1._gsql2rsql__anon2_transaction_id AS _gsql2rsql__anon2_transaction_id\n        ,_right_1._gsql2rsql__anon2_merchant_id AS _gsql2rsql__anon2_merchant_id\n      FROM (\n        SELECT\n           _left_2._gsql2rsql_a_id AS _gsql2rsql_a_id\n          ,_left_2._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n          ,_left_2._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n          ,_left_2._gsql2rsql_a_status AS _gsql2rsql_a_status\n          ,_left_2._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n          ,_left_2._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n          ,_left_2._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n          ,_left_2._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n          ,_left_2._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n          ,_left_2._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n          ,_right_2._gsql2rsql_t_id AS _gsql2rsql_t_id\n          ,_right_2._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n        FROM (\n          SELECT\n             _left_3._gsql2rsql_a_id AS _gsql2rsql_a_id\n            ,_left_3._gsql2rsql_a_holder_name AS _gsql2rsql_a_holder_name\n            ,_left_3._gsql2rsql_a_risk_score AS _gsql2rsql_a_risk_score\n            ,_left_3._gsql2rsql_a_status AS _gsql2rsql_a_status\n            ,_left_3._gsql2rsql_a_default_date AS _gsql2rsql_a_default_date\n            ,_left_3._gsql2rsql_a_home_country AS _gsql2rsql_a_home_country\n            ,_left_3._gsql2rsql_a_kyc_status AS _gsql2rsql_a_kyc_status\n            ,_left_3._gsql2rsql_a_days_since_creation AS _gsql2rsql_a_days_since_creation\n            ,_right_3._gsql2rsql__anon1_account_id AS _gsql2rsql__anon1_account_id\n            ,_right_3._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n          FROM (\n            SELECT\n               id AS _gsql2rsql_a_id\n              ,holder_name AS _gsql2rsql_a_holder_name\n              ,risk_score AS _gsql2rsql_a_risk_score\n              ,status AS _gsql2rsql_a_status\n              ,default_date AS _gsql2rsql_a_default_date\n              ,home_country AS _gsql2rsql_a_home_country\n              ,kyc_status AS _gsql2rsql_a_kyc_status\n              ,days_since_creation AS _gsql2rsql_a_days_since_creation\n            FROM\n              catalog.fraud.Account\n            WHERE (((kyc_status) = ('incomplete')) OR ((days_since_creation) &lt; (30)))\n          ) AS _left_3\n          INNER JOIN (\n            SELECT\n               account_id AS _gsql2rsql__anon1_account_id\n              ,transaction_id AS _gsql2rsql__anon1_transaction_id\n            FROM\n              catalog.fraud.AccountTx\n          ) AS _right_3 ON\n            _left_3._gsql2rsql_a_id = _right_3._gsql2rsql__anon1_account_id\n        ) AS _left_2\n        INNER JOIN (\n          SELECT\n             id AS _gsql2rsql_t_id\n            ,amount AS _gsql2rsql_t_amount\n          FROM\n            catalog.fraud.Transaction\n        ) AS _right_2 ON\n          _right_2._gsql2rsql_t_id = _left_2._gsql2rsql__anon1_transaction_id\n      ) AS _left_1\n      INNER JOIN (\n        SELECT\n           transaction_id AS _gsql2rsql__anon2_transaction_id\n          ,merchant_id AS _gsql2rsql__anon2_merchant_id\n        FROM\n          catalog.fraud.TransactionMerchant\n      ) AS _right_1 ON\n        _left_1._gsql2rsql_t_id = _right_1._gsql2rsql__anon2_transaction_id\n    ) AS _left_0\n    INNER JOIN (\n      SELECT\n         id AS _gsql2rsql_m_id\n        ,category AS _gsql2rsql_m_category\n      FROM\n        catalog.fraud.Merchant\n    ) AS _right_0 ON\n      _right_0._gsql2rsql_m_id = _left_0._gsql2rsql__anon2_merchant_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_a_id, _gsql2rsql_m_category, _gsql2rsql_a_days_since_creation, _gsql2rsql_a_default_date, _gsql2rsql_a_holder_name, _gsql2rsql_a_home_country, _gsql2rsql_a_kyc_status, _gsql2rsql_a_risk_score, _gsql2rsql_a_status\n  HAVING (transaction_count) &gt; (10)\n) AS _proj\nORDER BY total_volume DESC\nLIMIT 100\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: a:Account\n    Filter: ((a.kyc_status EQ 'incomplete') OR (a.days_since_creation LT 30))\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_TRANSACTION]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: t:Transaction\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:AT_MERCHANT]-&gt;\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: m:Merchant\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=a RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=m RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=ProjectionOperator; InOpIds=9; OutOpIds=12;\n  ProjectionOperator(id=11)\n    Projections: a=a, merchant_category=m.category, transaction_count=COUNT(t), total_volume=SUM(t.amount), avg_transaction=AVG(t.amount)\n    Having: (transaction_count GT 10)\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=12 Op=ProjectionOperator; InOpIds=11; OutOpIds=;\n  ProjectionOperator(id=12)\n    Projections: id=a.id, kyc_status=a.kyc_status, days_since_creation=a.days_since_creation, merchant_category=merchant_category, transaction_count=transaction_count, total_volume=total_volume, avg_transaction=avg_transaction\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"examples/fraud/#17-detect-shared-card-usage-across-blacklisted-and-verified-customers","title":"17. Detect shared card usage across blacklisted and verified customers","text":"<p>Application: Fraud: Card contamination tracking</p> Notes <p>Identifies cards shared between blacklisted and verified customers (contamination). Uses customer status metadata to filter and categorize relationships. Calculates total transaction metrics to assess card usage impact. Critical for identifying compromised cards or insider fraud networks.</p> OpenCypher Query Cypher<pre><code>MATCH (blacklisted:Customer)-[:HAS_CARD]-&gt;(card:Card)&lt;-[:HAS_CARD]-(verified:Customer)\nWHERE blacklisted.status = 'blacklisted' AND verified.status = 'verified'\nWITH card,\n     COLLECT(DISTINCT blacklisted.id) AS blacklisted_customers,\n     COLLECT(DISTINCT verified.id) AS verified_customers\nMATCH (card)-[:USED_IN]-&gt;(t:Transaction)\nWITH card,\n     blacklisted_customers,\n     verified_customers,\n     COUNT(t) AS total_transactions,\n     SUM(t.amount) AS total_amount\nRETURN card.number,\n       SIZE(blacklisted_customers) AS blacklisted_count,\n       SIZE(verified_customers) AS verified_count,\n       total_transactions,\n       total_amount,\n       blacklisted_customers,\n       verified_customers\nORDER BY total_amount DESC\nLIMIT 25\n</code></pre> Generated SQL SQL<pre><code>WITH\nagg_boundary_1 AS (\n  SELECT\n    _gsql2rsql_card_id AS `card`,\n    COLLECT_LIST(DISTINCT _gsql2rsql_blacklisted_id) AS `blacklisted_customers`,\n    COLLECT_LIST(DISTINCT _gsql2rsql_verified_id) AS `verified_customers`\n  FROM (\n  SELECT\n     _left_0._gsql2rsql_blacklisted_id AS _gsql2rsql_blacklisted_id\n    ,_left_0._gsql2rsql_blacklisted_status AS _gsql2rsql_blacklisted_status\n    ,_left_0._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n    ,_left_0._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n    ,_left_0._gsql2rsql_card_id AS _gsql2rsql_card_id\n    ,_left_0._gsql2rsql_card_number AS _gsql2rsql_card_number\n    ,_left_0._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n    ,_left_0._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n    ,_right_0._gsql2rsql_verified_id AS _gsql2rsql_verified_id\n    ,_right_0._gsql2rsql_verified_status AS _gsql2rsql_verified_status\n  FROM (\n    SELECT\n       _left_1._gsql2rsql_blacklisted_id AS _gsql2rsql_blacklisted_id\n      ,_left_1._gsql2rsql_blacklisted_status AS _gsql2rsql_blacklisted_status\n      ,_left_1._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n      ,_left_1._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_left_1._gsql2rsql_card_id AS _gsql2rsql_card_id\n      ,_left_1._gsql2rsql_card_number AS _gsql2rsql_card_number\n      ,_right_1._gsql2rsql__anon2_customer_id AS _gsql2rsql__anon2_customer_id\n      ,_right_1._gsql2rsql__anon2_card_id AS _gsql2rsql__anon2_card_id\n    FROM (\n      SELECT\n         _left_2._gsql2rsql_blacklisted_id AS _gsql2rsql_blacklisted_id\n        ,_left_2._gsql2rsql_blacklisted_status AS _gsql2rsql_blacklisted_status\n        ,_left_2._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n        ,_left_2._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_right_2._gsql2rsql_card_id AS _gsql2rsql_card_id\n        ,_right_2._gsql2rsql_card_number AS _gsql2rsql_card_number\n      FROM (\n        SELECT\n           _left_3._gsql2rsql_blacklisted_id AS _gsql2rsql_blacklisted_id\n          ,_left_3._gsql2rsql_blacklisted_status AS _gsql2rsql_blacklisted_status\n          ,_right_3._gsql2rsql__anon1_customer_id AS _gsql2rsql__anon1_customer_id\n          ,_right_3._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_blacklisted_id\n            ,status AS _gsql2rsql_blacklisted_status\n          FROM\n            catalog.fraud.Customer\n          WHERE ((status) = ('blacklisted'))\n        ) AS _left_3\n        INNER JOIN (\n          SELECT\n             customer_id AS _gsql2rsql__anon1_customer_id\n            ,card_id AS _gsql2rsql__anon1_card_id\n          FROM\n            catalog.fraud.CustomerCard\n        ) AS _right_3 ON\n          _left_3._gsql2rsql_blacklisted_id = _right_3._gsql2rsql__anon1_customer_id\n      ) AS _left_2\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_card_id\n          ,number AS _gsql2rsql_card_number\n        FROM\n          catalog.fraud.Card\n      ) AS _right_2 ON\n        _right_2._gsql2rsql_card_id = _left_2._gsql2rsql__anon1_card_id\n    ) AS _left_1\n    INNER JOIN (\n      SELECT\n         customer_id AS _gsql2rsql__anon2_customer_id\n        ,card_id AS _gsql2rsql__anon2_card_id\n      FROM\n        catalog.fraud.CustomerCard\n    ) AS _right_1 ON\n      _left_1._gsql2rsql_card_id = _right_1._gsql2rsql__anon2_card_id\n  ) AS _left_0\n  INNER JOIN (\n    SELECT\n       id AS _gsql2rsql_verified_id\n      ,status AS _gsql2rsql_verified_status\n    FROM\n      catalog.fraud.Customer\n    WHERE ((status) = ('verified'))\n  ) AS _right_0 ON\n    _right_0._gsql2rsql_verified_id = _left_0._gsql2rsql__anon2_customer_id\n  ) AS _agg_input\n  GROUP BY _gsql2rsql_card_id\n)\nSELECT \n   _gsql2rsql_card_number AS number\n  ,SIZE(blacklisted_customers) AS blacklisted_count\n  ,SIZE(verified_customers) AS verified_count\n  ,total_transactions AS total_transactions\n  ,total_amount AS total_amount\n  ,blacklisted_customers AS blacklisted_customers\n  ,verified_customers AS verified_customers\nFROM (\n  SELECT \n     _gsql2rsql_card_id AS _gsql2rsql_card_id\n    ,blacklisted_customers AS blacklisted_customers\n    ,verified_customers AS verified_customers\n    ,COUNT(_gsql2rsql_t_id) AS total_transactions\n    ,SUM(_gsql2rsql_t_amount) AS total_amount\n    ,_gsql2rsql_card_number AS _gsql2rsql_card_number\n  FROM (\n    SELECT\n       _left_5.`card` AS `card`\n      ,_left_5.`blacklisted_customers` AS `blacklisted_customers`\n      ,_left_5.`verified_customers` AS `verified_customers`\n      ,_right_5._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n      ,_right_5._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      ,_right_5._gsql2rsql_t_id AS _gsql2rsql_t_id\n      ,_right_5._gsql2rsql_card_id AS _gsql2rsql_card_id\n      ,_right_5._gsql2rsql_card_number AS _gsql2rsql_card_number\n      ,_right_5._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n    FROM (\n      SELECT\n         `card`\n        ,`blacklisted_customers`\n        ,`verified_customers`\n      FROM agg_boundary_1\n    ) AS _left_5\n    INNER JOIN (\n      SELECT\n         _left_6._gsql2rsql_card_id AS _gsql2rsql_card_id\n        ,_left_6._gsql2rsql_card_number AS _gsql2rsql_card_number\n        ,_left_6._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n        ,_left_6._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n        ,_right_6._gsql2rsql_t_id AS _gsql2rsql_t_id\n        ,_right_6._gsql2rsql_t_amount AS _gsql2rsql_t_amount\n      FROM (\n        SELECT\n           _left_7._gsql2rsql_card_id AS _gsql2rsql_card_id\n          ,_left_7._gsql2rsql_card_number AS _gsql2rsql_card_number\n          ,_right_7._gsql2rsql__anon1_card_id AS _gsql2rsql__anon1_card_id\n          ,_right_7._gsql2rsql__anon1_transaction_id AS _gsql2rsql__anon1_transaction_id\n        FROM (\n          SELECT\n             id AS _gsql2rsql_card_id\n            ,number AS _gsql2rsql_card_number\n          FROM\n            catalog.fraud.Card\n        ) AS _left_7\n        INNER JOIN (\n          SELECT\n             card_id AS _gsql2rsql__anon1_card_id\n            ,transaction_id AS _gsql2rsql__anon1_transaction_id\n          FROM\n            catalog.fraud.CardTransaction\n        ) AS _right_7 ON\n          _left_7._gsql2rsql_card_id = _right_7._gsql2rsql__anon1_card_id\n      ) AS _left_6\n      INNER JOIN (\n        SELECT\n           id AS _gsql2rsql_t_id\n          ,amount AS _gsql2rsql_t_amount\n        FROM\n          catalog.fraud.Transaction\n      ) AS _right_6 ON\n        _right_6._gsql2rsql_t_id = _left_6._gsql2rsql__anon1_transaction_id\n    ) AS _right_5 ON\n      _left_5.`card` = _right_5._gsql2rsql_card_id\n  ) AS _proj\n  GROUP BY _gsql2rsql_card_id, blacklisted_customers, verified_customers, _gsql2rsql_card_number\n) AS _proj\nORDER BY total_amount DESC\nLIMIT 25\n</code></pre> Logical Plan Text Only<pre><code>Level 0:\n----------------------------------------------------------------------\nOpId=1 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=1)\n    DataSource: blacklisted:Customer\n    Filter: (blacklisted.status EQ 'blacklisted')\n*\nOpId=2 Op=DataSourceOperator; InOpIds=; OutOpIds=6;\n  DataSourceOperator(id=2)\n    DataSource: [_anon1:HAS_CARD]-&gt;\n*\nOpId=3 Op=DataSourceOperator; InOpIds=; OutOpIds=7;\n  DataSourceOperator(id=3)\n    DataSource: card:Card\n*\nOpId=4 Op=DataSourceOperator; InOpIds=; OutOpIds=8;\n  DataSourceOperator(id=4)\n    DataSource: [_anon2:HAS_CARD]&lt;-\n*\nOpId=5 Op=DataSourceOperator; InOpIds=; OutOpIds=9;\n  DataSourceOperator(id=5)\n    DataSource: verified:Customer\n    Filter: (verified.status EQ 'verified')\n*\nOpId=12 Op=DataSourceOperator; InOpIds=; OutOpIds=15;\n  DataSourceOperator(id=12)\n    DataSource: card:Card\n*\nOpId=13 Op=DataSourceOperator; InOpIds=; OutOpIds=15;\n  DataSourceOperator(id=13)\n    DataSource: [_anon1:USED_IN]-&gt;\n*\nOpId=14 Op=DataSourceOperator; InOpIds=; OutOpIds=16;\n  DataSourceOperator(id=14)\n    DataSource: t:Transaction\n*\n----------------------------------------------------------------------\nLevel 1:\n----------------------------------------------------------------------\nOpId=6 Op=JoinOperator; InOpIds=1,2; OutOpIds=7;\n  JoinOperator(id=6)\n    JoinType: INNER\n    Joins: JoinPair: Node=blacklisted RelOrNode=_anon1 Type=SOURCE\n*\nOpId=15 Op=JoinOperator; InOpIds=12,13; OutOpIds=16;\n  JoinOperator(id=15)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon1 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 2:\n----------------------------------------------------------------------\nOpId=7 Op=JoinOperator; InOpIds=6,3; OutOpIds=8;\n  JoinOperator(id=7)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon1 Type=SINK\n*\nOpId=16 Op=JoinOperator; InOpIds=15,14; OutOpIds=17;\n  JoinOperator(id=16)\n    JoinType: INNER\n    Joins: JoinPair: Node=t RelOrNode=_anon1 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 3:\n----------------------------------------------------------------------\nOpId=8 Op=JoinOperator; InOpIds=7,4; OutOpIds=9;\n  JoinOperator(id=8)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=_anon2 Type=SINK\n*\n----------------------------------------------------------------------\nLevel 4:\n----------------------------------------------------------------------\nOpId=9 Op=JoinOperator; InOpIds=8,5; OutOpIds=11;\n  JoinOperator(id=9)\n    JoinType: INNER\n    Joins: JoinPair: Node=verified RelOrNode=_anon2 Type=SOURCE\n*\n----------------------------------------------------------------------\nLevel 5:\n----------------------------------------------------------------------\nOpId=11 Op=AggregationBoundaryOperator; InOpIds=9; OutOpIds=17;\n  AggregationBoundaryOperator(id=11)\n    GroupBy: [card]\n    Aggregates: [blacklisted_customers, verified_customers]\n*\n----------------------------------------------------------------------\nLevel 6:\n----------------------------------------------------------------------\nOpId=17 Op=JoinOperator; InOpIds=11,16; OutOpIds=18;\n  JoinOperator(id=17)\n    JoinType: INNER\n    Joins: JoinPair: Node=card RelOrNode=agg_boundary_1 Type=NODE_ID\n*\n----------------------------------------------------------------------\nLevel 7:\n----------------------------------------------------------------------\nOpId=18 Op=ProjectionOperator; InOpIds=17; OutOpIds=19;\n  ProjectionOperator(id=18)\n    Projections: card=card, blacklisted_customers=blacklisted_customers, verified_customers=verified_customers, total_transactions=COUNT(t), total_amount=SUM(t.amount)\n*\n----------------------------------------------------------------------\nLevel 8:\n----------------------------------------------------------------------\nOpId=19 Op=ProjectionOperator; InOpIds=18; OutOpIds=;\n  ProjectionOperator(id=19)\n    Projections: number=card.number, blacklisted_count=SIZE(blacklisted_customers), verified_count=SIZE(verified_customers), total_transactions=total_transactions, total_amount=total_amount, blacklisted_customers=blacklisted_customers, verified_customers=verified_customers\n*\n----------------------------------------------------------------------\n</code></pre>"},{"location":"includes/inspiration/","title":"Inspiration","text":""},{"location":"includes/inspiration/#inspiration-and-design-differences","title":"Inspiration and Design Differences","text":"<p>gsql2rsql was inspired by the Microsoft openCypherTranspiler, a C# project for transpiling OpenCypher to T-SQL (now discontinued). While the core idea is similar\u2014translating Cypher graph queries to SQL\u2014gsql2rsql introduces several key architectural differences:</p> <ul> <li> <p>Stricter Phase Separation:   gsql2rsql enforces a much stronger separation between the phases of the transpiler pipeline (Parser, Planner, Resolver, Renderer). Each phase has a single responsibility, and the renderer is intentionally kept as \"dumb\" as possible, only emitting SQL from fully-resolved logical plans. This separation makes the codebase easier to maintain, test, and extend.</p> </li> <li> <p>Human-Friendly Debugging:   The architecture is designed for transparency and developer experience. For example, error messages during development are rich and actionable, showing available variables, suggestions, and hints. See the example below:</p> Text Only<pre><code>Makefile:55: warning: ignoring old recipe for target 'test-pyspark-quick'\nTesting recursive query transpilation...\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 ColumnResolutionError: Variable 'rels' is not defined                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2501\u2501\u2501 Query \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n    1 \u2502 MATCH path = (root:Vertex)-[rels:REL*1..5]-(n:Vertex) WHERE root.node_id = '1234_algo' AND n.node_type = 'node_type' AND NONE(r IN rels WHERE r.relationship_type IN ['a', 'b']) RETURN rels AS edges, n AS vertex_info\n      \u2502                             \u25b2\n      \u2502                             \u2514\u2500\u2500 ERROR: Variable 'rels' is not defined\n    2 \u2502\n\n\u2501\u2501\u2501 Available Variables (Scope Level 0) \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Name         Type      Data Type   Defined At              Properties\n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  root         entity   Vertex       MATCH (root:Vertex)      node_type, metadata, node_id\n  path         path     PATH         MATCH path = ...         -\n  n            entity   Vertex       MATCH (n:Vertex)         node_type, metadata, node_id\n  edges        value    unknown      RETURN/WITH AS edges     -\n  vertex_info  value    Vertex       RETURN/WITH AS vertex_info -\n\n\u2501\u2501\u2501 Suggestions \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \u2022 Did you mean 'root'? (3 characters difference)\n\n\u2501\u2501\u2501 Hints \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  \ud83d\udca1 Make sure 'rels' is defined in a MATCH clause before use.\n     Variables must be defined before they can be referenced in WHERE, WITH, or RETURN clauses.\n\n\u2501\u2501\u2501 Debug Information \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n  Operator:         ProjectionOperator (id=6)\n  Resolution Phase: expression_resolution\n  Symbol Table:\n    Symbol Table Dump:\n      Scope 0 (global):\n        root: entity(Vertex) @ scope 0\n        path: path(PATH) @ scope 0\n        n: entity(Vertex) @ scope 0\n        edges: value(unknown) @ scope 0\n        vertex_info: value(Vertex) @ scope 0\n</code></pre> </li> </ul>"}]}