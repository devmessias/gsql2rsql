# Credit Analysis Query Examples for OpenCypher to Databricks SQL Transpiler
# These examples demonstrate credit risk assessment and financial analytics patterns

# Schema definition for credit analysis examples
schema:
  nodes:
    - name: Customer
      tableName: catalog.credit.Customer
      idProperty: { name: id, type: int }
      properties:
        - { name: name, type: string }
        - { name: status, type: string }

    - name: Account
      tableName: catalog.credit.Account
      idProperty: { name: id, type: int }
      properties:
        - { name: balance, type: float }
        - { name: customer_id, type: int }

    - name: Transaction
      tableName: catalog.credit.Transaction
      idProperty: { name: id, type: int }
      properties:
        - { name: amount, type: float }
        - { name: timestamp, type: string }
        - { name: type, type: string }
        - { name: category, type: string }

    - name: Loan
      tableName: catalog.credit.Loan
      idProperty: { name: id, type: int }
      properties:
        - { name: amount, type: float }
        - { name: balance, type: float }
        - { name: interest_rate, type: float }
        - { name: status, type: string }
        - { name: origination_date, type: string }

    - name: Payment
      tableName: catalog.credit.Payment
      idProperty: { name: id, type: int }
      properties:
        - { name: amount, type: float }
        - { name: timestamp, type: string }
        - { name: on_time, type: boolean }

    - name: CreditCard
      tableName: catalog.credit.CreditCard
      idProperty: { name: id, type: int }
      properties:
        - { name: credit_limit, type: float }
        - { name: number, type: string }

  edges:
    - name: HAS_ACCOUNT
      sourceNode: Customer
      sinkNode: Account
      tableName: catalog.credit.CustomerAccount
      sourceIdProperty: { name: customer_id, type: int }
      sinkIdProperty: { name: account_id, type: int }

    - name: TRANSACTION
      sourceNode: Account
      sinkNode: Transaction
      tableName: catalog.credit.AccountTransaction
      sourceIdProperty: { name: account_id, type: int }
      sinkIdProperty: { name: transaction_id, type: int }

    - name: HAS_LOAN
      sourceNode: Customer
      sinkNode: Loan
      tableName: catalog.credit.CustomerLoan
      sourceIdProperty: { name: customer_id, type: int }
      sinkIdProperty: { name: loan_id, type: int }

    - name: PAYMENT
      sourceNode: Loan
      sinkNode: Payment
      tableName: catalog.credit.LoanPayment
      sourceIdProperty: { name: loan_id, type: int }
      sinkIdProperty: { name: payment_id, type: int }

    - name: TRANSFER
      sourceNode: Account
      sinkNode: Account
      tableName: catalog.credit.Transfer
      sourceIdProperty: { name: source_account_id, type: int }
      sinkIdProperty: { name: target_account_id, type: int }
      properties:
        - { name: amount, type: float }
        - { name: timestamp, type: string }

    - name: HAS_CARD
      sourceNode: Customer
      sinkNode: CreditCard
      tableName: catalog.credit.CustomerCard
      sourceIdProperty: { name: customer_id, type: int }
      sinkIdProperty: { name: card_id, type: int }

    - name: KNOWS
      sourceNode: Customer
      sinkNode: Customer
      tableName: catalog.credit.CustomerKnows
      sourceIdProperty: { name: customer_id, type: int }
      sinkIdProperty: { name: knows_customer_id, type: int }

    - name: CO_BORROWER
      sourceNode: Customer
      sinkNode: Loan
      tableName: catalog.credit.CoBorrower
      sourceIdProperty: { name: customer_id, type: int }
      sinkIdProperty: { name: loan_id, type: int }

    - name: CARD_TRANSACTION
      sourceNode: CreditCard
      sinkNode: Transaction
      tableName: catalog.credit.CardTransaction
      sourceIdProperty: { name: card_id, type: int }
      sinkIdProperty: { name: transaction_id, type: int }

examples:
  - description: "Calculate credit risk scores based on transaction history"
    application: "Credit: Risk scoring"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)-[:TRANSACTION]->(t:Transaction)
      WHERE t.timestamp > TIMESTAMP() - DURATION('P90D')
      WITH c, a,
           COUNT(t) AS tx_count,
           AVG(t.amount) AS avg_transaction,
           SUM(CASE WHEN t.type = 'overdraft' THEN 1 ELSE 0 END) AS overdraft_count
      RETURN c.id, c.name,
             tx_count,
             avg_transaction,
             overdraft_count,
             (overdraft_count * 1.0 / tx_count) AS overdraft_rate
      ORDER BY overdraft_rate DESC
    notes: |
      **Use case:** Banks use overdraft frequency as a key behavioral signal in
      internal credit scoring models (e.g., FICO Behavioral Score). A high
      overdraft rate over 90 days often triggers watchlist placement or
      preemptive credit line reduction.

      **Interpreting results:** `overdraft_rate` close to 0 means healthy account
      usage. Rates above 0.05 (5%) warrant review; above 0.15 typically triggers
      risk mitigation actions. Combine with `avg_transaction` to distinguish
      between high-volume customers with occasional overdrafts vs. chronically
      underfunded accounts.

  - description: "Identify credit-worthy customers via payment consistency"
    application: "Credit: Payment reliability assessment"
    query: |
      MATCH (c:Customer)-[:HAS_LOAN]->(l:Loan)-[:PAYMENT]->(p:Payment)
      WHERE l.status = 'active'
      WITH c, l,
           COUNT(p) AS total_payments,
           SUM(CASE WHEN p.on_time = true THEN 1 ELSE 0 END) AS on_time_payments
      WHERE total_payments > 6
      WITH c, l, total_payments, on_time_payments,
           (on_time_payments * 1.0 / total_payments) AS on_time_rate
      WHERE on_time_rate > 0.95
      RETURN c.id, c.name, l.amount, on_time_rate, total_payments
      ORDER BY l.amount DESC
    notes: |
      **Use case:** Credit line increase programs target customers with proven
      repayment discipline. Lenders use on-time payment ratios (>95% over 6+
      payments) as a primary criterion for automatic limit upgrades, reducing
      manual underwriting costs.

      **Interpreting results:** `on_time_rate` of 1.0 means perfect payment
      history. The query pre-filters to >0.95, so all results are strong
      candidates. Sort by `l.amount` to prioritize customers with larger
      existing loans, as they represent the most significant upsell opportunity.

  - description: "Trace debt consolidation opportunities via multiple loan analysis"
    application: "Credit: Debt consolidation"
    query: |
      MATCH (c:Customer)-[:HAS_LOAN]->(l:Loan)
      WHERE l.status = 'active'
      WITH c, COUNT(l) AS active_loans, SUM(l.balance) AS total_debt, AVG(l.interest_rate) AS avg_rate
      WHERE active_loans >= 3 AND total_debt > 10000
      RETURN c.id, c.name, active_loans, total_debt, avg_rate
      ORDER BY total_debt DESC
    notes: |
      **Use case:** Debt consolidation is a common retention strategy in
      consumer lending. Customers juggling 3+ loans at varying rates are at
      higher default risk due to payment complexity. Offering a single
      consolidated loan at a competitive rate reduces churn and simplifies
      collections.

      **Interpreting results:** `active_loans >= 3` with `total_debt > 10000`
      flags high-burden customers. Compare `avg_rate` against your current
      consolidation product rate; if `avg_rate` is significantly higher,
      the customer has a strong financial incentive to consolidate.

  - description: "Predict default probability using behavioral patterns"
    application: "Credit: Default prediction"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)-[:TRANSACTION]->(t:Transaction)
      WHERE t.timestamp > TIMESTAMP() - DURATION('P60D')
      WITH c, a,
           COUNT(CASE WHEN t.type = 'NSF' THEN 1 END) AS nsf_count,
           COUNT(CASE WHEN t.type = 'late_fee' THEN 1 END) AS late_fee_count,
           MIN(a.balance) AS min_balance
      WHERE nsf_count > 2 OR late_fee_count > 3 OR min_balance < 0
      RETURN c.id, c.name, nsf_count, late_fee_count, min_balance,
             (nsf_count + late_fee_count * 2) AS default_risk_score
      ORDER BY default_risk_score DESC
    notes: |
      **Use case:** Early default detection models combine NSF (Non-Sufficient
      Funds) events, late fees, and negative balances as leading indicators.
      These behavioral signals often precede default by 30-90 days, giving
      collections teams time for proactive outreach (payment plans, forbearance).

      **Interpreting results:** `default_risk_score` weights late fees at 2x
      because they indicate systemic payment failure, not just momentary
      insufficient funds. A score above 5 is a strong default signal.
      `min_balance < 0` alone (negative balance) is a severe indicator even
      with low NSF/late counts.

  - description: "Analyze transaction chains to assess liquidity patterns"
    application: "Credit: Liquidity assessment"
    query: |
      MATCH path = (source:Account)-[:TRANSFER*1..3]->(sink:Account)
      WHERE source.customer_id = sink.customer_id
        AND ALL(rel IN relationships(path) WHERE rel.timestamp > TIMESTAMP() - DURATION('P30D'))
      WITH source.customer_id AS customer_id,
           COUNT(DISTINCT path) AS transfer_chains,
           AVG(LENGTH(path)) AS avg_chain_length
      RETURN customer_id, transfer_chains, avg_chain_length
      ORDER BY transfer_chains DESC
      LIMIT 20
    notes: |
      **Use case:** Internal transfer chains (account-to-account within the same
      customer) are a known liquidity stress signal. Treasury and risk teams
      monitor these patterns to detect "kiting" behavior or cash flow
      juggling that precedes overdrafts or missed payments.

      **Interpreting results:** `transfer_chains` counts distinct multi-hop
      transfer paths. High counts (top 20) with `avg_chain_length > 2`
      suggest the customer is actively moving money across accounts to cover
      shortfalls. A single direct transfer (chain length 1) is normal;
      chains of 3 hops indicate complex liquidity management.

  - description: "Find high-value customers for premium credit products"
    application: "Credit: Customer segmentation"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)-[:TRANSACTION]->(t:Transaction)
      WHERE t.timestamp > TIMESTAMP() - DURATION('P180D')
      WITH c, SUM(t.amount) AS total_volume, AVG(a.balance) AS avg_balance, COUNT(DISTINCT a) AS account_count
      WHERE total_volume > 100000 AND avg_balance > 10000
      RETURN c.id, c.name, total_volume, avg_balance, account_count
      ORDER BY total_volume DESC
    notes: |
      **Use case:** Customer segmentation for premium products (e.g., platinum
      cards, private banking) requires identifying high-value relationships.
      Customers with >100K transaction volume and >10K average balance over
      6 months represent the top tier for targeted premium offers.

      **Interpreting results:** `total_volume` reflects transactional engagement,
      while `avg_balance` reflects deposit stability. The ideal premium
      candidate has both high volume AND high balance. `account_count > 1`
      indicates a multi-product relationship, making the customer stickier
      and more receptive to additional offerings.

  - description: "Detect early warning signs of financial distress"
    application: "Credit: Early warning system"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)-[:TRANSACTION]->(t:Transaction)
      WITH c, a,
           AVG(CASE WHEN t.timestamp > TIMESTAMP() - DURATION('P7D') THEN a.balance END) AS recent_avg,
           AVG(CASE WHEN t.timestamp <= TIMESTAMP() - DURATION('P30D') AND t.timestamp > TIMESTAMP() - DURATION('P60D') THEN a.balance END) AS historical_avg
      WHERE historical_avg > 0 AND recent_avg < historical_avg * 0.5
      RETURN c.id, c.name, historical_avg, recent_avg,
             ((historical_avg - recent_avg) / historical_avg) AS balance_decline_pct
      ORDER BY balance_decline_pct DESC
    notes: |
      **Use case:** Balance velocity monitoring is a core component of early
      warning systems (EWS) in commercial and retail banking. A >50% balance
      decline in 7 days vs. the 30-60 day historical average triggers alerts
      for relationship managers, enabling proactive intervention before
      missed payments occur.

      **Interpreting results:** `balance_decline_pct` measures relative drop;
      0.5 means balance halved, 0.8 means 80% decline. High values ordered
      DESC surface the most urgent cases first. Note that the query compares
      7-day recent vs. 30-60 day historical window, avoiding seasonal noise
      from the most recent month.

  - description: "Assess creditworthiness via social network analysis"
    application: "Credit: Network-based scoring"
    query: |
      MATCH (c:Customer)-[:KNOWS*1..2]-(peer:Customer)-[:HAS_LOAN]->(l:Loan)
      WHERE l.status = 'defaulted'
      WITH c, COUNT(DISTINCT peer) AS defaulted_peers, COUNT(DISTINCT l) AS defaulted_loans
      WHERE defaulted_peers > 0
      RETURN c.id, c.name, defaulted_peers, defaulted_loans,
             (defaulted_peers * 1.0) AS network_risk_score
      ORDER BY network_risk_score DESC
    notes: |
      **Use case:** Network-based credit scoring leverages graph relationships
      to assess "guilt by association." Research shows that borrowers within
      1-2 hops of defaulted peers have 2-3x higher default probability.
      This is used as an auxiliary signal in credit decisioning, not as a
      standalone criterion.

      **Interpreting results:** `defaulted_peers` counts distinct individuals
      within 2 hops who have defaulted loans. `defaulted_loans` can be higher
      if a single peer has multiple defaults. The undirected KNOWS relationship
      captures bidirectional social ties. Customers with `defaulted_peers >= 3`
      should be flagged for enhanced due diligence.

  - description: "Calculate debt-to-income ratio estimates from transaction data"
    application: "Credit: DTI estimation"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)-[:TRANSACTION]->(t:Transaction)
      WHERE t.timestamp > TIMESTAMP() - DURATION('P90D')
      WITH c,
           SUM(CASE WHEN t.category = 'income' THEN t.amount ELSE 0 END) AS income,
           SUM(CASE WHEN t.category = 'debt_payment' THEN t.amount ELSE 0 END) AS debt_payments
      WHERE income > 0
      RETURN c.id, c.name, income, debt_payments,
             (debt_payments * 1.0 / income) AS estimated_dti
      ORDER BY estimated_dti DESC
    notes: |
      **Use case:** Debt-to-income ratio (DTI) is a regulatory requirement
      for mortgage lending (Qualified Mortgage rules cap DTI at 43%) and a
      key underwriting metric for all consumer credit. This query estimates
      DTI from transaction data when formal income documentation is unavailable,
      enabling faster pre-qualification.

      **Interpreting results:** `estimated_dti` below 0.36 is generally
      considered healthy. Between 0.36-0.43 is borderline. Above 0.43 exceeds
      the QM threshold and indicates the customer may be overleveraged.
      Results sorted DESC surface the highest-risk customers first.

  - description: "Find cross-sell opportunities for additional credit products"
    application: "Credit: Cross-sell targeting"
    query: |
      MATCH (c:Customer)-[:HAS_ACCOUNT]->(a:Account)
      WHERE NOT (c)-[:HAS_LOAN]->(:Loan) AND a.balance > 5000
      WITH c, AVG(a.balance) AS avg_balance, COUNT(a) AS account_count
      WHERE account_count >= 2
      RETURN c.id, c.name, avg_balance, account_count
      ORDER BY avg_balance DESC
      LIMIT 50
    notes: |
      **Use case:** Cross-sell analytics identify untapped revenue from existing
      deposit customers. Customers with no loan products but high deposit
      balances across multiple accounts represent low-risk lending prospects,
      since the bank already holds their primary financial relationship.

      **Interpreting results:** `avg_balance > 5000` with `account_count >= 2`
      indicates a sticky, multi-product deposit customer. These customers have
      low acquisition cost for lending products. The LIMIT 50 focuses outreach
      on the top tier. The EXISTS-NOT pattern (`NOT (c)-[:HAS_LOAN]->(:Loan)`)
      is key: it filters out customers who already have loans.

  - description: "Analyze payment velocity to detect cash flow improvements"
    application: "Credit: Payment velocity analysis"
    query: |
      MATCH (c:Customer)-[:HAS_LOAN]->(l:Loan)-[:PAYMENT]->(p:Payment)
      WHERE p.timestamp > TIMESTAMP() - DURATION('P180D')
      WITH c, l,
           AVG(CASE WHEN p.timestamp > TIMESTAMP() - DURATION('P30D') THEN p.amount END) AS recent_avg,
           AVG(CASE WHEN p.timestamp <= TIMESTAMP() - DURATION('P90D') THEN p.amount END) AS historical_avg
      WHERE historical_avg > 0 AND recent_avg > historical_avg * 1.2
      RETURN c.id, c.name, l.id AS loan_id, historical_avg, recent_avg,
             ((recent_avg - historical_avg) / historical_avg) AS payment_increase_pct
      ORDER BY payment_increase_pct DESC
    notes: |
      **Use case:** Payment velocity analysis detects improving financial health.
      Customers who increase payment amounts by >20% are likely experiencing
      income growth or improved cash flow. This is used to identify candidates
      for credit line increases or refinancing to a larger loan amount.

      **Interpreting results:** `payment_increase_pct` of 0.2 means 20% increase
      in recent vs. historical payment amounts. Higher values indicate
      stronger improvement. This is a positive signal -- opposite of the
      early warning query. Combine with DTI data to confirm that increased
      payments reflect improved capacity, not desperation to pay down debt.

  - description: "Identify customers suitable for credit line decreases"
    application: "Credit: Risk mitigation"
    query: |
      MATCH (c:Customer)-[:HAS_CARD]->(card:CreditCard)-[:CARD_TRANSACTION]->(t:Transaction)
      WHERE t.timestamp > TIMESTAMP() - DURATION('P180D')
      WITH c, card,
           MAX(card.credit_limit) AS credit_limit,
           MAX(t.amount) AS max_transaction,
           AVG(t.amount) AS avg_transaction
      WHERE max_transaction < credit_limit * 0.3 AND avg_transaction < credit_limit * 0.1
      RETURN c.id, card.id AS card_id, credit_limit, max_transaction, avg_transaction,
             (credit_limit - max_transaction * 3) AS suggested_new_limit
      ORDER BY suggested_new_limit DESC
    notes: |
      **Use case:** Credit line management is a regulatory expectation under
      OCC guidance. Unused credit limits represent contingent exposure on the
      bank's balance sheet. Proactively reducing limits on cards where
      max usage < 30% of limit reduces capital requirements (Basel III RWA)
      while preserving adequate headroom for the customer.

      **Interpreting results:** `suggested_new_limit` is calculated as
      `credit_limit - max_transaction * 3`, providing a 3x buffer over peak
      usage. If `avg_transaction < credit_limit * 0.1`, the card is heavily
      underutilized. Review these cases for potential limit reduction or
      product migration to a lower-tier card.

  - description: "Detect refinancing opportunities via interest rate comparison"
    application: "Credit: Refinancing targeting"
    query: |
      MATCH (c:Customer)-[:HAS_LOAN]->(l:Loan)
      WHERE l.status = 'active' AND l.origination_date < TIMESTAMP() - DURATION('P730D')
        AND l.interest_rate > 7.0
      WITH c, l, l.interest_rate AS current_rate, 5.5 AS market_rate
      WHERE current_rate > market_rate + 1.0
      RETURN c.id, c.name, l.id AS loan_id, l.balance, current_rate, market_rate,
             (l.balance * (current_rate - market_rate) / 100) AS annual_savings_potential
      ORDER BY annual_savings_potential DESC
    notes: |
      **Use case:** Retention-driven refinancing targets customers paying
      above-market rates on seasoned loans (>2 years old). Offering a rate
      reduction before the customer shops competitors prevents attrition.
      The `annual_savings_potential` quantifies the value proposition for
      each customer, enabling prioritized outreach.

      **Interpreting results:** `annual_savings_potential` estimates yearly
      savings from the rate differential. Higher values represent stronger
      customer incentive to refinance. `current_rate > market_rate + 1.0`
      ensures only meaningful rate gaps are surfaced. Focus on high-balance
      loans first, as these generate the most significant savings.

  - description: "Analyze co-borrower relationships for joint credit assessment"
    application: "Credit: Co-borrower analysis"
    query: |
      MATCH (c1:Customer)-[:CO_BORROWER]->(l:Loan)<-[:CO_BORROWER]-(c2:Customer)
      WHERE c1.id < c2.id
      MATCH (c1)-[:HAS_ACCOUNT]->(a1:Account), (c2)-[:HAS_ACCOUNT]->(a2:Account)
      WITH c1, c2, l,
           AVG(a1.balance) AS c1_avg_balance,
           AVG(a2.balance) AS c2_avg_balance
      RETURN c1.id, c2.id, l.id AS loan_id, l.balance,
             c1_avg_balance, c2_avg_balance,
             (c1_avg_balance + c2_avg_balance) AS combined_liquidity
      ORDER BY combined_liquidity DESC
    notes: |
      **Use case:** Co-borrower analysis is essential for joint loan
      underwriting. Regulatory guidance requires assessing both borrowers'
      financial capacity. The graph pattern `c1 -> loan <- c2` naturally
      captures the co-borrower relationship, and joining each borrower's
      accounts provides a combined liquidity picture.

      **Interpreting results:** `combined_liquidity` sums both borrowers'
      average balances. Higher combined liquidity relative to `l.balance`
      indicates a safer loan. If one borrower's balance is significantly
      lower, that borrower represents a concentration risk. The `c1.id < c2.id`
      filter deduplicates pairs (avoids counting Alice-Bob and Bob-Alice).
